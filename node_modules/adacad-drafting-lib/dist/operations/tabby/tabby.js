"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tabby = void 0;
const draft_1 = require("../../draft");
const sequence_1 = require("../../sequence");
const operations_1 = require("../../operations");
const categories_1 = require("../categories");
const utils_1 = require("../../utils");
const name = "tabby";
const meta = {
    displayname: 'tabby',
    desc: 'Also known as plain weave. Plain weave is one of the most basic weave structures in which each weft thread passes over one warp end and under one warp end; the next weft pick follows the pattern on the alternate warp threads (over/under/over/under). Tabby variations include basket weave, rib weave, and rep weave. These derivatives can be generated by modifying the parameters',
    img: 'tabby.png',
    categories: [categories_1.structureOp],
    old_names: ['tabbyder']
};
//PARAMS
const warps_raised = {
    name: 'warps raised',
    type: 'number',
    min: 0,
    max: 5000,
    value: 1,
    dx: ""
};
const warps_lowered = {
    name: 'warps lowered',
    type: 'number',
    min: 0,
    max: 5000,
    value: 1,
    dx: ""
};
const base_pics = {
    name: 'base pics',
    type: 'number',
    min: 0,
    max: 5000,
    value: 1,
    dx: 'the number of pics upon which the first tabby pic will be repeated'
};
const alt_pics = {
    name: 'alt pics',
    type: 'number',
    min: 0,
    max: 5000,
    value: 1,
    dx: 'the number of pics upon which the repeat the alteranting pattern'
};
const params = [warps_raised, warps_lowered, base_pics, alt_pics];
//INLETS
const inlets = [];
const perform = (param_vals) => {
    const raised = (0, operations_1.getOpParamValById)(0, param_vals);
    const lowered = (0, operations_1.getOpParamValById)(1, param_vals);
    const rep = (0, operations_1.getOpParamValById)(2, param_vals);
    const alt_rep = (0, operations_1.getOpParamValById)(3, param_vals);
    const first_row = new sequence_1.Sequence.OneD();
    for (let j = 0; j < raised; j++) {
        first_row.push(1);
    }
    for (let j = 0; j < lowered; j++) {
        first_row.push(0);
    }
    const pattern = new sequence_1.Sequence.TwoD();
    for (let i = 0; i < rep; i++) {
        pattern.pushWeftSequence(first_row.val());
    }
    const inverted = first_row.invert().val();
    for (let i = 0; i < alt_rep; i++) {
        pattern.pushWeftSequence(inverted);
    }
    const draft = (0, draft_1.initDraftFromDrawdown)(pattern.export());
    return Promise.resolve([{ draft }]);
};
const generateName = (param_vals) => {
    return 'tabby(' + (0, operations_1.flattenParamVals)(param_vals) + ')';
};
const sizeCheck = (param_vals) => {
    const raised = (0, operations_1.getOpParamValById)(0, param_vals);
    const lowered = (0, operations_1.getOpParamValById)(1, param_vals);
    const rep = (0, operations_1.getOpParamValById)(2, param_vals);
    const alt_rep = (0, operations_1.getOpParamValById)(3, param_vals);
    const width = raised + lowered;
    const height = rep + alt_rep;
    return (width * height <= utils_1.defaults.max_area) ? true : false;
};
exports.tabby = { name, meta, params, inlets, perform, generateName, sizeCheck };
//# sourceMappingURL=tabby.js.map