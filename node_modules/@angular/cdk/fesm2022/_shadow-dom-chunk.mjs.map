{"version":3,"file":"_shadow-dom-chunk.mjs","sources":["../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/src/cdk/platform/features/shadow-dom.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nlet shadowDomIsSupported: boolean;\n\n/** Checks whether the user's browser support Shadow DOM. */\nexport function _supportsShadowDom(): boolean {\n  if (shadowDomIsSupported == null) {\n    const head = typeof document !== 'undefined' ? document.head : null;\n    shadowDomIsSupported = !!(head && ((head as any).createShadowRoot || head.attachShadow));\n  }\n\n  return shadowDomIsSupported;\n}\n\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nexport function _getShadowRoot(element: HTMLElement): ShadowRoot | null {\n  if (_supportsShadowDom()) {\n    const rootNode = element.getRootNode ? element.getRootNode() : null;\n\n    // Note that this should be caught by `_supportsShadowDom`, but some\n    // teams have been able to hit this code path on unsupported browsers.\n    if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n      return rootNode;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nexport function _getFocusedElementPierceShadowDom(): HTMLElement | null {\n  let activeElement =\n    typeof document !== 'undefined' && document\n      ? (document.activeElement as HTMLElement | null)\n      : null;\n\n  while (activeElement && activeElement.shadowRoot) {\n    const newActiveElement = activeElement.shadowRoot.activeElement as HTMLElement | null;\n    if (newActiveElement === activeElement) {\n      break;\n    } else {\n      activeElement = newActiveElement;\n    }\n  }\n\n  return activeElement;\n}\n\n/** Gets the target of an event while accounting for Shadow DOM. */\nexport function _getEventTarget<T extends EventTarget>(event: Event): T | null {\n  // If an event is bound outside the Shadow DOM, the `event.target` will\n  // point to the shadow root so we have to use `composedPath` instead.\n  return (event.composedPath ? event.composedPath()[0] : event.target) as T | null;\n}\n"],"names":["shadowDomIsSupported","_supportsShadowDom","head","document","createShadowRoot","attachShadow","_getShadowRoot","element","rootNode","getRootNode","ShadowRoot","_getFocusedElementPierceShadowDom","activeElement","shadowRoot","newActiveElement","_getEventTarget","event","composedPath","target"],"mappings":"AAQA,IAAIA,oBAA6B;SAGjBC,kBAAkBA,GAAA;EAChC,IAAID,oBAAoB,IAAI,IAAI,EAAE;IAChC,MAAME,IAAI,GAAG,OAAOC,QAAQ,KAAK,WAAW,GAAGA,QAAQ,CAACD,IAAI,GAAG,IAAI;AACnEF,IAAAA,oBAAoB,GAAG,CAAC,EAAEE,IAAI,KAAMA,IAAY,CAACE,gBAAgB,IAAIF,IAAI,CAACG,YAAY,CAAC,CAAC;AAC1F;AAEA,EAAA,OAAOL,oBAAoB;AAC7B;AAGM,SAAUM,cAAcA,CAACC,OAAoB,EAAA;EACjD,IAAIN,kBAAkB,EAAE,EAAE;AACxB,IAAA,MAAMO,QAAQ,GAAGD,OAAO,CAACE,WAAW,GAAGF,OAAO,CAACE,WAAW,EAAE,GAAG,IAAI;IAInE,IAAI,OAAOC,UAAU,KAAK,WAAW,IAAIA,UAAU,IAAIF,QAAQ,YAAYE,UAAU,EAAE;AACrF,MAAA,OAAOF,QAAQ;AACjB;AACF;AAEA,EAAA,OAAO,IAAI;AACb;SAMgBG,iCAAiCA,GAAA;AAC/C,EAAA,IAAIC,aAAa,GACf,OAAOT,QAAQ,KAAK,WAAW,IAAIA,QAAQ,GACtCA,QAAQ,CAACS,aAAoC,GAC9C,IAAI;AAEV,EAAA,OAAOA,aAAa,IAAIA,aAAa,CAACC,UAAU,EAAE;AAChD,IAAA,MAAMC,gBAAgB,GAAGF,aAAa,CAACC,UAAU,CAACD,aAAmC;IACrF,IAAIE,gBAAgB,KAAKF,aAAa,EAAE;AACtC,MAAA;AACF,KAAA,MAAO;AACLA,MAAAA,aAAa,GAAGE,gBAAgB;AAClC;AACF;AAEA,EAAA,OAAOF,aAAa;AACtB;AAGM,SAAUG,eAAeA,CAAwBC,KAAY,EAAA;AAGjE,EAAA,OAAQA,KAAK,CAACC,YAAY,GAAGD,KAAK,CAACC,YAAY,EAAE,CAAC,CAAC,CAAC,GAAGD,KAAK,CAACE,MAAM;AACrE;;;;"}