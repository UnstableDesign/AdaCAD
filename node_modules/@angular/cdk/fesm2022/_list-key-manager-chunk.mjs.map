{"version":3,"file":"_list-key-manager-chunk.mjs","sources":["../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/src/cdk/a11y/key-manager/list-key-manager.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  DOWN_ARROW,\n  END,\n  HOME,\n  LEFT_ARROW,\n  PAGE_DOWN,\n  PAGE_UP,\n  RIGHT_ARROW,\n  TAB,\n  UP_ARROW,\n  hasModifierKey,\n} from '../../keycodes';\nimport {EffectRef, Injector, QueryList, Signal, effect, isSignal, signal} from '@angular/core';\nimport {Subject, Subscription} from 'rxjs';\nimport {Typeahead} from './typeahead';\n\n/** This interface is for items that can be passed to a ListKeyManager. */\nexport interface ListKeyManagerOption {\n  /** Whether the option is disabled. */\n  disabled?: boolean;\n\n  /** Gets the label for this option. */\n  getLabel?(): string;\n}\n\n/** Modifier keys handled by the ListKeyManager. */\nexport type ListKeyManagerModifierKey = 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey';\n\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nexport class ListKeyManager<T extends ListKeyManagerOption> {\n  private _activeItemIndex = signal(-1);\n  private _activeItem = signal<T | null>(null);\n  private _wrap = false;\n  private _typeaheadSubscription = Subscription.EMPTY;\n  private _itemChangesSubscription?: Subscription;\n  private _vertical = true;\n  private _horizontal: 'ltr' | 'rtl' | null;\n  private _allowedModifierKeys: ListKeyManagerModifierKey[] = [];\n  private _homeAndEnd = false;\n  private _pageUpAndDown = {enabled: false, delta: 10};\n  private _effectRef: EffectRef | undefined;\n  private _typeahead?: Typeahead<T>;\n\n  /**\n   * Predicate function that can be used to check whether an item should be skipped\n   * by the key manager. By default, disabled items are skipped.\n   */\n  private _skipPredicateFn = (item: T) => item.disabled;\n\n  constructor(items: QueryList<T> | T[] | readonly T[]);\n  constructor(items: Signal<T[]> | Signal<readonly T[]>, injector: Injector);\n  constructor(\n    private _items: QueryList<T> | T[] | readonly T[] | Signal<T[]> | Signal<readonly T[]>,\n    injector?: Injector,\n  ) {\n    // We allow for the items to be an array because, in some cases, the consumer may\n    // not have access to a QueryList of the items they want to manage (e.g. when the\n    // items aren't being collected via `ViewChildren` or `ContentChildren`).\n    if (_items instanceof QueryList) {\n      this._itemChangesSubscription = _items.changes.subscribe((newItems: QueryList<T>) =>\n        this._itemsChanged(newItems.toArray()),\n      );\n    } else if (isSignal(_items)) {\n      if (!injector && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw new Error('ListKeyManager constructed with a signal must receive an injector');\n      }\n\n      this._effectRef = effect(() => this._itemsChanged(_items()), {injector});\n    }\n  }\n\n  /**\n   * Stream that emits any time the TAB key is pressed, so components can react\n   * when focus is shifted off of the list.\n   */\n  readonly tabOut = new Subject<void>();\n\n  /** Stream that emits whenever the active item of the list manager changes. */\n  readonly change = new Subject<number>();\n\n  /**\n   * Sets the predicate function that determines which items should be skipped by the\n   * list key manager.\n   * @param predicate Function that determines whether the given item should be skipped.\n   */\n  skipPredicate(predicate: (item: T) => boolean): this {\n    this._skipPredicateFn = predicate;\n    return this;\n  }\n\n  /**\n   * Configures wrapping mode, which determines whether the active item will wrap to\n   * the other end of list when there are no more items in the given direction.\n   * @param shouldWrap Whether the list should wrap when reaching the end.\n   */\n  withWrap(shouldWrap = true): this {\n    this._wrap = shouldWrap;\n    return this;\n  }\n\n  /**\n   * Configures whether the key manager should be able to move the selection vertically.\n   * @param enabled Whether vertical selection should be enabled.\n   */\n  withVerticalOrientation(enabled: boolean = true): this {\n    this._vertical = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to move the selection horizontally.\n   * Passing in `null` will disable horizontal movement.\n   * @param direction Direction in which the selection can be moved.\n   */\n  withHorizontalOrientation(direction: 'ltr' | 'rtl' | null): this {\n    this._horizontal = direction;\n    return this;\n  }\n\n  /**\n   * Modifier keys which are allowed to be held down and whose default actions will be prevented\n   * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n   */\n  withAllowedModifierKeys(keys: ListKeyManagerModifierKey[]): this {\n    this._allowedModifierKeys = keys;\n    return this;\n  }\n\n  /**\n   * Turns on typeahead mode which allows users to set the active item by typing.\n   * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n   */\n  withTypeAhead(debounceInterval: number = 200): this {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const items = this._getItemsArray();\n      if (items.length > 0 && items.some(item => typeof item.getLabel !== 'function')) {\n        throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n      }\n    }\n\n    this._typeaheadSubscription.unsubscribe();\n\n    const items = this._getItemsArray();\n    this._typeahead = new Typeahead(items, {\n      debounceInterval: typeof debounceInterval === 'number' ? debounceInterval : undefined,\n      skipPredicate: item => this._skipPredicateFn(item),\n    });\n\n    this._typeaheadSubscription = this._typeahead.selectedItem.subscribe(item => {\n      this.setActiveItem(item);\n    });\n\n    return this;\n  }\n\n  /** Cancels the current typeahead sequence. */\n  cancelTypeahead(): this {\n    this._typeahead?.reset();\n    return this;\n  }\n\n  /**\n   * Configures the key manager to activate the first and last items\n   * respectively when the Home or End key is pressed.\n   * @param enabled Whether pressing the Home or End key activates the first/last item.\n   */\n  withHomeAndEnd(enabled: boolean = true): this {\n    this._homeAndEnd = enabled;\n    return this;\n  }\n\n  /**\n   * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n   * respectively when the Page-Up or Page-Down key is pressed.\n   * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n   * @param delta Whether pressing the Home or End key activates the first/last item.\n   */\n  withPageUpDown(enabled: boolean = true, delta: number = 10): this {\n    this._pageUpAndDown = {enabled, delta};\n    return this;\n  }\n\n  /**\n   * Sets the active item to the item at the index specified.\n   * @param index The index of the item to be set as active.\n   */\n  setActiveItem(index: number): void;\n\n  /**\n   * Sets the active item to the specified item.\n   * @param item The item to be set as active.\n   */\n  setActiveItem(item: T): void;\n\n  /**\n   * Sets the active item to the specified item.\n   * @param item The item to be set as active.\n   */\n  setActiveItem(item: T | number): void;\n\n  setActiveItem(item: any): void {\n    const previousActiveItem = this._activeItem();\n\n    this.updateActiveItem(item);\n\n    if (this._activeItem() !== previousActiveItem) {\n      this.change.next(this._activeItemIndex());\n    }\n  }\n\n  /**\n   * Sets the active item depending on the key event passed in.\n   * @param event Keyboard event to be used for determining which element should be active.\n   */\n  onKeydown(event: KeyboardEvent): void {\n    const keyCode = event.keyCode;\n    const modifiers: ListKeyManagerModifierKey[] = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n    const isModifierAllowed = modifiers.every(modifier => {\n      return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n    });\n\n    switch (keyCode) {\n      case TAB:\n        this.tabOut.next();\n        return;\n\n      case DOWN_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case UP_ARROW:\n        if (this._vertical && isModifierAllowed) {\n          this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case RIGHT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case LEFT_ARROW:\n        if (this._horizontal && isModifierAllowed) {\n          this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case HOME:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setFirstItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case END:\n        if (this._homeAndEnd && isModifierAllowed) {\n          this.setLastItemActive();\n          break;\n        } else {\n          return;\n        }\n\n      case PAGE_UP:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex() - this._pageUpAndDown.delta;\n          this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n          break;\n        } else {\n          return;\n        }\n\n      case PAGE_DOWN:\n        if (this._pageUpAndDown.enabled && isModifierAllowed) {\n          const targetIndex = this._activeItemIndex() + this._pageUpAndDown.delta;\n          const itemsLength = this._getItemsArray().length;\n          this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n          break;\n        } else {\n          return;\n        }\n\n      default:\n        if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n          this._typeahead?.handleKey(event);\n        }\n\n        // Note that we return here, in order to avoid preventing\n        // the default action of non-navigational keys.\n        return;\n    }\n\n    this._typeahead?.reset();\n    event.preventDefault();\n  }\n\n  /** Index of the currently active item. */\n  get activeItemIndex(): number | null {\n    return this._activeItemIndex();\n  }\n\n  /** The active item. */\n  get activeItem(): T | null {\n    return this._activeItem();\n  }\n\n  /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n  isTyping(): boolean {\n    return !!this._typeahead && this._typeahead.isTyping();\n  }\n\n  /** Sets the active item to the first enabled item in the list. */\n  setFirstItemActive(): void {\n    this._setActiveItemByIndex(0, 1);\n  }\n\n  /** Sets the active item to the last enabled item in the list. */\n  setLastItemActive(): void {\n    this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);\n  }\n\n  /** Sets the active item to the next enabled item in the list. */\n  setNextItemActive(): void {\n    this._activeItemIndex() < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n  }\n\n  /** Sets the active item to a previous enabled item in the list. */\n  setPreviousItemActive(): void {\n    this._activeItemIndex() < 0 && this._wrap\n      ? this.setLastItemActive()\n      : this._setActiveItemByDelta(-1);\n  }\n\n  /**\n   * Allows setting the active without any other effects.\n   * @param index Index of the item to be set as active.\n   */\n  updateActiveItem(index: number): void;\n\n  /**\n   * Allows setting the active item without any other effects.\n   * @param item Item to be set as active.\n   */\n  updateActiveItem(item: T): void;\n\n  updateActiveItem(item: any): void {\n    const itemArray = this._getItemsArray();\n    const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n    const activeItem = itemArray[index];\n\n    // Explicitly check for `null` and `undefined` because other falsy values are valid.\n    this._activeItem.set(activeItem == null ? null : activeItem);\n    this._activeItemIndex.set(index);\n    this._typeahead?.setCurrentSelectedItemIndex(index);\n  }\n\n  /** Cleans up the key manager. */\n  destroy() {\n    this._typeaheadSubscription.unsubscribe();\n    this._itemChangesSubscription?.unsubscribe();\n    this._effectRef?.destroy();\n    this._typeahead?.destroy();\n    this.tabOut.complete();\n    this.change.complete();\n  }\n\n  /**\n   * This method sets the active item, given a list of items and the delta between the\n   * currently active item and the new active item. It will calculate differently\n   * depending on whether wrap mode is turned on.\n   */\n  private _setActiveItemByDelta(delta: -1 | 1): void {\n    this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n  }\n\n  /**\n   * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n   * down the list until it finds an item that is not disabled, and it will wrap if it\n   * encounters either end of the list.\n   */\n  private _setActiveInWrapMode(delta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    for (let i = 1; i <= items.length; i++) {\n      const index = (this._activeItemIndex() + delta * i + items.length) % items.length;\n      const item = items[index];\n\n      if (!this._skipPredicateFn(item)) {\n        this.setActiveItem(index);\n        return;\n      }\n    }\n  }\n\n  /**\n   * Sets the active item properly given the default mode. In other words, it will\n   * continue to move down the list until it finds an item that is not disabled. If\n   * it encounters either end of the list, it will stop and not wrap.\n   */\n  private _setActiveInDefaultMode(delta: -1 | 1): void {\n    this._setActiveItemByIndex(this._activeItemIndex() + delta, delta);\n  }\n\n  /**\n   * Sets the active item to the first enabled item starting at the index specified. If the\n   * item is disabled, it will move in the fallbackDelta direction until it either\n   * finds an enabled item or encounters the end of the list.\n   */\n  private _setActiveItemByIndex(index: number, fallbackDelta: -1 | 1): void {\n    const items = this._getItemsArray();\n\n    if (!items[index]) {\n      return;\n    }\n\n    while (this._skipPredicateFn(items[index])) {\n      index += fallbackDelta;\n\n      if (!items[index]) {\n        return;\n      }\n    }\n\n    this.setActiveItem(index);\n  }\n\n  /** Returns the items as an array. */\n  private _getItemsArray(): T[] | readonly T[] {\n    if (isSignal(this._items)) {\n      return this._items();\n    }\n\n    return this._items instanceof QueryList ? this._items.toArray() : this._items;\n  }\n\n  /** Callback for when the items have changed. */\n  private _itemsChanged(newItems: T[] | readonly T[]) {\n    this._typeahead?.setItems(newItems);\n    const activeItem = this._activeItem();\n    if (activeItem) {\n      const newIndex = newItems.indexOf(activeItem);\n\n      if (newIndex > -1 && newIndex !== this._activeItemIndex()) {\n        this._activeItemIndex.set(newIndex);\n        this._typeahead?.setCurrentSelectedItemIndex(newIndex);\n      }\n    }\n  }\n}\n"],"names":["ListKeyManager","_items","_activeItemIndex","signal","_activeItem","_wrap","_typeaheadSubscription","Subscription","EMPTY","_itemChangesSubscription","_vertical","_horizontal","_allowedModifierKeys","_homeAndEnd","_pageUpAndDown","enabled","delta","_effectRef","_typeahead","_skipPredicateFn","item","disabled","constructor","injector","QueryList","changes","subscribe","newItems","_itemsChanged","toArray","isSignal","ngDevMode","Error","effect","debugName","tabOut","Subject","change","skipPredicate","predicate","withWrap","shouldWrap","withVerticalOrientation","withHorizontalOrientation","direction","withAllowedModifierKeys","keys","withTypeAhead","debounceInterval","items","_getItemsArray","length","some","getLabel","unsubscribe","Typeahead","undefined","selectedItem","setActiveItem","cancelTypeahead","reset","withHomeAndEnd","withPageUpDown","previousActiveItem","updateActiveItem","next","onKeydown","event","keyCode","modifiers","isModifierAllowed","every","modifier","indexOf","TAB","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","RIGHT_ARROW","LEFT_ARROW","HOME","setFirstItemActive","END","setLastItemActive","PAGE_UP","targetIndex","_setActiveItemByIndex","PAGE_DOWN","itemsLength","hasModifierKey","handleKey","preventDefault","activeItemIndex","activeItem","isTyping","_setActiveItemByDelta","itemArray","index","set","setCurrentSelectedItemIndex","destroy","complete","_setActiveInWrapMode","_setActiveInDefaultMode","i","fallbackDelta","setItems","newIndex"],"mappings":"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"}