{"version":3,"file":"angular-fire-compat-firestore.mjs","sources":["../../../src/compat/firestore/observable/fromRef.ts","../../../src/compat/firestore/document/document.ts","../../../src/compat/firestore/collection/changes.ts","../../../src/compat/firestore/collection/collection.ts","../../../src/compat/firestore/collection-group/collection-group.ts","../../../src/compat/firestore/firestore.ts","../../../src/compat/firestore/firestore.module.ts","../../../src/compat/firestore/angular-fire-compat-firestore.ts"],"sourcesContent":["import { Observable, SchedulerLike, asyncScheduler } from 'rxjs';\nimport { map, pairwise, startWith } from 'rxjs/operators';\nimport { Action, DocumentReference, DocumentSnapshot, Query, QuerySnapshot, Reference } from '../interfaces';\n\nfunction _fromRef<R>(ref: Reference, scheduler: SchedulerLike = asyncScheduler): Observable<R> {\n  return new Observable(subscriber => {\n    let unsubscribe: () => void;\n    if (scheduler != null) {\n      scheduler.schedule(() => {\n        unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n      });\n    } else {\n      unsubscribe = ref.onSnapshot({ includeMetadataChanges: true }, subscriber);\n    }\n\n    return () => {\n      if (unsubscribe != null) {\n        unsubscribe();\n      }\n    };\n  });\n}\n\nexport function fromRef<R, T>(ref: DocumentReference<T> | Query<T>, scheduler?: SchedulerLike) {\n  return _fromRef<R>(ref, scheduler);\n}\n\nexport function fromDocRef<T>(ref: DocumentReference<T>, scheduler?: SchedulerLike): Observable<Action<DocumentSnapshot<T>>> {\n  return fromRef<DocumentSnapshot<T>, T>(ref, scheduler)\n    .pipe(\n      startWith<DocumentSnapshot<T>, undefined>(undefined),\n      pairwise(),\n      map((snapshots: [DocumentSnapshot<T>, DocumentSnapshot<T>]) => {\n        const [priorPayload, payload] = snapshots;\n        if (!payload.exists) {\n          return { payload, type: 'removed' };\n        }\n        if (!priorPayload?.exists) {\n          return { payload, type: 'added' };\n        }\n        return { payload, type: 'modified' };\n      })\n    );\n}\n\nexport function fromCollectionRef<T>(ref: Query<T>, scheduler?: SchedulerLike): Observable<Action<QuerySnapshot<T>>> {\n  return fromRef<QuerySnapshot<T>, T>(ref, scheduler).pipe(map(payload => ({ payload, type: 'query' })));\n}\n","import { EnvironmentInjector, inject } from '@angular/core';\nimport { pendingUntilEvent } from '@angular/core/rxjs-interop';\nimport firebase from 'firebase/compat/app';\nimport { Observable, from } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { AngularFirestoreCollection } from '../collection/collection';\nimport { AngularFirestore, associateQuery } from '../firestore';\nimport { Action, DocumentData, DocumentReference, DocumentSnapshot, QueryFn, SetOptions } from '../interfaces';\nimport { fromDocRef } from '../observable/fromRef';\n\n/**\n * AngularFirestoreDocument service\n *\n * This class creates a reference to a Firestore Document. A reference is provided in\n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const fakeStock = new AngularFirestoreDocument<Stock>(doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => {\n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nexport class AngularFirestoreDocument<T = DocumentData> {\n  private readonly injector = inject(EnvironmentInjector);\n\n  /**\n   * The constructor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   */\n  constructor(public ref: DocumentReference<T>, private afs: AngularFirestore) { }\n\n  /**\n   * Create or overwrite a single document.\n   */\n  set(data: T, options?: SetOptions): Promise<void> {\n    return this.ref.set(data, options);\n  }\n\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   */\n  update(data: Partial<T>): Promise<void> {\n    return this.ref.update(data);\n  }\n\n  /**\n   * Delete a document.\n   */\n  delete(): Promise<void> {\n    return this.ref.delete();\n  }\n\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   */\n  collection<R = DocumentData>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<R> {\n    const collectionRef = this.ref.collection(path) as firebase.firestore.CollectionReference<R>;\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection(ref, query, this.afs);\n  }\n\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges(): Observable<Action<DocumentSnapshot<T>>> {\n    const scheduledFromDocRef$ = fromDocRef<T>(this.ref, this.afs.schedulers.outsideAngular);\n    return scheduledFromDocRef$.pipe(\n      pendingUntilEvent(this.injector)\n    );\n  }\n\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(options?: unknown): Observable<T | undefined>;\n  valueChanges<K extends string>(options: { idField: K }): Observable<(T & { [T in K]: string }) | undefined>;\n  valueChanges<K extends string>(options: { idField?: K } = {}): Observable<T | undefined> {\n    return this.snapshotChanges().pipe(\n      map(({ payload }) =>\n        options.idField ? {\n          ...payload.data(),\n          ...{ [options.idField]: payload.id }\n        } as T & { [T in K]: string } : payload.data()\n      )\n    );\n  }\n\n  /**\n   * Retrieve the document once.\n   */\n  get(options?: firebase.firestore.GetOptions) {\n    return from(this.ref.get(options)).pipe(\n      pendingUntilEvent(this.injector)\n    );\n  }\n}\n","import firebase from 'firebase/compat/app';\nimport { Observable, SchedulerLike } from 'rxjs';\nimport { distinctUntilChanged, map, pairwise, scan, startWith } from 'rxjs/operators';\nimport { Action, DocumentChange, DocumentChangeAction, DocumentChangeType, Query, QuerySnapshot } from '../interfaces';\nimport { fromCollectionRef } from '../observable/fromRef';\n\n\ntype ActionTupe = [Action<QuerySnapshot<firebase.firestore.DocumentData>>, Action<QuerySnapshot<firebase.firestore.DocumentData>>]\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n */\nexport function docChanges<T>(query: Query, scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return fromCollectionRef(query, scheduler)\n    .pipe(\n      startWith<Action<QuerySnapshot<firebase.firestore.DocumentData>>, undefined>(undefined),\n      pairwise(),\n      map((actionTuple: ActionTupe) => {\n        const [priorAction, action] = actionTuple;\n        const docChanges = action.payload.docChanges();\n        const actions = docChanges.map(change => ({ type: change.type, payload: change }));\n        // the metadata has changed from the prior emission\n        if (priorAction && JSON.stringify(priorAction.payload.metadata) !== JSON.stringify(action.payload.metadata)) {\n          // go through all the docs in payload and figure out which ones changed\n          action.payload.docs.forEach((currentDoc, currentIndex) => {\n            const docChange = docChanges.find(d => d.doc.ref.isEqual(currentDoc.ref));\n            const priorDoc = priorAction?.payload.docs.find(d => d.ref.isEqual(currentDoc.ref));\n            if (docChange && JSON.stringify(docChange.doc.metadata) === JSON.stringify(currentDoc.metadata) ||\n              !docChange && priorDoc && JSON.stringify(priorDoc.metadata) === JSON.stringify(currentDoc.metadata)) {\n              // document doesn't appear to have changed, don't log another action\n            } else {\n              // since the actions are processed in order just push onto the array\n              actions.push({\n                type: 'modified',\n                payload: {\n                  oldIndex: currentIndex,\n                  newIndex: currentIndex,\n                  type: 'modified',\n                  doc: currentDoc\n                }\n              });\n            }\n          });\n        }\n        return actions as DocumentChangeAction<T>[];\n      }),\n  );\n}\n\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n */\nexport function sortedChanges<T>(\n  query: Query,\n  events: DocumentChangeType[],\n  scheduler?: SchedulerLike): Observable<DocumentChangeAction<T>[]> {\n  return docChanges<T>(query, scheduler)\n    .pipe(\n      scan((current, changes) => combineChanges<T>(current, changes.map(it => it.payload), events), []),\n      distinctUntilChanged(), // cut down on unneed change cycles\n      map(changes => changes.map(c => ({ type: c.type, payload: c } as DocumentChangeAction<T>))));\n}\n\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n */\nexport function combineChanges<T>(current: DocumentChange<T>[], changes: DocumentChange<T>[], events: DocumentChangeType[]) {\n  changes.forEach(change => {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\n\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice<T>(\n  original: T[],\n  start: number,\n  deleteCount: number,\n  ...args: T[]\n): T[] {\n  const returnArray = original.slice();\n  returnArray.splice(start, deleteCount, ...args);\n  return returnArray;\n}\n\n/**\n * Creates a new sorted array from a new change.\n * Build our own because we allow filtering of action types ('added', 'removed', 'modified') before scanning\n * and so we have greater control over change detection (by breaking ===)\n */\nexport function combineChange<T>(combined: DocumentChange<T>[], change: DocumentChange<T>): DocumentChange<T>[] {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex]?.doc.ref.isEqual(change.doc.ref)) {\n        // Not sure why the duplicates are getting fired\n      } else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          const copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex]?.doc.ref.isEqual(change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n","import { EnvironmentInjector, inject } from '@angular/core';\nimport { pendingUntilEvent } from '@angular/core/rxjs-interop';\nimport firebase from 'firebase/compat/app';\nimport { Observable, from } from 'rxjs';\nimport { filter, map, pairwise, scan, startWith } from 'rxjs/operators';\nimport { AngularFirestoreDocument } from '../document/document';\nimport { AngularFirestore } from '../firestore';\nimport { CollectionReference, DocumentChangeAction, DocumentChangeType, DocumentData, DocumentReference, Query } from '../interfaces';\nimport { fromCollectionRef } from '../observable/fromRef';\nimport { docChanges, sortedChanges } from './changes';\n\ntype DocumentChangeTuple<T> = [DocumentChangeAction<T>[], DocumentChangeAction<T>[]];\n\nexport function validateEventsArray(events?: DocumentChangeType[]) {\n  if (!events || events.length === 0) {\n    events = ['added', 'removed', 'modified'];\n  }\n  return events;\n}\n\n/**\n * AngularFirestoreCollection service\n *\n * This class creates a reference to a Firestore Collection. A reference and a query are provided in\n * in the constructor. The query can be the unqueried reference if no query is desired.The class\n * is generic which gives you type safety for data update methods and data streaming.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionRef = firebase.firestore.collection('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollection<Stock>(collectionRef, query);\n *\n * // NOTE!: the updates are performed on the reference not the query\n * await fakeStock.add({ name: 'FAKE', price: 0.01 });\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollection<T = DocumentData> {\n  private readonly injector = inject(EnvironmentInjector);\n\n  /**\n   * The constructor takes in a CollectionReference and Query to provide wrapper methods\n   * for data operations and data streaming.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query. See the AssociatedRefence type for details\n   * on this implication.\n   */\n  constructor(\n    public readonly ref: CollectionReference<T>,\n    private readonly query: Query<T>,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    let source = docChanges<T>(this.query, this.afs.schedulers.outsideAngular);\n    if (events && events.length > 0) {\n      source = source.pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1))\n      );\n    }\n    return source.pipe(\n      // We want to filter out empty arrays, but always emit at first, so the developer knows\n      // that the collection has been resolve; even if it's empty\n      startWith<DocumentChangeAction<T>[], undefined>(undefined),\n      pairwise(),\n      filter(([prior, current]: DocumentChangeTuple<T>) => current.length > 0 || !prior),\n      map(([, current]) => current),\n      pendingUntilEvent(this.injector)\n    );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      pendingUntilEvent(this.injector)\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(): Observable<T[]>;\n  // eslint-disable-next-line no-empty-pattern\n  valueChanges({}): Observable<T[]>;\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>;\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    return fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              ...a.data() as any,\n              ...{ [options.idField]: a.id }\n            } as T & { [T in K]: string };\n          } else {\n            return a.data();\n          }\n        })),\n        pendingUntilEvent(this.injector)\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options?: firebase.firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      pendingUntilEvent(this.injector)\n    );\n  }\n\n  /**\n   * Add data to a collection reference.\n   *\n   * Note: Data operation methods are done on the reference not the query. This means\n   * when you update data it is not updating data to the window of your query unless\n   * the data fits the criteria of the query.\n   */\n  add(data: T): Promise<DocumentReference<T>> {\n    return this.ref.add(data);\n  }\n\n  /**\n   * Create a reference to a single document in a collection.\n   */\n  doc<T2 = T>(path?: string): AngularFirestoreDocument<T2> {\n    // TODO is there a better way to solve this type issue\n    return new AngularFirestoreDocument(this.ref.doc(path) as any, this.afs);\n  }\n}\n","import { EnvironmentInjector, inject } from '@angular/core';\nimport { pendingUntilEvent } from '@angular/core/rxjs-interop';\nimport firebase from 'firebase/compat/app';\nimport { Observable, from } from 'rxjs';\nimport { filter, map, scan } from 'rxjs/operators';\nimport { docChanges, sortedChanges } from '../collection/changes';\nimport { validateEventsArray } from '../collection/collection';\nimport { AngularFirestore } from '../firestore';\nimport { DocumentChangeAction, DocumentChangeType, DocumentData, Query } from '../interfaces';\nimport { fromCollectionRef } from '../observable/fromRef';\n\n/**\n * AngularFirestoreCollectionGroup service\n *\n * This class holds a reference to a Firestore Collection Group Query.\n *\n * This class uses Symbol.observable to transform into Observable using Observable.from().\n *\n * This class is rarely used directly and should be created from the AngularFirestore service.\n *\n * Example:\n *\n * const collectionGroup = firebase.firestore.collectionGroup('stocks');\n * const query = collectionRef.where('price', '>', '0.01');\n * const fakeStock = new AngularFirestoreCollectionGroup<Stock>(query, afs);\n *\n * // Subscribe to changes as snapshots. This provides you data updates as well as delta updates.\n * fakeStock.valueChanges().subscribe(value => console.log(value));\n */\nexport class AngularFirestoreCollectionGroup<T = DocumentData> {\n  private readonly injector = inject(EnvironmentInjector);\n\n  /**\n   * The constructor takes in a CollectionGroupQuery to provide wrapper methods\n   * for data operations and data streaming.\n   */\n  constructor(\n    private readonly query: Query<T>,\n    private readonly afs: AngularFirestore) { }\n\n  /**\n   * Listen to the latest change in the stream. This method returns changes\n   * as they occur and they are not sorted by query order. This allows you to construct\n   * your own data structure.\n   */\n  stateChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    if (!events || events.length === 0) {\n      return docChanges<T>(this.query, this.afs.schedulers.outsideAngular).pipe(\n        pendingUntilEvent(this.injector)\n      );\n    }\n    return docChanges<T>(this.query, this.afs.schedulers.outsideAngular)\n      .pipe(\n        map(actions => actions.filter(change => events.indexOf(change.type) > -1)),\n        filter(changes =>  changes.length > 0),\n        pendingUntilEvent(this.injector)\n      );\n  }\n\n  /**\n   * Create a stream of changes as they occur it time. This method is similar to stateChanges()\n   * but it collects each event in an array over time.\n   */\n  auditTrail(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    return this.stateChanges(events).pipe(scan((current, action) => [...current, ...action], []));\n  }\n\n  /**\n   * Create a stream of synchronized changes. This method keeps the local array in sorted\n   * query order.\n   */\n  snapshotChanges(events?: DocumentChangeType[]): Observable<DocumentChangeAction<T>[]> {\n    const validatedEvents = validateEventsArray(events);\n    const scheduledSortedChanges$ = sortedChanges<T>(this.query, validatedEvents, this.afs.schedulers.outsideAngular);\n    return scheduledSortedChanges$.pipe(\n      pendingUntilEvent(this.injector)\n    );\n  }\n\n  /**\n   * Listen to all documents in the collection and its possible query as an Observable.\n   *\n   * If the `idField` option is provided, document IDs are included and mapped to the\n   * provided `idField` property name.\n   */\n  valueChanges(): Observable<T[]>;\n  // eslint-disable-next-line no-empty-pattern\n  valueChanges({}): Observable<T[]>;\n  valueChanges<K extends string>(options: {idField: K}): Observable<(T & { [T in K]: string })[]>;\n  valueChanges<K extends string>(options: {idField?: K} = {}): Observable<T[]> {\n    const fromCollectionRefScheduled$ = fromCollectionRef<T>(this.query, this.afs.schedulers.outsideAngular);\n    return fromCollectionRefScheduled$\n      .pipe(\n        map(actions => actions.payload.docs.map(a => {\n          if (options.idField) {\n            return {\n              [options.idField]: a.id,\n              ...a.data()\n            } as T & { [T in K]: string };\n          } else {\n            return a.data();\n          }\n        })),\n        pendingUntilEvent(this.injector)\n      );\n  }\n\n  /**\n   * Retrieve the results of the query once.\n   */\n  get(options?: firebase.firestore.GetOptions) {\n    return from(this.query.get(options)).pipe(\n      pendingUntilEvent(this.injector)\n    );\n  }\n\n}\n","import { isPlatformServer } from '@angular/common';\nimport { Inject, Injectable, InjectionToken, NgZone, Optional, PLATFORM_ID, inject } from '@angular/core';\nimport { ɵAngularFireSchedulers } from '@angular/fire';\nimport { AppCheckInstances } from '@angular/fire/app-check';\nimport { FIREBASE_APP_NAME, FIREBASE_OPTIONS, ɵcacheInstance, ɵfirebaseAppFactory } from '@angular/fire/compat';\nimport {\n  SETTINGS as AUTH_SETTINGS,\n  AngularFireAuth,\n  LANGUAGE_CODE,\n  PERSISTENCE,\n  TENANT_ID,\n  USE_EMULATOR as USE_AUTH_EMULATOR,\n  USE_DEVICE_LANGUAGE,\n  ɵauthFactory,\n} from '@angular/fire/compat/auth';\nimport { FirebaseOptions } from 'firebase/app';\nimport firebase from 'firebase/compat/app';\nimport { Observable, from, of } from 'rxjs';\nimport { AngularFirestoreCollection } from './collection/collection';\nimport { AngularFirestoreCollectionGroup } from './collection-group/collection-group';\nimport { AngularFirestoreDocument } from './document/document';\nimport {\n  AssociatedReference,\n  CollectionReference,\n  DocumentReference,\n  PersistenceSettings,\n  Query,\n  QueryFn,\n  QueryGroupFn,\n  Settings\n} from './interfaces';\nimport 'firebase/compat/auth';\nimport 'firebase/compat/firestore';\n\n/**\n * The value of this token determines whether or not the firestore will have persistance enabled\n */\nexport const ENABLE_PERSISTENCE = new InjectionToken<boolean>('angularfire2.enableFirestorePersistence');\nexport const PERSISTENCE_SETTINGS = new InjectionToken<PersistenceSettings | undefined>('angularfire2.firestore.persistenceSettings');\nexport const SETTINGS = new InjectionToken<Settings>('angularfire2.firestore.settings');\n\ntype UseEmulatorArguments = Parameters<firebase.firestore.Firestore['useEmulator']>;\nexport const USE_EMULATOR = new InjectionToken<UseEmulatorArguments>('angularfire2.firestore.use-emulator');\n\n/**\n * A utility methods for associating a collection reference with\n * a query.\n *\n * @param collectionRef - A collection reference to query\n * @param queryFn - The callback to create a query\n *\n * Example:\n * const { query, ref } = associateQuery(docRef.collection('items'), ref => {\n *  return ref.where('age', '<', 200);\n * });\n */\nexport function associateQuery<T>(collectionRef: CollectionReference<T>, queryFn = ref => ref): AssociatedReference<T> {\n  const query = queryFn(collectionRef);\n  const ref = collectionRef;\n  return { query, ref };\n}\n\n/**\n * AngularFirestore Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for creating Collection and Reference services. These services can\n * then be used to do data updates and observable streams of the data.\n *\n * Example:\n *\n * import { Component } from '@angular/core';\n * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '@angular/fire/firestore';\n * import { Observable } from 'rxjs/Observable';\n * import { from } from 'rxjs/observable';\n *\n * @Component({\n *   selector: 'app-my-component',\n *   template: `\n *    <h2>Items for {{ (profile | async)?.name }}\n *    <ul>\n *       <li *ngFor=\"let item of items | async\">{{ item.name }}</li>\n *    </ul>\n *    <div class=\"control-input\">\n *       <input type=\"text\" #itemname />\n *       <button (click)=\"addItem(itemname.value)\">Add Item</button>\n *    </div>\n *   `\n * })\n * export class MyComponent implements OnInit {\n *\n *   // services for data operations and data streaming\n *   private readonly itemsRef: AngularFirestoreCollection<Item>;\n *   private readonly profileRef: AngularFirestoreDocument<Profile>;\n *\n *   // observables for template\n *   items: Observable<Item[]>;\n *   profile: Observable<Profile>;\n *\n *   // inject main service\n *   constructor(private readonly afs: AngularFirestore) {}\n *\n *   ngOnInit() {\n *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));\n *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));\n *     // this.items = from(this.itemsRef); // you can also do this with no mapping\n *\n *     this.profileRef = afs.doc('users/davideast');\n *     this.profile = this.profileRef.valueChanges();\n *   }\n *\n *   addItem(name: string) {\n *     const user = 'davideast';\n *     this.itemsRef.add({ name, user });\n *   }\n * }\n */\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFirestore {\n  public readonly firestore: firebase.firestore.Firestore;\n  public readonly persistenceEnabled$: Observable<boolean>;\n  private readonly ngZone = inject(NgZone);\n\n  /**\n   * Each Feature of AngularFire has a FirebaseApp injected. This way we\n   * don't rely on the main Firebase App instance and we can create named\n   * apps and use multiple apps.\n   */\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options: FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) name: string | null | undefined,\n    @Optional() @Inject(ENABLE_PERSISTENCE) shouldEnablePersistence: boolean | null,\n    @Optional() @Inject(SETTINGS) settings: Settings | null,\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone,\n    public schedulers: ɵAngularFireSchedulers,\n    @Optional() @Inject(PERSISTENCE_SETTINGS) persistenceSettings: PersistenceSettings | null,\n    @Optional() @Inject(USE_EMULATOR) _useEmulator: any,\n    @Optional() auth: AngularFireAuth,\n    @Optional() @Inject(USE_AUTH_EMULATOR) useAuthEmulator: any,\n    @Optional() @Inject(AUTH_SETTINGS) authSettings: any, // can't use firebase.auth.AuthSettings here\n    @Optional() @Inject(TENANT_ID) tenantId: string | null,\n    @Optional() @Inject(LANGUAGE_CODE) languageCode: string | null,\n    @Optional() @Inject(USE_DEVICE_LANGUAGE) useDeviceLanguage: boolean | null,\n    @Optional() @Inject(PERSISTENCE) persistence: string | null,\n    @Optional() _appCheckInstances: AppCheckInstances,\n  ) {\n    const app = ɵfirebaseAppFactory(options, zone, name);\n    const useEmulator: UseEmulatorArguments | null = _useEmulator;\n\n    if (auth) {\n      ɵauthFactory(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);\n    }\n\n    [this.firestore, this.persistenceEnabled$] = ɵcacheInstance(`${app.name}.firestore`, 'AngularFirestore', app.name, () => {\n      const firestore = zone.runOutsideAngular(() => app.firestore());\n      if (settings) {\n        firestore.settings(settings);\n      }\n      if (useEmulator) {\n        firestore.useEmulator(...useEmulator);\n      }\n\n      if (shouldEnablePersistence && !isPlatformServer(platformId)) {\n        // We need to try/catch here because not all enablePersistence() failures are caught\n        // https://github.com/firebase/firebase-js-sdk/issues/608\n        const enablePersistence = () => {\n          try {\n            return from(firestore.enablePersistence(persistenceSettings || undefined).then(() => true, () => false));\n          } catch (e) {\n            if (typeof console !== 'undefined') { console.warn(e); }\n            return of(false);\n          }\n        };\n        return [firestore, zone.runOutsideAngular(enablePersistence)];\n      } else {\n        return [firestore, of(false)];\n      }\n\n    }, [settings, useEmulator, shouldEnablePersistence]);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection based on a path or\n   * CollectionReference and an optional query function to narrow the result\n   * set.\n   */\n  collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n  collection<T>(ref: CollectionReference, queryFn?: QueryFn): AngularFirestoreCollection<T>;\n  collection<T>(pathOrRef: string | CollectionReference<T>, queryFn?: QueryFn): AngularFirestoreCollection<T> {\n    let collectionRef: CollectionReference<T>;\n    if (typeof pathOrRef === 'string') {\n      collectionRef = this.firestore.collection(pathOrRef) as firebase.firestore.CollectionReference<T>;\n    } else {\n      collectionRef = pathOrRef;\n    }\n    const { ref, query } = associateQuery<T>(collectionRef, queryFn);\n    const refInZone = this.ngZone.run(() => ref);\n    return new AngularFirestoreCollection<T>(refInZone, query, this);\n  }\n\n  /**\n   * Create a reference to a Firestore Collection Group based on a collectionId\n   * and an optional query function to narrow the result\n   * set.\n   */\n  collectionGroup<T>(collectionId: string, queryGroupFn?: QueryGroupFn<T>): AngularFirestoreCollectionGroup<T> {\n    const queryFn = queryGroupFn || (ref => ref);\n    const collectionGroup: Query<T> = this.firestore.collectionGroup(collectionId) as firebase.firestore.Query<T>;\n    return new AngularFirestoreCollectionGroup<T>(queryFn(collectionGroup), this);\n  }\n\n  /**\n   * Create a reference to a Firestore Document based on a path or\n   * DocumentReference. Note that documents are not queryable because they are\n   * simply objects. However, documents have sub-collections that return a\n   * Collection reference and can be queried.\n   */\n  doc<T>(path: string): AngularFirestoreDocument<T>;\n  doc<T>(ref: DocumentReference): AngularFirestoreDocument<T>;\n  doc<T>(pathOrRef: string | DocumentReference<T>): AngularFirestoreDocument<T> {\n    let ref: DocumentReference<T>;\n    if (typeof pathOrRef === 'string') {\n      ref = this.firestore.doc(pathOrRef) as firebase.firestore.DocumentReference<T>;\n    } else {\n      ref = pathOrRef;\n    }\n    const refInZone = this.ngZone.run(() => ref);\n    return new AngularFirestoreDocument<T>(refInZone, this);\n  }\n\n  /**\n   * Returns a generated Firestore Document Id.\n   */\n  createId() {\n    return this.firestore.collection('_').doc().id;\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { VERSION } from '@angular/fire';\nimport firebase from 'firebase/compat/app';\nimport { AngularFirestore, ENABLE_PERSISTENCE, PERSISTENCE_SETTINGS } from './firestore';\nimport { PersistenceSettings } from './interfaces';\n\n@NgModule({\n  providers: [ AngularFirestore ]\n})\nexport class AngularFirestoreModule {\n  constructor() {\n    firebase.registerVersion('angularfire', VERSION.full, 'fst-compat');\n  }\n  /**\n   * Attempt to enable persistent storage, if possible\n   */\n  static enablePersistence(persistenceSettings?: PersistenceSettings): ModuleWithProviders<AngularFirestoreModule> {\n    return {\n      ngModule: AngularFirestoreModule,\n      providers: [\n        { provide: ENABLE_PERSISTENCE, useValue: true },\n        { provide: PERSISTENCE_SETTINGS, useValue: persistenceSettings },\n      ]\n    };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":["ɵfirebaseAppFactory","ɵauthFactory","ɵcacheInstance","USE_AUTH_EMULATOR","AUTH_SETTINGS"],"mappings":"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"}