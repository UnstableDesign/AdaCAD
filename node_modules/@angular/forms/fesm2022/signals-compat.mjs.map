{"version":3,"file":"signals-compat.mjs","sources":["../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/compat/src/compat_field_node.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/compat/src/compat_node_state.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/compat/src/compat_structure.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/compat/src/api/compat_validation_error.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/compat/src/compat_validation_error.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/compat/src/compat_validation_state.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/compat/src/compat_field_adapter.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/compat/src/api/compat_form.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/compat/src/api/di.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, linkedSignal, runInInjectionContext, Signal, untracked} from '@angular/core';\nimport {toSignal} from '@angular/core/rxjs-interop';\nimport {AbstractControl} from '@angular/forms';\nimport {Observable, ReplaySubject} from 'rxjs';\nimport {map, takeUntil} from 'rxjs/operators';\nimport {FieldNode} from '../../src/field/node';\nimport {getInjectorFromOptions} from '../../src/field/util';\nimport type {CompatFieldNodeOptions} from './compat_structure';\n\n/**\n * Field node with additional  control property.\n *\n * Compat node has no children.\n */\nexport class CompatFieldNode extends FieldNode {\n  readonly control: Signal<AbstractControl>;\n\n  constructor(public readonly options: CompatFieldNodeOptions) {\n    super(options);\n    this.control = this.options.control;\n  }\n}\n\n/**\n * Makes a function which creates a new subject (and unsubscribes/destroys the previous one).\n *\n * This allows us to automatically unsubscribe from status changes of the previous FormControl when we go to subscribe to a new one\n */\nfunction makeCreateDestroySubject() {\n  let destroy$ = new ReplaySubject<void>(1);\n  return () => {\n    if (destroy$) {\n      destroy$.next();\n      destroy$.complete();\n    }\n    return (destroy$ = new ReplaySubject<void>(1));\n  };\n}\n\n/**\n * Helper function taking options, and a callback which takes options, and a function\n * converting reactive control to appropriate property using toSignal from rxjs compat.\n *\n * This helper keeps all complexity in one place by doing the following things:\n * - Running the callback in injection context\n * - Not tracking the callback, as it creates a new signal.\n * - Reacting to control changes, allowing to swap control dynamically.\n *\n * @param options\n * @param makeSignal\n */\nexport function extractControlPropToSignal<T, R = T>(\n  options: CompatFieldNodeOptions,\n  makeSignal: (c: AbstractControl<unknown, T>, destroy$: Observable<void>) => Signal<R>,\n): Signal<R> {\n  const injector = getInjectorFromOptions(options);\n\n  // Creates a subject that could be used in takeUntil.\n  const createDestroySubject = makeCreateDestroySubject();\n\n  const signalOfControlSignal = linkedSignal({\n    source: options.control,\n    computation: (control) => {\n      return untracked(() => {\n        return runInInjectionContext(injector, () => makeSignal(control, createDestroySubject()));\n      });\n    },\n  });\n\n  // We have to have computed, because we need to react to both:\n  // linked signal changes as well as the inner signal changes.\n  return computed(() => signalOfControlSignal()());\n}\n\n/**\n * A helper function, simplifying getting reactive control properties after status changes.\n *\n * Used to extract errors and statuses such as valid, pending.\n *\n * @param options\n * @param getValue\n */\nexport const getControlStatusSignal = <T>(\n  options: CompatFieldNodeOptions,\n  getValue: (c: AbstractControl<unknown>) => T,\n) => {\n  return extractControlPropToSignal<unknown, T>(options, (c, destroy$) =>\n    toSignal(\n      c.statusChanges.pipe(\n        map(() => getValue(c)),\n        takeUntil(destroy$),\n      ),\n      {\n        initialValue: getValue(c),\n      },\n    ),\n  );\n};\n\n/**\n * A helper function, simplifying converting convert events to signals.\n *\n * Used to get dirty and touched signals from control.\n *\n *  @param options\n * @param getValue A function which takes control and returns required value.\n */\nexport const getControlEventsSignal = <T>(\n  options: CompatFieldNodeOptions,\n  getValue: (c: AbstractControl) => T,\n) => {\n  return extractControlPropToSignal<unknown, T>(options, (c, destroy$) =>\n    toSignal(\n      c.events.pipe(\n        map(() => {\n          return getValue(c);\n        }),\n        takeUntil(destroy$),\n      ),\n      {\n        initialValue: getValue(c),\n      },\n    ),\n  );\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal} from '@angular/core';\nimport {AbstractControl} from '@angular/forms';\nimport {FieldNodeState} from '../../src/field/state';\nimport {CompatFieldNode, getControlEventsSignal, getControlStatusSignal} from './compat_field_node';\nimport {CompatFieldNodeOptions} from './compat_structure';\n\n/**\n * A FieldNodeState class wrapping a FormControl and proxying it's state.\n */\nexport class CompatNodeState extends FieldNodeState {\n  override readonly touched: Signal<boolean>;\n  override readonly dirty: Signal<boolean>;\n  override readonly disabled: Signal<boolean>;\n  private readonly control: Signal<AbstractControl>;\n\n  constructor(\n    readonly compatNode: CompatFieldNode,\n    options: CompatFieldNodeOptions,\n  ) {\n    super(compatNode);\n    this.control = options.control;\n    this.touched = getControlEventsSignal(options, (c) => c.touched);\n    this.dirty = getControlEventsSignal(options, (c) => c.dirty);\n    const controlDisabled = getControlStatusSignal(options, (c) => c.disabled);\n\n    this.disabled = computed(() => {\n      return controlDisabled() || this.disabledReasons().length > 0;\n    });\n  }\n\n  override markAsDirty() {\n    this.control().markAsDirty();\n  }\n\n  override markAsTouched() {\n    this.control().markAsTouched();\n  }\n\n  override markAsPristine() {\n    this.control().markAsPristine();\n  }\n\n  override markAsUntouched() {\n    this.control().markAsUntouched();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal, signal, WritableSignal} from '@angular/core';\nimport {FormFieldManager} from '../../src/field/manager';\nimport {FieldNode, ParentFieldNode} from '../../src/field/node';\nimport {\n  ChildFieldNodeOptions,\n  FieldNodeOptions,\n  FieldNodeStructure,\n  RootFieldNodeOptions,\n} from '../../src/field/structure';\n\nimport {toSignal} from '@angular/core/rxjs-interop';\nimport {AbstractControl} from '@angular/forms';\nimport {map, takeUntil} from 'rxjs/operators';\nimport {extractControlPropToSignal} from './compat_field_node';\n\n/**\n * Child Field Node options also exposing control property.\n */\nexport interface CompatChildFieldNodeOptions extends ChildFieldNodeOptions {\n  control: Signal<AbstractControl>;\n}\n\n/**\n * Root Field Node options also exposing control property.\n */\nexport interface CompatRootFieldNodeOptions extends RootFieldNodeOptions {\n  control: Signal<AbstractControl>;\n}\n\n/**\n * Field Node options also exposing control property.\n */\nexport type CompatFieldNodeOptions = CompatRootFieldNodeOptions | CompatChildFieldNodeOptions;\n\n/**\n * A helper function allowing to get parent if it exists.\n */\nfunction getParentFromOptions(options: FieldNodeOptions) {\n  if (options.kind === 'root') {\n    return undefined;\n  }\n\n  return options.parent;\n}\n\n/**\n * A helper function allowing to get fieldManager regardless of the option type.\n */\nfunction getFieldManagerFromOptions(options: FieldNodeOptions) {\n  if (options.kind === 'root') {\n    return options.fieldManager;\n  }\n\n  return options.parent.structure.root.structure.fieldManager;\n}\n\n/**\n * A helper function that takes CompatFieldNodeOptions, and produce a writable signal synced to the\n * value of contained AbstractControl.\n *\n * This uses toSignal, which requires an injector.\n *\n * @param options\n */\nfunction getControlValueSignal<T>(options: CompatFieldNodeOptions) {\n  const value = extractControlPropToSignal<T>(options, (control, destroy$) => {\n    return toSignal(\n      control.valueChanges.pipe(\n        map(() => control.getRawValue()),\n        takeUntil(destroy$),\n      ),\n      {\n        initialValue: control.getRawValue(),\n      },\n    );\n  }) as WritableSignal<T>;\n\n  value.set = (value: T) => {\n    options.control().setValue(value);\n  };\n\n  value.update = (fn: (current: T) => T) => {\n    value.set(fn(value()));\n  };\n\n  return value;\n}\n\n/**\n * Compat version of FieldNodeStructure,\n * - It has no children\n * - It wraps FormControl and proxies its value.\n */\nexport class CompatStructure extends FieldNodeStructure {\n  override value: WritableSignal<unknown>;\n  override keyInParent: Signal<string> = (() => {\n    throw new Error('Compat nodes do not use keyInParent.');\n  }) as unknown as Signal<string>;\n  override root: FieldNode;\n  override pathKeys: Signal<readonly string[]>;\n  override readonly children = signal([]);\n  override readonly childrenMap = signal(undefined);\n  override readonly parent: ParentFieldNode | undefined;\n  override readonly fieldManager: FormFieldManager;\n\n  constructor(node: FieldNode, options: CompatFieldNodeOptions) {\n    super(options.logic);\n    this.value = getControlValueSignal(options);\n    this.parent = getParentFromOptions(options);\n    this.root = this.parent?.structure.root ?? node;\n    this.fieldManager = getFieldManagerFromOptions(options);\n    this.pathKeys = computed(() =>\n      this.parent ? [...this.parent.structure.pathKeys(), this.keyInParent()] : [],\n    );\n  }\n\n  override getChild(): FieldNode | undefined {\n    return undefined;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AbstractControl} from '@angular/forms';\nimport {FieldTree} from '../../../src/api/types';\nimport {ValidationError} from '../../../src/api/validation_errors';\n\n/**\n * An error used for compat errors.\n *\n * @experimental 21.0.0\n * @category interop\n */\nexport class CompatValidationError<T = unknown> implements ValidationError {\n  readonly kind: string = 'compat';\n  readonly control: AbstractControl;\n  readonly field!: FieldTree<unknown>;\n  readonly context: T;\n  readonly message?: string;\n\n  constructor({context, kind, control}: {context: T; kind: string; control: AbstractControl}) {\n    this.context = context;\n    this.kind = kind;\n    this.control = control;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {AbstractControl, FormArray, FormGroup, ValidationErrors} from '@angular/forms';\nimport {CompatValidationError} from './api/compat_validation_error';\n\n/**\n * Converts reactive form validation error to signal forms CompatValidationError.\n * @param errors\n * @param control\n * @return list of errors.\n */\nexport function reactiveErrorsToSignalErrors(\n  errors: ValidationErrors | null,\n  control: AbstractControl,\n): CompatValidationError[] {\n  if (errors === null) {\n    return [];\n  }\n\n  return Object.entries(errors).map(([kind, context]) => {\n    return new CompatValidationError({context, kind, control});\n  });\n}\n\nexport function extractNestedReactiveErrors(control: AbstractControl): CompatValidationError[] {\n  const errors: CompatValidationError[] = [];\n\n  if (control.errors) {\n    errors.push(...reactiveErrorsToSignalErrors(control.errors, control));\n  }\n\n  if (control instanceof FormGroup || control instanceof FormArray) {\n    for (const c of Object.values(control.controls)) {\n      errors.push(...extractNestedReactiveErrors(c));\n    }\n  }\n\n  return errors;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal} from '@angular/core';\nimport {AbstractControl} from '@angular/forms';\nimport {ValidationError} from '../../src/api/validation_errors';\nimport {calculateValidationSelfStatus, ValidationState} from '../../src/field/validation';\nimport type {CompatValidationError} from './api/compat_validation_error';\nimport {getControlStatusSignal} from './compat_field_node';\nimport {CompatFieldNodeOptions} from './compat_structure';\nimport {extractNestedReactiveErrors} from './compat_validation_error';\n\n// Readonly signal containing an empty array, used for optimization.\nconst EMPTY_ARRAY_SIGNAL = computed(() => []);\nconst TRUE_SIGNAL = computed(() => true);\n\n/**\n * Compat version of a validation state that wraps a FormControl, and proxies it's validation state.\n */\nexport class CompatValidationState implements ValidationState {\n  readonly syncValid: Signal<boolean>;\n  /**\n   * All validation errors for this field.\n   */\n  readonly errors: Signal<CompatValidationError[]>;\n  readonly pending: Signal<boolean>;\n  readonly invalid: Signal<boolean>;\n  readonly valid: Signal<boolean>;\n\n  constructor(options: CompatFieldNodeOptions) {\n    this.syncValid = getControlStatusSignal(options, (c: AbstractControl) => c.status === 'VALID');\n    this.errors = getControlStatusSignal(options, extractNestedReactiveErrors);\n    this.pending = getControlStatusSignal(options, (c) => c.pending);\n\n    this.valid = getControlStatusSignal(options, (c) => {\n      return c.valid;\n    });\n\n    this.invalid = getControlStatusSignal(options, (c) => {\n      return c.invalid;\n    });\n  }\n\n  asyncErrors: Signal<(ValidationError.WithField | 'pending')[]> = EMPTY_ARRAY_SIGNAL;\n  errorSummary: Signal<ValidationError.WithField[]> = EMPTY_ARRAY_SIGNAL;\n\n  // Those are irrelevant for compat mode, as it has no children\n  rawSyncTreeErrors = EMPTY_ARRAY_SIGNAL;\n  syncErrors = EMPTY_ARRAY_SIGNAL;\n  rawAsyncErrors = EMPTY_ARRAY_SIGNAL;\n  shouldSkipValidation = TRUE_SIGNAL;\n\n  /**\n   * Computes status based on whether the field is valid/invalid/pending.\n   */\n  readonly status: Signal<'valid' | 'invalid' | 'unknown'> = computed(() => {\n    return calculateValidationSelfStatus(this);\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal, WritableSignal} from '@angular/core';\nimport {AbstractControl} from '@angular/forms';\nimport {BasicFieldAdapter, FieldAdapter} from '../../src/field/field_adapter';\nimport {FormFieldManager} from '../../src/field/manager';\nimport {FieldNode} from '../../src/field/node';\nimport {FieldNodeState} from '../../src/field/state';\nimport {\n  ChildFieldNodeOptions,\n  FieldNodeOptions,\n  FieldNodeStructure,\n} from '../../src/field/structure';\nimport {ValidationState} from '../../src/field/validation';\nimport {FieldPathNode} from '../../src/schema/path_node';\nimport {CompatFieldNode} from './compat_field_node';\nimport {CompatNodeState} from './compat_node_state';\nimport {CompatChildFieldNodeOptions, CompatStructure} from './compat_structure';\nimport {CompatValidationState} from './compat_validation_state';\n\n/**\n * This is a tree-shakable Field adapter that can create a compat node\n * that proxies FormControl state and value to a field.\n */\nexport class CompatFieldAdapter implements FieldAdapter {\n  readonly basicAdapter = new BasicFieldAdapter();\n\n  /**\n   * Creates a regular or compat root node state based on whether the control is present.\n   * @param fieldManager\n   * @param value\n   * @param pathNode\n   * @param adapter\n   */\n  newRoot<TModel>(\n    fieldManager: FormFieldManager,\n    value: WritableSignal<TModel>,\n    pathNode: FieldPathNode,\n    adapter: FieldAdapter,\n  ): FieldNode {\n    if (value() instanceof AbstractControl) {\n      return createCompatNode({\n        kind: 'root',\n        fieldManager,\n        value,\n        pathNode,\n        logic: pathNode.builder.build(),\n        fieldAdapter: adapter,\n      });\n    }\n\n    return this.basicAdapter.newRoot<TModel>(fieldManager, value, pathNode, adapter);\n  }\n\n  /**\n   * Creates a regular or compat node state based on whether the control is present.\n   * @param node\n   * @param options\n   */\n  createNodeState(node: CompatFieldNode, options: CompatChildFieldNodeOptions): FieldNodeState {\n    if (!options.control) {\n      return this.basicAdapter.createNodeState(node);\n    }\n    return new CompatNodeState(node, options);\n  }\n\n  /**\n   * Creates a regular or compat structure based on whether the control is present.\n   * @param node\n   * @param options\n   */\n  createStructure(node: CompatFieldNode, options: CompatChildFieldNodeOptions): FieldNodeStructure {\n    if (!options.control) {\n      return this.basicAdapter.createStructure(node, options);\n    }\n    return new CompatStructure(node, options);\n  }\n\n  /**\n   * Creates a regular or compat validation state based on whether the control is present.\n   * @param node\n   * @param options\n   */\n  createValidationState(\n    node: CompatFieldNode,\n    options: CompatChildFieldNodeOptions,\n  ): ValidationState {\n    if (!options.control) {\n      return this.basicAdapter.createValidationState(node);\n    }\n    return new CompatValidationState(options);\n  }\n\n  /**\n   * Creates a regular or compat node based on whether the control is present.\n   * @param options\n   */\n  newChild(options: ChildFieldNodeOptions): FieldNode {\n    const value = options.parent.value()[options.initialKeyInParent];\n\n    if (value instanceof AbstractControl) {\n      return createCompatNode(options);\n    }\n\n    return new FieldNode(options);\n  }\n}\n\n/**\n * Creates a CompatFieldNode from options.\n * @param options\n */\nexport function createCompatNode(options: FieldNodeOptions) {\n  const control = (\n    options.kind === 'root'\n      ? options.value\n      : computed(() => {\n          return options.parent.value()[options.initialKeyInParent];\n        })\n  ) as Signal<AbstractControl>;\n\n  return new CompatFieldNode({\n    ...options,\n    control,\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {WritableSignal} from '@angular/core';\nimport {form, FormOptions} from '../../../public_api';\nimport {FieldTree, PathKind, SchemaOrSchemaFn} from '../../../src/api/types';\nimport {normalizeFormArgs} from '../../../src/util/normalize_form_args';\nimport {CompatFieldAdapter} from '../compat_field_adapter';\n\n/**\n * Options that may be specified when creating a compat form.\n *\n * @category interop\n * @experimental 21.0.0\n */\nexport type CompatFormOptions = Omit<FormOptions, 'adapter'>;\n\n/**\n * Creates a compatibility form wrapped around the given model data.\n *\n * `compatForm` is a version of the `form` function that is designed for backwards\n * compatibility with Reactive forms by accepting Reactive controls as a part of the data.\n *\n * @example\n * ```\n * const lastName = new FormControl('lastName');\n *\n * const nameModel = signal({\n *    first: '',\n *    last: lastName\n * });\n *\n * const nameForm = compatForm(nameModel, (name) => {\n *   required(name.first);\n * });\n *\n * nameForm.last().value(); // lastName, not FormControl\n *\n * @param model A writable signal that contains the model data for the form. The resulting field\n * structure will match the shape of the model and any changes to the form data will be written to\n * the model.\n\n * @category interop\n * @experimental 21.0.0\n */\nexport function compatForm<TModel>(model: WritableSignal<TModel>): FieldTree<TModel>;\n\n/**\n * Creates a compatibility form wrapped around the given model data.\n *\n * `compatForm` is a version of the `form` function that is designed for backwards\n * compatibility with Reactive forms by accepting Reactive controls as a part of the data.\n *\n * @example\n * ```\n * const lastName = new FormControl('lastName');\n *\n * const nameModel = signal({\n *    first: '',\n *    last: lastName\n * });\n *\n * const nameForm = compatForm(nameModel, (name) => {\n *   required(name.first);\n * });\n *\n * nameForm.last().value(); // lastName, not FormControl\n *\n * @param model A writable signal that contains the model data for the form. The resulting field\n * structure will match the shape of the model and any changes to the form data will be written to\n * the model.\n * @param schemaOrOptions The second argument can be either\n *   1. A schema or a function used to specify logic for the form (e.g. validation, disabled fields, etc.).\n *      When passing a schema, the form options can be passed as a third argument if needed.\n *   2. The form options (excluding adapter, since it's provided).\n *\n * @category interop\n * @experimental 21.0.0\n */\nexport function compatForm<TModel>(\n  model: WritableSignal<TModel>,\n  schemaOrOptions: SchemaOrSchemaFn<TModel> | CompatFormOptions,\n): FieldTree<TModel>;\n\n/**\n * Creates a compatibility form wrapped around the given model data.\n *\n * `compatForm` is a version of the `form` function that is designed for backwards\n * compatibility with Reactive forms by accepting Reactive controls as a part of the data.\n *\n * @example\n * ```\n * const lastName = new FormControl('lastName');\n *\n * const nameModel = signal({\n *    first: '',\n *    last: lastName\n * });\n *\n * const nameForm = compatForm(nameModel, (name) => {\n *   required(name.first);\n * });\n *\n * nameForm.last().value(); // lastName, not FormControl\n *\n * @param model A writable signal that contains the model data for the form. The resulting field\n * structure will match the shape of the model and any changes to the form data will be written to\n * the model.\n * @param schemaOrOptions A schema or a function used to specify logic for the form (e.g. validation, disabled fields, etc.).\n *      When passing a schema, the form options can be passed as a third argument if needed.\n * @param options The form options (excluding adapter, since it's provided).\n *\n * @category interop\n * @experimental 21.0.0\n */\nexport function compatForm<TModel>(\n  model: WritableSignal<TModel>,\n  schema: SchemaOrSchemaFn<TModel>,\n  options: CompatFormOptions,\n): FieldTree<TModel>;\n\nexport function compatForm<TModel>(...args: any[]): FieldTree<TModel> {\n  const [model, maybeSchema, maybeOptions] = normalizeFormArgs<TModel>(args);\n\n  const options = {...maybeOptions, adapter: new CompatFieldAdapter()};\n  const schema = maybeSchema || ((() => {}) as SchemaOrSchemaFn<TModel, PathKind>);\n  return form(model, schema, options) as FieldTree<TModel>;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {SignalFormsConfig} from '../../../src/api/di';\n\n/**\n * A value that can be used for `SignalFormsConfig.classes` to automatically add\n * the `ng-*` status classes from reactive forms.\n *\n * @experimental 21.0.1\n */\nexport const NG_STATUS_CLASSES: SignalFormsConfig['classes'] = {\n  'ng-touched': (state) => state.touched(),\n  'ng-untouched': (state) => !state.touched(),\n  'ng-dirty': (state) => state.dirty(),\n  'ng-pristine': (state) => !state.dirty(),\n  'ng-valid': (state) => state.valid(),\n  'ng-invalid': (state) => state.invalid(),\n  'ng-pending': (state) => state.pending(),\n};\n"],"names":["CompatFieldNode","FieldNode","options","control","constructor","makeCreateDestroySubject","destroy$","ReplaySubject","next","complete","extractControlPropToSignal","makeSignal","injector","getInjectorFromOptions","createDestroySubject","signalOfControlSignal","linkedSignal","ngDevMode","debugName","source","computation","untracked","runInInjectionContext","computed","getControlStatusSignal","getValue","c","toSignal","statusChanges","pipe","map","takeUntil","initialValue","getControlEventsSignal","events","CompatNodeState","FieldNodeState","compatNode","touched","dirty","disabled","controlDisabled","disabledReasons","length","markAsDirty","markAsTouched","markAsPristine","markAsUntouched","getParentFromOptions","kind","undefined","parent","getFieldManagerFromOptions","fieldManager","structure","root","getControlValueSignal","value","valueChanges","getRawValue","set","setValue","update","fn","CompatStructure","FieldNodeStructure","keyInParent","Error","pathKeys","children","signal","childrenMap","node","logic","getChild","CompatValidationError","field","context","message","reactiveErrorsToSignalErrors","errors","Object","entries","extractNestedReactiveErrors","push","FormGroup","FormArray","values","controls","EMPTY_ARRAY_SIGNAL","TRUE_SIGNAL","CompatValidationState","syncValid","pending","invalid","valid","status","asyncErrors","errorSummary","rawSyncTreeErrors","syncErrors","rawAsyncErrors","shouldSkipValidation","calculateValidationSelfStatus","CompatFieldAdapter","basicAdapter","BasicFieldAdapter","newRoot","pathNode","adapter","AbstractControl","createCompatNode","builder","build","fieldAdapter","createNodeState","createStructure","createValidationState","newChild","initialKeyInParent","compatForm","args","model","maybeSchema","maybeOptions","normalizeFormArgs","schema","form","NG_STATUS_CLASSES","state"],"mappings":"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"}