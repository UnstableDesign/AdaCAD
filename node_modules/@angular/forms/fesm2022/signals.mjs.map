{"version":3,"file":"signals.mjs","sources":["../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validation_errors.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/util.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/logic.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/async.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/debounce.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/field/di.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/di.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/controls/interop_ng_control.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/field_directive.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/email.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/max.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/max_length.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/min.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/min_length.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/pattern.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/required.ts","../../../../../darwin_arm64-fastbuild-ST-199a4f3c4e20/bin/packages/forms/signals/src/api/validators/standard_schema.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport type {StandardSchemaV1} from '@standard-schema/spec';\nimport {FieldTree} from './types';\n\n/**\n * Options used to create a `ValidationError`.\n */\ninterface ValidationErrorOptions {\n  /** Human readable error message. */\n  message?: string;\n}\n\n/**\n * A type that requires the given type `T` to have a `field` property.\n * @template T The type to add a `field` to.\n *\n * @experimental 21.0.0\n */\nexport type WithField<T> = T & {field: FieldTree<unknown>};\n\n/**\n * A type that allows the given type `T` to optionally have a `field` property.\n * @template T The type to optionally add a `field` to.\n *\n * @experimental 21.0.0\n */\nexport type WithOptionalField<T> = Omit<T, 'field'> & {field?: FieldTree<unknown>};\n\n/**\n * A type that ensures the given type `T` does not have a `field` property.\n * @template T The type to remove the `field` from.\n *\n * @experimental 21.0.0\n */\nexport type WithoutField<T> = T & {field: never};\n\n/**\n * Create a required error associated with the target field\n * @param options The validation error options\n *\n * @experimental 21.0.0\n */\nexport function requiredError(options: WithField<ValidationErrorOptions>): RequiredValidationError;\n/**\n * Create a required error\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function requiredError(\n  options?: ValidationErrorOptions,\n): WithoutField<RequiredValidationError>;\nexport function requiredError(\n  options?: ValidationErrorOptions,\n): WithOptionalField<RequiredValidationError> {\n  return new RequiredValidationError(options);\n}\n\n/**\n * Create a min value error associated with the target field\n * @param min The min value constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minError(\n  min: number,\n  options: WithField<ValidationErrorOptions>,\n): MinValidationError;\n/**\n * Create a min value error\n * @param min The min value constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minError(\n  min: number,\n  options?: ValidationErrorOptions,\n): WithoutField<MinValidationError>;\nexport function minError(\n  min: number,\n  options?: ValidationErrorOptions,\n): WithOptionalField<MinValidationError> {\n  return new MinValidationError(min, options);\n}\n\n/**\n * Create a max value error associated with the target field\n * @param max The max value constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxError(\n  max: number,\n  options: WithField<ValidationErrorOptions>,\n): MaxValidationError;\n/**\n * Create a max value error\n * @param max The max value constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxError(\n  max: number,\n  options?: ValidationErrorOptions,\n): WithoutField<MaxValidationError>;\nexport function maxError(\n  max: number,\n  options?: ValidationErrorOptions,\n): WithOptionalField<MaxValidationError> {\n  return new MaxValidationError(max, options);\n}\n\n/**\n * Create a minLength error associated with the target field\n * @param minLength The minLength constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minLengthError(\n  minLength: number,\n  options: WithField<ValidationErrorOptions>,\n): MinLengthValidationError;\n/**\n * Create a minLength error\n * @param minLength The minLength constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minLengthError(\n  minLength: number,\n  options?: ValidationErrorOptions,\n): WithoutField<MinLengthValidationError>;\nexport function minLengthError(\n  minLength: number,\n  options?: ValidationErrorOptions,\n): WithOptionalField<MinLengthValidationError> {\n  return new MinLengthValidationError(minLength, options);\n}\n\n/**\n * Create a maxLength error associated with the target field\n * @param maxLength The maxLength constraint\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxLengthError(\n  maxLength: number,\n  options: WithField<ValidationErrorOptions>,\n): MaxLengthValidationError;\n/**\n * Create a maxLength error\n * @param maxLength The maxLength constraint\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxLengthError(\n  maxLength: number,\n  options?: ValidationErrorOptions,\n): WithoutField<MaxLengthValidationError>;\nexport function maxLengthError(\n  maxLength: number,\n  options?: ValidationErrorOptions,\n): WithOptionalField<MaxLengthValidationError> {\n  return new MaxLengthValidationError(maxLength, options);\n}\n\n/**\n * Create a pattern matching error associated with the target field\n * @param pattern The violated pattern\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function patternError(\n  pattern: RegExp,\n  options: WithField<ValidationErrorOptions>,\n): PatternValidationError;\n/**\n * Create a pattern matching error\n * @param pattern The violated pattern\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function patternError(\n  pattern: RegExp,\n  options?: ValidationErrorOptions,\n): WithoutField<PatternValidationError>;\nexport function patternError(\n  pattern: RegExp,\n  options?: ValidationErrorOptions,\n): WithOptionalField<PatternValidationError> {\n  return new PatternValidationError(pattern, options);\n}\n\n/**\n * Create an email format error associated with the target field\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function emailError(options: WithField<ValidationErrorOptions>): EmailValidationError;\n/**\n * Create an email format error\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function emailError(options?: ValidationErrorOptions): WithoutField<EmailValidationError>;\nexport function emailError(\n  options?: ValidationErrorOptions,\n): WithOptionalField<EmailValidationError> {\n  return new EmailValidationError(options);\n}\n\n/**\n * Create a standard schema issue error associated with the target field\n * @param issue The standard schema issue\n * @param options The validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function standardSchemaError(\n  issue: StandardSchemaV1.Issue,\n  options: WithField<ValidationErrorOptions>,\n): StandardSchemaValidationError;\n/**\n * Create a standard schema issue error\n * @param issue The standard schema issue\n * @param options The optional validation error options\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function standardSchemaError(\n  issue: StandardSchemaV1.Issue,\n  options?: ValidationErrorOptions,\n): WithoutField<StandardSchemaValidationError>;\nexport function standardSchemaError(\n  issue: StandardSchemaV1.Issue,\n  options?: ValidationErrorOptions,\n): WithOptionalField<StandardSchemaValidationError> {\n  return new StandardSchemaValidationError(issue, options);\n}\n\n/**\n * Create a custom error associated with the target field\n * @param obj The object to create an error from\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function customError<E extends Partial<ValidationError.WithField>>(\n  obj: WithField<E>,\n): CustomValidationError;\n/**\n * Create a custom error\n * @param obj The object to create an error from\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function customError<E extends Partial<ValidationError.WithField>>(\n  obj?: E,\n): WithoutField<CustomValidationError>;\nexport function customError<E extends Partial<ValidationError.WithField>>(\n  obj?: E,\n): WithOptionalField<CustomValidationError> {\n  return new CustomValidationError(obj);\n}\n\n/**\n * Common interface for all validation errors.\n *\n * This can be returned from validators.\n *\n * It's also used by the creation functions to create an instance\n * (e.g. `requiredError`, `minError`, etc.).\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport interface ValidationError {\n  /** Identifies the kind of error. */\n  readonly kind: string;\n  /** Human readable error message. */\n  readonly message?: string;\n}\n\nexport declare namespace ValidationError {\n  /**\n   * Validation error with a field.\n   *\n   * This is returned from field state, e.g., catField.errors() would be of a list of errors with\n   * `field: catField` bound to state.\n   */\n  export interface WithField extends ValidationError {\n    /** The field associated with this error. */\n    readonly field: FieldTree<unknown>;\n  }\n\n  /**\n   * Validation error with optional field.\n   *\n   * This is generally used in places where the result might have a field.\n   * e.g., as a result of a `validateTree`, or when handling form submission.\n   */\n  export interface WithOptionalField extends ValidationError {\n    /** The field associated with this error. */\n    readonly field?: FieldTree<unknown>;\n  }\n\n  /**\n   * Validation error with no field.\n   *\n   * This is used to strongly enforce that fields are not allowed in validation result.\n   */\n  export interface WithoutField extends ValidationError {\n    /** The field associated with this error. */\n    readonly field?: never;\n  }\n}\n\n/**\n * A custom error that may contain additional properties\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class CustomValidationError implements ValidationError {\n  /** Brand the class to avoid Typescript structural matching */\n  private __brand = undefined;\n\n  /**\n   * Allow the user to attach arbitrary other properties.\n   */\n  [key: PropertyKey]: unknown;\n\n  /** Identifies the kind of error. */\n  readonly kind: string = '';\n\n  /** The field associated with this error. */\n  readonly field!: FieldTree<unknown>;\n\n  /** Human readable error message. */\n  readonly message?: string;\n\n  constructor(options?: ValidationErrorOptions) {\n    if (options) {\n      Object.assign(this, options);\n    }\n  }\n}\n\n/**\n * Internal version of `NgValidationError`, we create this separately so we can change its type on\n * the exported version to a type union of the possible sub-classes.\n *\n * @experimental 21.0.0\n */\nabstract class _NgValidationError implements ValidationError {\n  /** Brand the class to avoid Typescript structural matching */\n  private __brand = undefined;\n\n  /** Identifies the kind of error. */\n  readonly kind: string = '';\n\n  /** The field associated with this error. */\n  readonly field!: FieldTree<unknown>;\n\n  /** Human readable error message. */\n  readonly message?: string;\n\n  constructor(options?: ValidationErrorOptions) {\n    if (options) {\n      Object.assign(this, options);\n    }\n  }\n}\n\n/**\n * An error used to indicate that a required field is empty.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class RequiredValidationError extends _NgValidationError {\n  override readonly kind = 'required';\n}\n\n/**\n * An error used to indicate that a value is lower than the minimum allowed.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MinValidationError extends _NgValidationError {\n  override readonly kind = 'min';\n\n  constructor(\n    readonly min: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is higher than the maximum allowed.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MaxValidationError extends _NgValidationError {\n  override readonly kind = 'max';\n\n  constructor(\n    readonly max: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is shorter than the minimum allowed length.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MinLengthValidationError extends _NgValidationError {\n  override readonly kind = 'minLength';\n\n  constructor(\n    readonly minLength: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is longer than the maximum allowed length.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class MaxLengthValidationError extends _NgValidationError {\n  override readonly kind = 'maxLength';\n\n  constructor(\n    readonly maxLength: number,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value does not match the required pattern.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class PatternValidationError extends _NgValidationError {\n  override readonly kind = 'pattern';\n\n  constructor(\n    readonly pattern: RegExp,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * An error used to indicate that a value is not a valid email.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class EmailValidationError extends _NgValidationError {\n  override readonly kind = 'email';\n}\n\n/**\n * An error used to indicate an issue validating against a standard schema.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport class StandardSchemaValidationError extends _NgValidationError {\n  override readonly kind = 'standardSchema';\n\n  constructor(\n    readonly issue: StandardSchemaV1.Issue,\n    options?: ValidationErrorOptions,\n  ) {\n    super(options);\n  }\n}\n\n/**\n * The base class for all built-in, non-custom errors. This class can be used to check if an error\n * is one of the standard kinds, allowing you to switch on the kind to further narrow the type.\n *\n * @example\n * ```\n * const f = form(...);\n * for (const e of form().errors()) {\n *   if (e instanceof NgValidationError) {\n *     switch(e.kind) {\n *       case 'required':\n *         console.log('This is required!');\n *         break;\n *       case 'min':\n *         console.log(`Must be at least ${e.min}`);\n *         break;\n *       ...\n *     }\n *   }\n * }\n * ```\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport const NgValidationError: abstract new () => NgValidationError = _NgValidationError as any;\nexport type NgValidationError =\n  | RequiredValidationError\n  | MinValidationError\n  | MaxValidationError\n  | MinLengthValidationError\n  | MaxLengthValidationError\n  | PatternValidationError\n  | EmailValidationError\n  | StandardSchemaValidationError;\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {isArray} from '../../util/type_guards';\nimport {LogicFn, OneOrMany, PathKind, ValidationResult, type FieldContext} from '../types';\nimport {customError, ValidationError} from '../validation_errors';\n\n/** Represents a value that has a length or size, such as an array or string, or set. */\nexport type ValueWithLengthOrSize = {length: number} | {size: number};\n\n/** Common options available on the standard validators. */\nexport type BaseValidatorConfig<TValue, TPathKind extends PathKind = PathKind.Root> =\n  | {\n      /** A user-facing error message to include with the error. */\n      message?: string | LogicFn<TValue, string, TPathKind>;\n      error?: never;\n    }\n  | {\n      /**\n       * Custom validation error(s) to report instead of the default,\n       * or a function that receives the `FieldContext` and returns custom validation error(s).\n       */\n      error?: OneOrMany<ValidationError> | LogicFn<TValue, OneOrMany<ValidationError>, TPathKind>;\n      message?: never;\n    };\n\n/** Gets the length or size of the given value. */\nexport function getLengthOrSize(value: ValueWithLengthOrSize) {\n  const v = value as {length: number; size: number};\n  return typeof v.length === 'number' ? v.length : v.size;\n}\n\n/**\n * Gets the value for an option that may be either a static value or a logic function that produces\n * the option value.\n *\n * @param opt The option from BaseValidatorConfig.\n * @param ctx The current FieldContext.\n * @returns The value for the option.\n */\nexport function getOption<TOption, TValue, TPathKind extends PathKind = PathKind.Root>(\n  opt: Exclude<TOption, Function> | LogicFn<TValue, TOption, TPathKind> | undefined,\n  ctx: FieldContext<TValue, TPathKind>,\n): TOption | undefined {\n  return opt instanceof Function ? opt(ctx) : opt;\n}\n\n/**\n * Checks if the given value is considered empty. Empty values are: null, undefined, '', false, NaN.\n */\nexport function isEmpty(value: unknown): boolean {\n  if (typeof value === 'number') {\n    return isNaN(value);\n  }\n  return value === '' || value === false || value == null;\n}\n\n/**\n * Whether the value is a plain object, as opposed to being an instance of Validation error.\n * @param error An error that could be a plain object, or an instance of a class implementing ValidationError.\n */\nfunction isPlainError(error: ValidationError) {\n  return (\n    typeof error === 'object' &&\n    (Object.getPrototypeOf(error) === Object.prototype || Object.getPrototypeOf(error) === null)\n  );\n}\n\n/**\n * If the value provided is a plain object, it wraps it into a custom error.\n * @param error An error that could be a plain object, or an instance of a class implementing ValidationError.\n */\nfunction ensureCustomValidationError(error: ValidationError.WithField): ValidationError.WithField {\n  if (isPlainError(error)) {\n    return customError(error);\n  }\n  return error;\n}\n\n/**\n * Makes sure every provided error is wrapped as a custom error.\n * @param result Validation result with a field.\n */\nexport function ensureCustomValidationResult(\n  result: ValidationResult<ValidationError.WithField>,\n): ValidationResult<ValidationError.WithField> {\n  if (result === null || result === undefined) {\n    return result;\n  }\n\n  if (isArray(result)) {\n    return result.map(ensureCustomValidationError);\n  }\n\n  return ensureCustomValidationError(result);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {addDefaultField} from '../field/validation';\nimport {FieldPathNode} from '../schema/path_node';\nimport {assertPathIsCurrent} from '../schema/schema';\nimport {AggregateMetadataKey, createMetadataKey, MetadataKey} from './metadata';\nimport type {\n  FieldContext,\n  SchemaPath,\n  FieldValidator,\n  LogicFn,\n  PathKind,\n  TreeValidator,\n  SchemaPathRules,\n} from './types';\nimport {ensureCustomValidationResult} from './validators/util';\n\n/**\n * Adds logic to a field to conditionally disable it. A disabled field does not contribute to the\n * validation, touched/dirty, or other state of its parent field.\n *\n * @param path The target path to add the disabled logic to.\n * @param logic A reactive function that returns `true` (or a string reason) when the field is disabled,\n *   and `false` when it is not disabled.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function disabled<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic?: string | NoInfer<LogicFn<TValue, boolean | string, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addDisabledReasonRule((ctx) => {\n    let result: boolean | string = true;\n    if (typeof logic === 'string') {\n      result = logic;\n    } else if (logic) {\n      result = logic(ctx as FieldContext<TValue, TPathKind>);\n    }\n    if (typeof result === 'string') {\n      return {field: ctx.field, message: result};\n    }\n    return result ? {field: ctx.field} : undefined;\n  });\n}\n\n/**\n * Adds logic to a field to conditionally make it readonly. A readonly field does not contribute to\n * the validation, touched/dirty, or other state of its parent field.\n *\n * @param path The target path to make readonly.\n * @param logic A reactive function that returns `true` when the field is readonly.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function readonly<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic: NoInfer<LogicFn<TValue, boolean, TPathKind>> = () => true,\n) {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addReadonlyRule(logic);\n}\n\n/**\n * Adds logic to a field to conditionally hide it. A hidden field does not contribute to the\n * validation, touched/dirty, or other state of its parent field.\n *\n * If a field may be hidden it is recommended to guard it with an `@if` in the template:\n * ```\n * @if (!email().hidden()) {\n *   <label for=\"email\">Email</label>\n *   <input id=\"email\" type=\"email\" [control]=\"email\" />\n * }\n * ```\n *\n * @param path The target path to add the hidden logic to.\n * @param logic A reactive function that returns `true` when the field is hidden.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function hidden<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic: NoInfer<LogicFn<TValue, boolean, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addHiddenRule(logic);\n}\n\n/**\n * Adds logic to a field to determine if the field has validation errors.\n *\n * @param path The target path to add the validation logic to.\n * @param logic A `Validator` that returns the current validation errors.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function validate<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic: NoInfer<FieldValidator<TValue, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addSyncErrorRule((ctx) => {\n    return ensureCustomValidationResult(\n      addDefaultField(logic(ctx as FieldContext<TValue, TPathKind>), ctx.field),\n    );\n  });\n}\n\n/**\n * Adds logic to a field to determine if the field or any of its child fields has validation errors.\n *\n * @param path The target path to add the validation logic to.\n * @param logic A `TreeValidator` that returns the current validation errors.\n *   Errors returned by the validator may specify a target field to indicate an error on a child field.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function validateTree<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  logic: NoInfer<TreeValidator<TValue, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addSyncTreeErrorRule((ctx) =>\n    addDefaultField(logic(ctx as FieldContext<TValue, TPathKind>), ctx.field),\n  );\n}\n\n/**\n * Adds a value to an {@link AggregateMetadataKey} of a field.\n *\n * @param path The target path to set the aggregate metadata on.\n * @param key The aggregate metadata key\n * @param logic A function that receives the `FieldContext` and returns a value to add to the aggregate metadata.\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TMetadataItem The type of value the metadata aggregates over.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function aggregateMetadata<\n  TValue,\n  TMetadataItem,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  key: AggregateMetadataKey<any, TMetadataItem>,\n  logic: NoInfer<LogicFn<TValue, TMetadataItem, TPathKind>>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addAggregateMetadataRule(key, logic);\n}\n\n/**\n * Creates a new {@link MetadataKey} and defines the value of the new metadata key for the given field.\n *\n * @param path The path to define the metadata for.\n * @param factory A factory function that creates the value for the metadata.\n *   This function is **not** reactive. It is run once when the field is created.\n * @returns The newly created metadata key\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  factory: (ctx: FieldContext<TValue, TPathKind>) => TData,\n): MetadataKey<TData>;\n\n/**\n * Defines the value of a {@link MetadataKey} for a given field.\n *\n * @param path The path to define the metadata for.\n * @param key  The metadata key to define.\n * @param factory A factory function that creates the value for the metadata.\n *   This function is **not** reactive. It is run once when the field is created.\n * @returns The given metadata key\n *\n * @category logic\n * @experimental 21.0.0\n */\nexport function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  key: MetadataKey<TData>,\n  factory: (ctx: FieldContext<TValue, TPathKind>) => TData,\n): MetadataKey<TData>;\n\nexport function metadata<TValue, TData, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  ...rest:\n    | [(ctx: FieldContext<TValue, TPathKind>) => TData]\n    | [MetadataKey<TData>, (ctx: FieldContext<TValue, TPathKind>) => TData]\n): MetadataKey<TData> {\n  assertPathIsCurrent(path);\n\n  let key: MetadataKey<TData>;\n  let factory: (ctx: FieldContext<TValue, TPathKind>) => TData;\n  if (rest.length === 2) {\n    [key, factory] = rest;\n  } else {\n    [factory] = rest;\n  }\n  key ??= createMetadataKey();\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addMetadataFactory(key, factory as (ctx: FieldContext<unknown>) => unknown);\n  return key;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {httpResource, HttpResourceOptions, HttpResourceRequest} from '@angular/common/http';\nimport {computed, ResourceRef, Signal} from '@angular/core';\nimport {FieldNode} from '../field/node';\nimport {addDefaultField} from '../field/validation';\nimport {FieldPathNode} from '../schema/path_node';\nimport {assertPathIsCurrent} from '../schema/schema';\nimport {metadata} from './logic';\nimport {FieldContext, SchemaPath, PathKind, TreeValidationResult, SchemaPathRules} from './types';\n\n/**\n * A function that takes the result of an async operation and the current field context, and maps it\n * to a list of validation errors.\n *\n * @param result The result of the async operation.\n * @param ctx The context for the field the validator is attached to.\n * @return A validation error, or list of validation errors to report based on the result of the async operation.\n *   The returned errors can optionally specify a field that the error should be targeted to.\n *   A targeted error will show up as an error on its target field rather than the field being validated.\n *   If a field is not given, the error is assumed to apply to the field being validated.\n * @template TValue The type of value stored in the field being validated.\n * @template TResult The type of result returned by the async operation\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @experimental 21.0.0\n */\nexport type MapToErrorsFn<TValue, TResult, TPathKind extends PathKind = PathKind.Root> = (\n  result: TResult,\n  ctx: FieldContext<TValue, TPathKind>,\n) => TreeValidationResult;\n\n/**\n * Options that indicate how to create a resource for async validation for a field,\n * and map its result to validation errors.\n *\n * @template TValue The type of value stored in the field being validated.\n * @template TParams The type of parameters to the resource.\n * @template TResult The type of result returned by the resource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport interface AsyncValidatorOptions<\n  TValue,\n  TParams,\n  TResult,\n  TPathKind extends PathKind = PathKind.Root,\n> {\n  /**\n   * A function that receives the field context and returns the params for the resource.\n   *\n   * @param ctx The field context for the field being validated.\n   * @returns The params for the resource.\n   */\n  readonly params: (ctx: FieldContext<TValue, TPathKind>) => TParams;\n\n  /**\n   * A function that receives the resource params and returns a resource of the given params.\n   * The given params should be used as is to create the resource.\n   * The forms system will report the params as `undefined` when this validation doesn't need to be run.\n   *\n   * @param params The params to use for constructing the resource\n   * @returns A reference to the constructed resource.\n   */\n  readonly factory: (params: Signal<TParams | undefined>) => ResourceRef<TResult | undefined>;\n  /**\n   * A function to handle errors thrown by httpResource (HTTP errors, network errors, etc.).\n   * Receives the error and the field context, returns a list of validation errors.\n   */\n  readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;\n  /**\n   * A function that takes the resource result, and the current field context and maps it to a list\n   * of validation errors.\n   *\n   * @param result The resource result.\n   * @param ctx The context for the field the validator is attached to.\n   * @return A validation error, or list of validation errors to report based on the resource result.\n   *   The returned errors can optionally specify a field that the error should be targeted to.\n   *   A targeted error will show up as an error on its target field rather than the field being validated.\n   *   If a field is not given, the error is assumed to apply to the field being validated.\n   */\n  readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;\n}\n\n/**\n * Options that indicate how to create an httpResource for async validation for a field,\n * and map its result to validation errors.\n *\n * @template TValue The type of value stored in the field being validated.\n * @template TResult The type of result returned by the httpResource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport interface HttpValidatorOptions<TValue, TResult, TPathKind extends PathKind = PathKind.Root> {\n  /**\n   * A function that receives the field context and returns the url or request for the httpResource.\n   * If given a URL, the underlying httpResource will perform an HTTP GET on it.\n   *\n   * @param ctx The field context for the field being validated.\n   * @returns The URL or request for creating the httpResource.\n   */\n  readonly request:\n    | ((ctx: FieldContext<TValue, TPathKind>) => string | undefined)\n    | ((ctx: FieldContext<TValue, TPathKind>) => HttpResourceRequest | undefined);\n\n  /**\n   * A function that takes the httpResource result, and the current field context and maps it to a\n   * list of validation errors.\n   *\n   * @param result The httpResource result.\n   * @param ctx The context for the field the validator is attached to.\n   * @return A validation error, or list of validation errors to report based on the httpResource result.\n   *   The returned errors can optionally specify a field that the error should be targeted to.\n   *   A targeted error will show up as an error on its target field rather than the field being validated.\n   *   If a field is not given, the error is assumed to apply to the field being validated.\n   */\n  readonly onSuccess: MapToErrorsFn<TValue, TResult, TPathKind>;\n\n  /**\n   * A function to handle errors thrown by httpResource (HTTP errors, network errors, etc.).\n   * Receives the error and the field context, returns a list of validation errors.\n   */\n  readonly onError: (error: unknown, ctx: FieldContext<TValue, TPathKind>) => TreeValidationResult;\n  /**\n   * The options to use when creating the httpResource.\n   */\n  readonly options?: HttpResourceOptions<TResult, unknown>;\n}\n\n/**\n * Adds async validation to the field corresponding to the given path based on a resource.\n * Async validation for a field only runs once all synchronous validation is passing.\n *\n * @param path A path indicating the field to bind the async validation logic to.\n * @param opts The async validation options.\n * @template TValue The type of value stored in the field being validated.\n * @template TParams The type of parameters to the resource.\n * @template TResult The type of result returned by the resource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function validateAsync<TValue, TParams, TResult, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  opts: AsyncValidatorOptions<TValue, TParams, TResult, TPathKind>,\n): void {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n\n  const RESOURCE = metadata(path, (ctx) => {\n    const params = computed(() => {\n      const node = ctx.stateOf(path) as FieldNode;\n      const validationState = node.validationState;\n      if (validationState.shouldSkipValidation() || !validationState.syncValid()) {\n        return undefined;\n      }\n      return opts.params(ctx);\n    });\n    return opts.factory(params);\n  });\n\n  pathNode.builder.addAsyncErrorRule((ctx) => {\n    const res = ctx.state.metadata(RESOURCE)!;\n    let errors;\n    switch (res.status()) {\n      case 'idle':\n        return undefined;\n      case 'loading':\n      case 'reloading':\n        return 'pending';\n      case 'resolved':\n      case 'local':\n        if (!res.hasValue()) {\n          return undefined;\n        }\n        errors = opts.onSuccess(res.value()!, ctx as FieldContext<TValue, TPathKind>);\n        return addDefaultField(errors, ctx.field);\n      case 'error':\n        errors = opts.onError(res.error(), ctx as FieldContext<TValue, TPathKind>);\n        return addDefaultField(errors, ctx.field);\n    }\n  });\n}\n\n/**\n * Adds async validation to the field corresponding to the given path based on an httpResource.\n * Async validation for a field only runs once all synchronous validation is passing.\n *\n * @param path A path indicating the field to bind the async validation logic to.\n * @param opts The http validation options.\n * @template TValue The type of value stored in the field being validated.\n * @template TResult The type of result returned by the httpResource\n * @template TPathKind The kind of path being validated (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function validateHttp<TValue, TResult = unknown, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  opts: HttpValidatorOptions<TValue, TResult, TPathKind>,\n) {\n  validateAsync(path, {\n    params: opts.request,\n    factory: (request: Signal<any>) => httpResource(request, opts.options),\n    onSuccess: opts.onSuccess,\n    onError: opts.onError,\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DEBOUNCER} from '../field/debounce';\nimport {FieldPathNode} from '../schema/path_node';\nimport {assertPathIsCurrent} from '../schema/schema';\nimport type {Debouncer, PathKind, SchemaPath, SchemaPathRules} from './types';\n\n/**\n * Configures the frequency at which a form field is updated by UI events.\n *\n * When this rule is applied, updates from the UI to the form model will be delayed until either\n * the field is touched, or the most recently debounced update resolves.\n *\n * @param path The target path to debounce.\n * @param durationOrDebouncer Either a debounce duration in milliseconds, or a custom\n *     {@link Debouncer} function.\n *\n * @experimental 21.0.0\n */\nexport function debounce<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  durationOrDebouncer: number | Debouncer<TValue, TPathKind>,\n): void {\n  assertPathIsCurrent(path);\n\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  const debouncer =\n    typeof durationOrDebouncer === 'function'\n      ? durationOrDebouncer\n      : durationOrDebouncer > 0\n        ? debounceForDuration(durationOrDebouncer)\n        : immediate;\n  pathNode.builder.addAggregateMetadataRule(DEBOUNCER, () => debouncer);\n}\n\nfunction debounceForDuration(durationInMilliseconds: number): Debouncer<unknown> {\n  return (_context, abortSignal) => {\n    return new Promise((resolve) => {\n      const timeoutId = setTimeout(resolve, durationInMilliseconds);\n      abortSignal.addEventListener('abort', () => clearTimeout(timeoutId));\n    });\n  };\n}\n\nfunction immediate() {}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {InjectionToken} from '@angular/core';\nimport type {SignalFormsConfig} from '../api/di';\n\n/** Injection token for the signal forms configuration. */\nexport const SIGNAL_FORMS_CONFIG = new InjectionToken<SignalFormsConfig>(\n  typeof ngDevMode !== 'undefined' && ngDevMode ? 'SIGNAL_FORMS_CONFIG' : '',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {type Provider} from '@angular/core';\nimport {SIGNAL_FORMS_CONFIG} from '../field/di';\nimport type {FieldState} from './types';\n\n/**\n * Configuration options for signal forms.\n *\n * @experimental 21.0.1\n */\nexport interface SignalFormsConfig {\n  /** A map of CSS class names to predicate functions that determine when to apply them. */\n  classes?: {[className: string]: (state: FieldState<unknown>) => boolean};\n}\n\n/**\n * Provides configuration options for signal forms.\n *\n * @experimental 21.0.1\n */\nexport function provideSignalFormsConfig(config: SignalFormsConfig): Provider[] {\n  return [{provide: SIGNAL_FORMS_CONFIG, useValue: config}];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ControlValueAccessor,\n  Validators,\n  type AbstractControl,\n  type FormControlStatus,\n  type NgControl,\n  type ValidationErrors,\n  type ValidatorFn,\n} from '@angular/forms';\nimport {REQUIRED} from '../api/metadata';\nimport type {FieldState} from '../api/types';\n\n// TODO: Also consider supporting (if possible):\n// - hasError\n// - getError\n// - reset\n// - name\n// - path\n// - markAs[Touched,Dirty,etc.]\n\n/**\n * Properties of both NgControl & AbstractControl that are supported by the InteropNgControl.\n */\nexport type InteropSharedKeys =\n  | 'value'\n  | 'valid'\n  | 'invalid'\n  | 'touched'\n  | 'untouched'\n  | 'disabled'\n  | 'enabled'\n  | 'errors'\n  | 'pristine'\n  | 'dirty'\n  | 'status';\n\n/**\n * A fake version of `NgControl` provided by the `Field` directive. This allows interoperability\n * with a wider range of components designed to work with reactive forms, in particular ones that\n * inject the `NgControl`. The interop control does not implement *all* properties and methods of\n * the real `NgControl`, but does implement some of the most commonly used ones that have a clear\n * equivalent in signal forms.\n */\nexport class InteropNgControl\n  implements\n    Pick<NgControl, InteropSharedKeys | 'control' | 'valueAccessor'>,\n    Pick<AbstractControl<unknown>, InteropSharedKeys | 'hasValidator'>\n{\n  constructor(protected field: () => FieldState<unknown>) {}\n\n  readonly control: AbstractControl<any, any> = this as unknown as AbstractControl<any, any>;\n\n  get value(): any {\n    return this.field().value();\n  }\n\n  get valid(): boolean {\n    return this.field().valid();\n  }\n\n  get invalid(): boolean {\n    return this.field().invalid();\n  }\n\n  get pending(): boolean | null {\n    return this.field().pending();\n  }\n\n  get disabled(): boolean {\n    return this.field().disabled();\n  }\n\n  get enabled(): boolean {\n    return !this.field().disabled();\n  }\n\n  get errors(): ValidationErrors | null {\n    const errors = this.field().errors();\n    if (errors.length === 0) {\n      return null;\n    }\n    const errObj: ValidationErrors = {};\n    for (const error of errors) {\n      errObj[error.kind] = error;\n    }\n    return errObj;\n  }\n\n  get pristine(): boolean {\n    return !this.field().dirty();\n  }\n\n  get dirty(): boolean {\n    return this.field().dirty();\n  }\n\n  get touched(): boolean {\n    return this.field().touched();\n  }\n\n  get untouched(): boolean {\n    return !this.field().touched();\n  }\n\n  get status(): FormControlStatus {\n    if (this.field().disabled()) {\n      return 'DISABLED';\n    }\n    if (this.field().valid()) {\n      return 'VALID';\n    }\n    if (this.field().invalid()) {\n      return 'INVALID';\n    }\n    if (this.field().pending()) {\n      return 'PENDING';\n    }\n    throw Error('AssertionError: unknown form control status');\n  }\n\n  valueAccessor: ControlValueAccessor | null = null;\n\n  hasValidator(validator: ValidatorFn): boolean {\n    // This addresses a common case where users look for the presence of `Validators.required` to\n    // determine whether or not to show a required \"*\" indicator in the UI.\n    if (validator === Validators.required) {\n      return this.field().metadata(REQUIRED)();\n    }\n    return false;\n  }\n\n  updateValueAndValidity() {\n    // No-op since value and validity are always up to date in signal forms.\n    // We offer this method so that reactive forms code attempting to call it doesn't error.\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  computed,\n  Directive,\n  effect,\n  inject,\n  InjectionToken,\n  Injector,\n  input,\n  ɵCONTROL,\n  ɵControl,\n  ɵInteropControl,\n} from '@angular/core';\nimport {NG_VALUE_ACCESSOR, NgControl} from '@angular/forms';\nimport {InteropNgControl} from '../controls/interop_ng_control';\nimport {SIGNAL_FORMS_CONFIG} from '../field/di';\nimport type {FieldNode} from '../field/node';\nimport type {FieldTree} from './types';\n\n/**\n * Lightweight DI token provided by the {@link Field} directive.\n *\n * @category control\n * @experimental 21.0.0\n */\nexport const FIELD = new InjectionToken<Field<unknown>>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'FIELD' : '',\n);\n\n/**\n * Binds a form `FieldTree` to a UI control that edits it. A UI control can be one of several things:\n * 1. A native HTML input or textarea\n * 2. A signal forms custom control that implements `FormValueControl` or `FormCheckboxControl`\n * 3. A component that provides a `ControlValueAccessor`. This should only be used for backwards\n *    compatibility with reactive forms. Prefer options (1) and (2).\n *\n * This directive has several responsibilities:\n * 1. Two-way binds the field's value with the UI control's value\n * 2. Binds additional forms related state on the field to the UI control (disabled, required, etc.)\n * 3. Relays relevant events on the control to the field (e.g. marks field touched on blur)\n * 4. Provides a fake `NgControl` that implements a subset of the features available on the\n *    reactive forms `NgControl`. This is provided to improve interoperability with controls\n *    designed to work with reactive forms. It should not be used by controls written for signal\n *    forms.\n *\n * @category control\n * @experimental 21.0.0\n */\n@Directive({\n  selector: '[field]',\n  providers: [\n    {provide: FIELD, useExisting: Field},\n    {provide: NgControl, useFactory: () => inject(Field).getOrCreateNgControl()},\n  ],\n})\nexport class Field<T> implements ɵControl<T> {\n  private readonly injector = inject(Injector);\n  private config = inject(SIGNAL_FORMS_CONFIG, {optional: true});\n  readonly classes = Object.entries(this.config?.classes ?? {}).map(\n    ([className, computation]) => [className, computed(() => computation(this.state()))] as const,\n  );\n  readonly field = input.required<FieldTree<T>>();\n  readonly state = computed(() => this.field()());\n  readonly [ɵCONTROL] = undefined;\n\n  /** Any `ControlValueAccessor` instances provided on the host element. */\n  private readonly controlValueAccessors = inject(NG_VALUE_ACCESSOR, {optional: true, self: true});\n\n  /** A lazily instantiated fake `NgControl`. */\n  private interopNgControl: InteropNgControl | undefined;\n\n  /** A `ControlValueAccessor`, if configured, for the host component. */\n  get ɵinteropControl(): ɵInteropControl | undefined {\n    return this.controlValueAccessors?.[0] ?? this.interopNgControl?.valueAccessor ?? undefined;\n  }\n\n  /** Lazily instantiates a fake `NgControl` for this field. */\n  protected getOrCreateNgControl(): InteropNgControl {\n    return (this.interopNgControl ??= new InteropNgControl(this.state));\n  }\n\n  // TODO: https://github.com/orgs/angular/projects/60/views/1?pane=issue&itemId=131861631\n  ɵregister() {\n    // Register this control on the field it is currently bound to. We do this at the end of\n    // initialization so that it only runs if we are actually syncing with this control\n    // (as opposed to just passing the field through to its `field` input).\n    effect(\n      (onCleanup) => {\n        const fieldNode = this.state() as unknown as FieldNode;\n        fieldNode.nodeState.fieldBindings.update((controls) => [\n          ...controls,\n          this as Field<unknown>,\n        ]);\n        onCleanup(() => {\n          fieldNode.nodeState.fieldBindings.update((controls) =>\n            controls.filter((c) => c !== this),\n          );\n        });\n      },\n      {injector: this.injector},\n    );\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {validate} from '../logic';\nimport {SchemaPath, SchemaPathRules, PathKind} from '../types';\nimport {emailError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * A regular expression that matches valid e-mail addresses.\n *\n * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:\n * - `local-part` consists of one or more of the allowed characters (alphanumeric and some\n *   punctuation symbols).\n * - `local-part` cannot begin or end with a period (`.`).\n * - `local-part` cannot be longer than 64 characters.\n * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or\n *   `foo.com`.\n * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and\n *   periods (`.`)).\n * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).\n * - A `label` cannot be longer than 63 characters.\n * - The whole address cannot be longer than 254 characters.\n *\n * ## Implementation background\n *\n * This regexp was ported over from AngularJS (see there for git history):\n * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27\n * It is based on the\n * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n * lengths of different parts of the address). The main differences from the WHATWG version are:\n *   - Disallow `local-part` to begin or end with a period (`.`).\n *   - Disallow `local-part` length to exceed 64 characters.\n *   - Disallow total address length to exceed 254 characters.\n *\n * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.\n */\nconst EMAIL_REGEXP =\n  /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n\n/**\n * Binds a validator to the given path that requires the value to match the standard email format.\n * This function can only be called on string paths.\n *\n * @param path Path of the field to validate\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.email()`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function email<TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<string, SchemaPathRules.Supported, TPathKind>,\n  config?: BaseValidatorConfig<string, TPathKind>,\n) {\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    if (!EMAIL_REGEXP.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return emailError({message: getOption(config?.message, ctx)});\n      }\n    }\n\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {MAX} from '../metadata';\nimport {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../types';\nimport {maxError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * Binds a validator to the given path that requires the value to be less than or equal to the\n * given `maxValue`.\n * This function can only be called on number paths.\n * In addition to binding a validator, this function adds `MAX` property to the field.\n *\n * @param path Path of the field to validate\n * @param maxValue The maximum value, or a LogicFn that returns the maximum value.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.max(maxValue)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function max<TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<number | string | null, SchemaPathRules.Supported, TPathKind>,\n  maxValue: number | LogicFn<number | string | null, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<number | string | null, TPathKind>,\n) {\n  const MAX_MEMO = metadata(path, (ctx) =>\n    computed(() => (typeof maxValue === 'number' ? maxValue : maxValue(ctx))),\n  );\n  aggregateMetadata(path, MAX, ({state}) => state.metadata(MAX_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const max = ctx.state.metadata(MAX_MEMO)!();\n    if (max === undefined || Number.isNaN(max)) {\n      return undefined;\n    }\n    const value = ctx.value();\n    const numValue = !value && value !== 0 ? NaN : Number(value); // Treat `''` and `null` as `NaN`\n    if (numValue > max) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxError(max, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {MAX_LENGTH} from '../metadata';\nimport {SchemaPath, SchemaPathRules, LogicFn, PathKind} from '../types';\nimport {maxLengthError} from '../validation_errors';\nimport {\n  BaseValidatorConfig,\n  getLengthOrSize,\n  getOption,\n  isEmpty,\n  ValueWithLengthOrSize,\n} from './util';\n\n/**\n * Binds a validator to the given path that requires the length of the value to be less than or\n * equal to the given `maxLength`.\n * This function can only be called on string or array paths.\n * In addition to binding a validator, this function adds `MAX_LENGTH` property to the field.\n *\n * @param path Path of the field to validate\n * @param maxLength The maximum length, or a LogicFn that returns the maximum length.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.maxLength(maxLength)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function maxLength<\n  TValue extends ValueWithLengthOrSize,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  maxLength: number | LogicFn<TValue, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind>,\n) {\n  const MAX_LENGTH_MEMO = metadata(path, (ctx) =>\n    computed(() => (typeof maxLength === 'number' ? maxLength : maxLength(ctx))),\n  );\n  aggregateMetadata(path, MAX_LENGTH, ({state}) => state.metadata(MAX_LENGTH_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const maxLength = ctx.state.metadata(MAX_LENGTH_MEMO)!();\n    if (maxLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) > maxLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxLengthError(maxLength, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {MIN} from '../metadata';\nimport {LogicFn, PathKind, SchemaPath, SchemaPathRules} from '../types';\nimport {minError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * Binds a validator to the given path that requires the value to be greater than or equal to\n * the given `minValue`.\n * This function can only be called on number paths.\n * In addition to binding a validator, this function adds `MIN` property to the field.\n *\n * @param path Path of the field to validate\n * @param minValue The minimum value, or a LogicFn that returns the minimum value.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.min(minValue)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function min<\n  TValue extends number | string | null,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  minValue: number | LogicFn<TValue, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind>,\n) {\n  const MIN_MEMO = metadata(path, (ctx) =>\n    computed(() => (typeof minValue === 'number' ? minValue : minValue(ctx))),\n  );\n  aggregateMetadata(path, MIN, ({state}) => state.metadata(MIN_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const min = ctx.state.metadata(MIN_MEMO)!();\n    if (min === undefined || Number.isNaN(min)) {\n      return undefined;\n    }\n    const value = ctx.value();\n    const numValue = !value && value !== 0 ? NaN : Number(value); // Treat `''` and `null` as `NaN`\n    if (numValue < min) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minError(min, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {MIN_LENGTH} from '../metadata';\nimport {SchemaPath, LogicFn, PathKind, SchemaPathRules} from '../types';\nimport {minLengthError} from '../validation_errors';\nimport {\n  BaseValidatorConfig,\n  getLengthOrSize,\n  getOption,\n  isEmpty,\n  ValueWithLengthOrSize,\n} from './util';\n\n/**\n * Binds a validator to the given path that requires the length of the value to be greater than or\n * equal to the given `minLength`.\n * This function can only be called on string or array paths.\n * In addition to binding a validator, this function adds `MIN_LENGTH` property to the field.\n *\n * @param path Path of the field to validate\n * @param minLength The minimum length, or a LogicFn that returns the minimum length.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.minLength(minLength)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function minLength<\n  TValue extends ValueWithLengthOrSize,\n  TPathKind extends PathKind = PathKind.Root,\n>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  minLength: number | LogicFn<TValue, number | undefined, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind>,\n) {\n  const MIN_LENGTH_MEMO = metadata(path, (ctx) =>\n    computed(() => (typeof minLength === 'number' ? minLength : minLength(ctx))),\n  );\n  aggregateMetadata(path, MIN_LENGTH, ({state}) => state.metadata(MIN_LENGTH_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const minLength = ctx.state.metadata(MIN_LENGTH_MEMO)!();\n    if (minLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) < minLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minLengthError(minLength, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {PATTERN} from '../metadata';\nimport {SchemaPath, LogicFn, PathKind, SchemaPathRules} from '../types';\nimport {patternError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * Binds a validator to the given path that requires the value to match a specific regex pattern.\n * This function can only be called on string paths.\n * In addition to binding a validator, this function adds `PATTERN` property to the field.\n *\n * @param path Path of the field to validate\n * @param pattern The RegExp pattern to match, or a LogicFn that returns the RegExp pattern.\n * @param config Optional, allows providing any of the following options:\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.pattern(pattern)`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function pattern<TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<string, SchemaPathRules.Supported, TPathKind>,\n  pattern: RegExp | LogicFn<string | undefined, RegExp | undefined, TPathKind>,\n  config?: BaseValidatorConfig<string, TPathKind>,\n) {\n  const PATTERN_MEMO = metadata(path, (ctx) =>\n    computed(() => (pattern instanceof RegExp ? pattern : pattern(ctx))),\n  );\n  aggregateMetadata(path, PATTERN, ({state}) => state.metadata(PATTERN_MEMO)!());\n  validate(path, (ctx) => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const pattern = ctx.state.metadata(PATTERN_MEMO)!();\n    if (pattern === undefined) {\n      return undefined;\n    }\n    if (!pattern.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return patternError(pattern, {message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {aggregateMetadata, metadata, validate} from '../logic';\nimport {REQUIRED} from '../metadata';\nimport {SchemaPath, LogicFn, PathKind, SchemaPathRules} from '../types';\nimport {requiredError} from '../validation_errors';\nimport {BaseValidatorConfig, getOption, isEmpty} from './util';\n\n/**\n * Binds a validator to the given path that requires the value to be non-empty.\n * This function can only be called on any type of path.\n * In addition to binding a validator, this function adds `REQUIRED` property to the field.\n *\n * @param path Path of the field to validate\n * @param config Optional, allows providing any of the following options:\n *  - `message`: A user-facing message for the error.\n *  - `error`: Custom validation error(s) to be used instead of the default `ValidationError.required()`\n *    or a function that receives the `FieldContext` and returns custom validation error(s).\n *  - `when`: A function that receives the `FieldContext` and returns true if the field is required\n * @template TValue The type of value stored in the field the logic is bound to.\n * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function required<TValue, TPathKind extends PathKind = PathKind.Root>(\n  path: SchemaPath<TValue, SchemaPathRules.Supported, TPathKind>,\n  config?: BaseValidatorConfig<TValue, TPathKind> & {\n    when?: NoInfer<LogicFn<TValue, boolean, TPathKind>>;\n  },\n): void {\n  const REQUIRED_MEMO = metadata(path, (ctx) =>\n    computed(() => (config?.when ? config.when(ctx) : true)),\n  );\n  aggregateMetadata(path, REQUIRED, ({state}) => state.metadata(REQUIRED_MEMO)!());\n  validate(path, (ctx) => {\n    if (ctx.state.metadata(REQUIRED_MEMO)!() && isEmpty(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return requiredError({message: getOption(config?.message, ctx)});\n      }\n    }\n    return undefined;\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, resource, ɵisPromise, Signal} from '@angular/core';\nimport type {StandardSchemaV1} from '@standard-schema/spec';\nimport {addDefaultField} from '../../field/validation';\nimport {validateAsync} from '../async';\nimport {metadata, validateTree} from '../logic';\nimport type {SchemaPath, SchemaPathTree, FieldTree} from '../types';\nimport {standardSchemaError, StandardSchemaValidationError} from '../validation_errors';\n\n/**\n * Utility type that removes a string index key when its value is `unknown`,\n * i.e. `{[key: string]: unknown}`. It allows specific string keys to pass through, even if their\n * value is `unknown`, e.g. `{key: unknown}`.\n *\n * @experimental 21.0.0\n */\nexport type RemoveStringIndexUnknownKey<K, V> = string extends K\n  ? unknown extends V\n    ? never\n    : K\n  : K;\n\n/**\n * Utility type that recursively ignores unknown string index properties on the given object.\n * We use this on the `TSchema` type in `validateStandardSchema` in order to accommodate Zod's\n * `looseObject` which includes `{[key: string]: unknown}` as part of the type.\n *\n * @experimental 21.0.0\n */\nexport type IgnoreUnknownProperties<T> =\n  T extends Record<PropertyKey, unknown>\n    ? {\n        [K in keyof T as RemoveStringIndexUnknownKey<K, T[K]>]: IgnoreUnknownProperties<T[K]>;\n      }\n    : T;\n\n/**\n * Validates a field using a `StandardSchemaV1` compatible validator (e.g. a Zod validator).\n *\n * See https://github.com/standard-schema/standard-schema for more about standard schema.\n *\n * @param path The `FieldPath` to the field to validate.\n * @param schema The standard schema compatible validator to use for validation.\n * @template TSchema The type validated by the schema. This may be either the full `TValue` type,\n *   or a partial of it.\n * @template TValue The type of value stored in the field being validated.\n *\n * @category validation\n * @experimental 21.0.0\n */\nexport function validateStandardSchema<TSchema, TModel extends IgnoreUnknownProperties<TSchema>>(\n  path: SchemaPath<TModel> & SchemaPathTree<TModel>,\n  schema: StandardSchemaV1<TSchema>,\n) {\n  // We create both a sync and async validator because the standard schema validator can return\n  // either a sync result or a Promise, and we need to handle both cases. The sync validator\n  // handles the sync result, and the async validator handles the Promise.\n  // We memoize the result of the validation function here, so that it is only run once for both\n  // validators, it can then be passed through both sync & async validation.\n  type Result = StandardSchemaV1.Result<TSchema> | Promise<StandardSchemaV1.Result<TSchema>>;\n  const VALIDATOR_MEMO = metadata<TModel, Signal<Result>>(path, ({value}) => {\n    return computed(() => schema['~standard'].validate(value()));\n  });\n\n  validateTree<TModel>(path, ({state, fieldTreeOf}) => {\n    // Skip sync validation if the result is a Promise.\n    const result = state.metadata(VALIDATOR_MEMO)!();\n    if (ɵisPromise(result)) {\n      return [];\n    }\n    return (\n      result.issues?.map((issue) =>\n        standardIssueToFormTreeError(fieldTreeOf<TModel>(path), issue),\n      ) ?? []\n    );\n  });\n\n  validateAsync<\n    TModel,\n    Promise<StandardSchemaV1.Result<TSchema>> | undefined,\n    readonly StandardSchemaV1.Issue[]\n  >(path, {\n    params: ({state}) => {\n      // Skip async validation if the result is *not* a Promise.\n      const result = state.metadata(VALIDATOR_MEMO)!();\n      return ɵisPromise(result) ? result : undefined;\n    },\n    factory: (params) => {\n      return resource({\n        params,\n        loader: async ({params}) => (await params)?.issues ?? [],\n      });\n    },\n    onSuccess: (issues, {fieldTreeOf}) => {\n      return issues.map((issue) => standardIssueToFormTreeError(fieldTreeOf<TModel>(path), issue));\n    },\n    onError: () => {},\n  });\n}\n\n/**\n * Converts a `StandardSchemaV1.Issue` to a `FormTreeError`.\n *\n * @param field The root field to which the issue's path is relative.\n * @param issue The `StandardSchemaV1.Issue` to convert.\n * @returns A `ValidationError` representing the issue.\n */\nfunction standardIssueToFormTreeError(\n  field: FieldTree<unknown>,\n  issue: StandardSchemaV1.Issue,\n): StandardSchemaValidationError {\n  let target = field as FieldTree<Record<PropertyKey, unknown>>;\n  for (const pathPart of issue.path ?? []) {\n    const pathKey = typeof pathPart === 'object' ? pathPart.key : pathPart;\n    target = target[pathKey] as FieldTree<Record<PropertyKey, unknown>>;\n  }\n  return addDefaultField(standardSchemaError(issue, {message: issue.message}), target);\n}\n"],"names":["requiredError","options","RequiredValidationError","minError","min","MinValidationError","maxError","max","MaxValidationError","minLengthError","minLength","MinLengthValidationError","maxLengthError","maxLength","MaxLengthValidationError","patternError","pattern","PatternValidationError","emailError","EmailValidationError","standardSchemaError","issue","StandardSchemaValidationError","customError","obj","CustomValidationError","__brand","undefined","kind","field","message","constructor","Object","assign","_NgValidationError","NgValidationError","getLengthOrSize","value","v","length","size","getOption","opt","ctx","Function","isEmpty","isNaN","isPlainError","error","getPrototypeOf","prototype","ensureCustomValidationError","ensureCustomValidationResult","result","isArray","map","disabled","path","logic","assertPathIsCurrent","pathNode","FieldPathNode","unwrapFieldPath","builder","addDisabledReasonRule","readonly","addReadonlyRule","hidden","addHiddenRule","validate","addSyncErrorRule","addDefaultField","validateTree","addSyncTreeErrorRule","aggregateMetadata","key","addAggregateMetadataRule","metadata","rest","factory","createMetadataKey","addMetadataFactory","validateAsync","opts","RESOURCE","params","computed","node","stateOf","validationState","shouldSkipValidation","syncValid","addAsyncErrorRule","res","state","errors","status","hasValue","onSuccess","onError","validateHttp","request","httpResource","debounce","durationOrDebouncer","debouncer","debounceForDuration","immediate","DEBOUNCER","durationInMilliseconds","_context","abortSignal","Promise","resolve","timeoutId","setTimeout","addEventListener","clearTimeout","SIGNAL_FORMS_CONFIG","InjectionToken","ngDevMode","provideSignalFormsConfig","config","provide","useValue","InteropNgControl","control","valid","invalid","pending","enabled","errObj","pristine","dirty","touched","untouched","Error","valueAccessor","hasValidator","validator","Validators","required","REQUIRED","updateValueAndValidity","FIELD","Field","injector","inject","Injector","optional","classes","entries","className","computation","input","debugName","ɵCONTROL","controlValueAccessors","NG_VALUE_ACCESSOR","self","interopNgControl","ɵinteropControl","getOrCreateNgControl","ɵregister","effect","onCleanup","fieldNode","nodeState","fieldBindings","update","controls","filter","c","deps","target","i0","ɵɵFactoryTarget","Directive","ɵdir","ɵɵngDeclareDirective","minVersion","version","type","isStandalone","selector","inputs","classPropertyName","publicName","isSignal","isRequired","transformFunction","providers","useExisting","NgControl","useFactory","ngImport","decorators","args","EMAIL_REGEXP","email","test","maxValue","MAX_MEMO","MAX","Number","numValue","NaN","MAX_LENGTH_MEMO","MAX_LENGTH","minValue","MIN_MEMO","MIN","MIN_LENGTH_MEMO","MIN_LENGTH","PATTERN_MEMO","RegExp","PATTERN","REQUIRED_MEMO","when","validateStandardSchema","schema","VALIDATOR_MEMO","fieldTreeOf","ɵisPromise","issues","standardIssueToFormTreeError","resource","loader","pathPart","pathKey"],"mappings":";;;;;;;;;;;;;;AA4DM,SAAUA,aAAaA,CAC3BC,OAAgC,EAAA;AAEhC,EAAA,OAAO,IAAIC,uBAAuB,CAACD,OAAO,CAAC;AAC7C;AA0BgB,SAAAE,QAAQA,CACtBC,GAAW,EACXH,OAAgC,EAAA;AAEhC,EAAA,OAAO,IAAII,kBAAkB,CAACD,GAAG,EAAEH,OAAO,CAAC;AAC7C;AA0BgB,SAAAK,QAAQA,CACtBC,GAAW,EACXN,OAAgC,EAAA;AAEhC,EAAA,OAAO,IAAIO,kBAAkB,CAACD,GAAG,EAAEN,OAAO,CAAC;AAC7C;AA0BgB,SAAAQ,cAAcA,CAC5BC,SAAiB,EACjBT,OAAgC,EAAA;AAEhC,EAAA,OAAO,IAAIU,wBAAwB,CAACD,SAAS,EAAET,OAAO,CAAC;AACzD;AA0BgB,SAAAW,cAAcA,CAC5BC,SAAiB,EACjBZ,OAAgC,EAAA;AAEhC,EAAA,OAAO,IAAIa,wBAAwB,CAACD,SAAS,EAAEZ,OAAO,CAAC;AACzD;AA0BgB,SAAAc,YAAYA,CAC1BC,OAAe,EACff,OAAgC,EAAA;AAEhC,EAAA,OAAO,IAAIgB,sBAAsB,CAACD,OAAO,EAAEf,OAAO,CAAC;AACrD;AAkBM,SAAUiB,UAAUA,CACxBjB,OAAgC,EAAA;AAEhC,EAAA,OAAO,IAAIkB,oBAAoB,CAAClB,OAAO,CAAC;AAC1C;AA0BgB,SAAAmB,mBAAmBA,CACjCC,KAA6B,EAC7BpB,OAAgC,EAAA;AAEhC,EAAA,OAAO,IAAIqB,6BAA6B,CAACD,KAAK,EAAEpB,OAAO,CAAC;AAC1D;AAsBM,SAAUsB,WAAWA,CACzBC,GAAO,EAAA;AAEP,EAAA,OAAO,IAAIC,qBAAqB,CAACD,GAAG,CAAC;AACvC;MA4DaC,qBAAqB,CAAA;AAExBC,EAAAA,OAAO,GAAGC,SAAS;AAQlBC,EAAAA,IAAI,GAAW,EAAE;EAGjBC,KAAK;EAGLC,OAAO;EAEhBC,WAAAA,CAAY9B,OAAgC,EAAA;AAC1C,IAAA,IAAIA,OAAO,EAAE;AACX+B,MAAAA,MAAM,CAACC,MAAM,CAAC,IAAI,EAAEhC,OAAO,CAAC;AAC9B;AACF;AACD;AAQD,MAAeiC,kBAAkB,CAAA;AAEvBR,EAAAA,OAAO,GAAGC,SAAS;AAGlBC,EAAAA,IAAI,GAAW,EAAE;EAGjBC,KAAK;EAGLC,OAAO;EAEhBC,WAAAA,CAAY9B,OAAgC,EAAA;AAC1C,IAAA,IAAIA,OAAO,EAAE;AACX+B,MAAAA,MAAM,CAACC,MAAM,CAAC,IAAI,EAAEhC,OAAO,CAAC;AAC9B;AACF;AACD;AAQK,MAAOC,uBAAwB,SAAQgC,kBAAkB,CAAA;AAC3CN,EAAAA,IAAI,GAAG,UAAU;AACpC;AAQK,MAAOvB,kBAAmB,SAAQ6B,kBAAkB,CAAA;EAI7C9B,GAAA;AAHOwB,EAAAA,IAAI,GAAG,KAAK;AAE9BG,EAAAA,WACWA,CAAA3B,GAAW,EACpBH,OAAgC,EAAA;IAEhC,KAAK,CAACA,OAAO,CAAC;IAHL,IAAG,CAAAG,GAAA,GAAHA,GAAG;AAId;AACD;AAQK,MAAOI,kBAAmB,SAAQ0B,kBAAkB,CAAA;EAI7C3B,GAAA;AAHOqB,EAAAA,IAAI,GAAG,KAAK;AAE9BG,EAAAA,WACWA,CAAAxB,GAAW,EACpBN,OAAgC,EAAA;IAEhC,KAAK,CAACA,OAAO,CAAC;IAHL,IAAG,CAAAM,GAAA,GAAHA,GAAG;AAId;AACD;AAQK,MAAOI,wBAAyB,SAAQuB,kBAAkB,CAAA;EAInDxB,SAAA;AAHOkB,EAAAA,IAAI,GAAG,WAAW;AAEpCG,EAAAA,WACWA,CAAArB,SAAiB,EAC1BT,OAAgC,EAAA;IAEhC,KAAK,CAACA,OAAO,CAAC;IAHL,IAAS,CAAAS,SAAA,GAATA,SAAS;AAIpB;AACD;AAQK,MAAOI,wBAAyB,SAAQoB,kBAAkB,CAAA;EAInDrB,SAAA;AAHOe,EAAAA,IAAI,GAAG,WAAW;AAEpCG,EAAAA,WACWA,CAAAlB,SAAiB,EAC1BZ,OAAgC,EAAA;IAEhC,KAAK,CAACA,OAAO,CAAC;IAHL,IAAS,CAAAY,SAAA,GAATA,SAAS;AAIpB;AACD;AAQK,MAAOI,sBAAuB,SAAQiB,kBAAkB,CAAA;EAIjDlB,OAAA;AAHOY,EAAAA,IAAI,GAAG,SAAS;AAElCG,EAAAA,WACWA,CAAAf,OAAe,EACxBf,OAAgC,EAAA;IAEhC,KAAK,CAACA,OAAO,CAAC;IAHL,IAAO,CAAAe,OAAA,GAAPA,OAAO;AAIlB;AACD;AAQK,MAAOG,oBAAqB,SAAQe,kBAAkB,CAAA;AACxCN,EAAAA,IAAI,GAAG,OAAO;AACjC;AAQK,MAAON,6BAA8B,SAAQY,kBAAkB,CAAA;EAIxDb,KAAA;AAHOO,EAAAA,IAAI,GAAG,gBAAgB;AAEzCG,EAAAA,WACWA,CAAAV,KAA6B,EACtCpB,OAAgC,EAAA;IAEhC,KAAK,CAACA,OAAO,CAAC;IAHL,IAAK,CAAAoB,KAAA,GAALA,KAAK;AAIhB;AACD;AA2BM,MAAMc,iBAAiB,GAAyCD;;AC5gBjE,SAAUE,eAAeA,CAACC,KAA4B,EAAA;EAC1D,MAAMC,CAAC,GAAGD,KAAuC;AACjD,EAAA,OAAO,OAAOC,CAAC,CAACC,MAAM,KAAK,QAAQ,GAAGD,CAAC,CAACC,MAAM,GAAGD,CAAC,CAACE,IAAI;AACzD;AAUgB,SAAAC,SAASA,CACvBC,GAAiF,EACjFC,GAAoC,EAAA;EAEpC,OAAOD,GAAG,YAAYE,QAAQ,GAAGF,GAAG,CAACC,GAAG,CAAC,GAAGD,GAAG;AACjD;AAKM,SAAUG,OAAOA,CAACR,KAAc,EAAA;AACpC,EAAA,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOS,KAAK,CAACT,KAAK,CAAC;AACrB;EACA,OAAOA,KAAK,KAAK,EAAE,IAAIA,KAAK,KAAK,KAAK,IAAIA,KAAK,IAAI,IAAI;AACzD;AAMA,SAASU,YAAYA,CAACC,KAAsB,EAAA;EAC1C,OACE,OAAOA,KAAK,KAAK,QAAQ,KACxBhB,MAAM,CAACiB,cAAc,CAACD,KAAK,CAAC,KAAKhB,MAAM,CAACkB,SAAS,IAAIlB,MAAM,CAACiB,cAAc,CAACD,KAAK,CAAC,KAAK,IAAI,CAAC;AAEhG;AAMA,SAASG,2BAA2BA,CAACH,KAAgC,EAAA;AACnE,EAAA,IAAID,YAAY,CAACC,KAAK,CAAC,EAAE;IACvB,OAAOzB,WAAW,CAACyB,KAAK,CAAC;AAC3B;AACA,EAAA,OAAOA,KAAK;AACd;AAMM,SAAUI,4BAA4BA,CAC1CC,MAAmD,EAAA;AAEnD,EAAA,IAAIA,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK1B,SAAS,EAAE;AAC3C,IAAA,OAAO0B,MAAM;AACf;AAEA,EAAA,IAAIC,OAAO,CAACD,MAAM,CAAC,EAAE;AACnB,IAAA,OAAOA,MAAM,CAACE,GAAG,CAACJ,2BAA2B,CAAC;AAChD;EAEA,OAAOA,2BAA2B,CAACE,MAAM,CAAC;AAC5C;;AChEgB,SAAAG,QAAQA,CACtBC,IAA8D,EAC9DC,KAAsE,EAAA;EAEtEC,mBAAmB,CAACF,IAAI,CAAC;AAEzB,EAAA,MAAMG,QAAQ,GAAGC,aAAa,CAACC,eAAe,CAACL,IAAI,CAAC;AACpDG,EAAAA,QAAQ,CAACG,OAAO,CAACC,qBAAqB,CAAErB,GAAG,IAAI;IAC7C,IAAIU,MAAM,GAAqB,IAAI;AACnC,IAAA,IAAI,OAAOK,KAAK,KAAK,QAAQ,EAAE;AAC7BL,MAAAA,MAAM,GAAGK,KAAK;KAChB,MAAO,IAAIA,KAAK,EAAE;AAChBL,MAAAA,MAAM,GAAGK,KAAK,CAACf,GAAsC,CAAC;AACxD;AACA,IAAA,IAAI,OAAOU,MAAM,KAAK,QAAQ,EAAE;MAC9B,OAAO;QAACxB,KAAK,EAAEc,GAAG,CAACd,KAAK;AAAEC,QAAAA,OAAO,EAAEuB;OAAO;AAC5C;AACA,IAAA,OAAOA,MAAM,GAAG;MAACxB,KAAK,EAAEc,GAAG,CAACd;AAAM,KAAA,GAAGF,SAAS;AAChD,GAAC,CAAC;AACJ;AAcM,SAAUsC,QAAQA,CACtBR,IAA8D,EAC9DC,KAAsD,GAAAA,MAAM,IAAI,EAAA;EAEhEC,mBAAmB,CAACF,IAAI,CAAC;AAEzB,EAAA,MAAMG,QAAQ,GAAGC,aAAa,CAACC,eAAe,CAACL,IAAI,CAAC;AACpDG,EAAAA,QAAQ,CAACG,OAAO,CAACG,eAAe,CAACR,KAAK,CAAC;AACzC;AAsBgB,SAAAS,MAAMA,CACpBV,IAA8D,EAC9DC,KAAmD,EAAA;EAEnDC,mBAAmB,CAACF,IAAI,CAAC;AAEzB,EAAA,MAAMG,QAAQ,GAAGC,aAAa,CAACC,eAAe,CAACL,IAAI,CAAC;AACpDG,EAAAA,QAAQ,CAACG,OAAO,CAACK,aAAa,CAACV,KAAK,CAAC;AACvC;AAagB,SAAAW,QAAQA,CACtBZ,IAA8D,EAC9DC,KAAiD,EAAA;EAEjDC,mBAAmB,CAACF,IAAI,CAAC;AAEzB,EAAA,MAAMG,QAAQ,GAAGC,aAAa,CAACC,eAAe,CAACL,IAAI,CAAC;AACpDG,EAAAA,QAAQ,CAACG,OAAO,CAACO,gBAAgB,CAAE3B,GAAG,IAAI;AACxC,IAAA,OAAOS,4BAA4B,CACjCmB,eAAe,CAACb,KAAK,CAACf,GAAsC,CAAC,EAAEA,GAAG,CAACd,KAAK,CAAC,CAC1E;AACH,GAAC,CAAC;AACJ;AAcgB,SAAA2C,YAAYA,CAC1Bf,IAA8D,EAC9DC,KAAgD,EAAA;EAEhDC,mBAAmB,CAACF,IAAI,CAAC;AAEzB,EAAA,MAAMG,QAAQ,GAAGC,aAAa,CAACC,eAAe,CAACL,IAAI,CAAC;AACpDG,EAAAA,QAAQ,CAACG,OAAO,CAACU,oBAAoB,CAAE9B,GAAG,IACxC4B,eAAe,CAACb,KAAK,CAACf,GAAsC,CAAC,EAAEA,GAAG,CAACd,KAAK,CAAC,CAC1E;AACH;SAegB6C,iBAAiBA,CAK/BjB,IAA8D,EAC9DkB,GAA6C,EAC7CjB,KAAyD,EAAA;EAEzDC,mBAAmB,CAACF,IAAI,CAAC;AAEzB,EAAA,MAAMG,QAAQ,GAAGC,aAAa,CAACC,eAAe,CAACL,IAAI,CAAC;EACpDG,QAAQ,CAACG,OAAO,CAACa,wBAAwB,CAACD,GAAG,EAAEjB,KAAK,CAAC;AACvD;SAoCgBmB,QAAQA,CACtBpB,IAA8D,EAC9D,GAAGqB,IAEsE,EAAA;EAEzEnB,mBAAmB,CAACF,IAAI,CAAC;AAEzB,EAAA,IAAIkB,GAAuB;AAC3B,EAAA,IAAII,OAAwD;AAC5D,EAAA,IAAID,IAAI,CAACvC,MAAM,KAAK,CAAC,EAAE;AACrB,IAAA,CAACoC,GAAG,EAAEI,OAAO,CAAC,GAAGD,IAAI;AACvB,GAAA,MAAO;IACL,CAACC,OAAO,CAAC,GAAGD,IAAI;AAClB;EACAH,GAAG,KAAKK,iBAAiB,EAAE;AAE3B,EAAA,MAAMpB,QAAQ,GAAGC,aAAa,CAACC,eAAe,CAACL,IAAI,CAAC;EACpDG,QAAQ,CAACG,OAAO,CAACkB,kBAAkB,CAACN,GAAG,EAAEI,OAAkD,CAAC;AAC5F,EAAA,OAAOJ,GAAG;AACZ;;ACvFgB,SAAAO,aAAaA,CAC3BzB,IAA8D,EAC9D0B,IAAgE,EAAA;EAEhExB,mBAAmB,CAACF,IAAI,CAAC;AACzB,EAAA,MAAMG,QAAQ,GAAGC,aAAa,CAACC,eAAe,CAACL,IAAI,CAAC;AAEpD,EAAA,MAAM2B,QAAQ,GAAGP,QAAQ,CAACpB,IAAI,EAAGd,GAAG,IAAI;AACtC,IAAA,MAAM0C,MAAM,GAAGC,QAAQ,CAAC,MAAK;AAC3B,MAAA,MAAMC,IAAI,GAAG5C,GAAG,CAAC6C,OAAO,CAAC/B,IAAI,CAAc;AAC3C,MAAA,MAAMgC,eAAe,GAAGF,IAAI,CAACE,eAAe;AAC5C,MAAA,IAAIA,eAAe,CAACC,oBAAoB,EAAE,IAAI,CAACD,eAAe,CAACE,SAAS,EAAE,EAAE;AAC1E,QAAA,OAAOhE,SAAS;AAClB;AACA,MAAA,OAAOwD,IAAI,CAACE,MAAM,CAAC1C,GAAG,CAAC;AACzB,KAAC;;;;MAAC;AACF,IAAA,OAAOwC,IAAI,CAACJ,OAAO,CAACM,MAAM,CAAC;AAC7B,GAAC,CAAC;AAEFzB,EAAAA,QAAQ,CAACG,OAAO,CAAC6B,iBAAiB,CAAEjD,GAAG,IAAI;IACzC,MAAMkD,GAAG,GAAGlD,GAAG,CAACmD,KAAK,CAACjB,QAAQ,CAACO,QAAQ,CAAE;AACzC,IAAA,IAAIW,MAAM;AACV,IAAA,QAAQF,GAAG,CAACG,MAAM,EAAE;AAClB,MAAA,KAAK,MAAM;AACT,QAAA,OAAOrE,SAAS;AAClB,MAAA,KAAK,SAAS;AACd,MAAA,KAAK,WAAW;AACd,QAAA,OAAO,SAAS;AAClB,MAAA,KAAK,UAAU;AACf,MAAA,KAAK,OAAO;AACV,QAAA,IAAI,CAACkE,GAAG,CAACI,QAAQ,EAAE,EAAE;AACnB,UAAA,OAAOtE,SAAS;AAClB;AACAoE,QAAAA,MAAM,GAAGZ,IAAI,CAACe,SAAS,CAACL,GAAG,CAACxD,KAAK,EAAG,EAAEM,GAAsC,CAAC;AAC7E,QAAA,OAAO4B,eAAe,CAACwB,MAAM,EAAEpD,GAAG,CAACd,KAAK,CAAC;AAC3C,MAAA,KAAK,OAAO;AACVkE,QAAAA,MAAM,GAAGZ,IAAI,CAACgB,OAAO,CAACN,GAAG,CAAC7C,KAAK,EAAE,EAAEL,GAAsC,CAAC;AAC1E,QAAA,OAAO4B,eAAe,CAACwB,MAAM,EAAEpD,GAAG,CAACd,KAAK,CAAC;AAC7C;AACF,GAAC,CAAC;AACJ;AAegB,SAAAuE,YAAYA,CAC1B3C,IAA8D,EAC9D0B,IAAsD,EAAA;EAEtDD,aAAa,CAACzB,IAAI,EAAE;IAClB4B,MAAM,EAAEF,IAAI,CAACkB,OAAO;IACpBtB,OAAO,EAAGsB,OAAoB,IAAKC,YAAY,CAACD,OAAO,EAAElB,IAAI,CAAClF,OAAO,CAAC;IACtEiG,SAAS,EAAEf,IAAI,CAACe,SAAS;IACzBC,OAAO,EAAEhB,IAAI,CAACgB;AACf,GAAA,CAAC;AACJ;;ACjMgB,SAAAI,QAAQA,CACtB9C,IAA8D,EAC9D+C,mBAA0D,EAAA;EAE1D7C,mBAAmB,CAACF,IAAI,CAAC;AAEzB,EAAA,MAAMG,QAAQ,GAAGC,aAAa,CAACC,eAAe,CAACL,IAAI,CAAC;AACpD,EAAA,MAAMgD,SAAS,GACb,OAAOD,mBAAmB,KAAK,UAAU,GACrCA,mBAAmB,GACnBA,mBAAmB,GAAG,CAAA,GACpBE,mBAAmB,CAACF,mBAAmB,CAAA,GACvCG,SAAS;EACjB/C,QAAQ,CAACG,OAAO,CAACa,wBAAwB,CAACgC,SAAS,EAAE,MAAMH,SAAS,CAAC;AACvE;AAEA,SAASC,mBAAmBA,CAACG,sBAA8B,EAAA;AACzD,EAAA,OAAO,CAACC,QAAQ,EAAEC,WAAW,KAAI;AAC/B,IAAA,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAI;AAC7B,MAAA,MAAMC,SAAS,GAAGC,UAAU,CAACF,OAAO,EAAEJ,sBAAsB,CAAC;MAC7DE,WAAW,CAACK,gBAAgB,CAAC,OAAO,EAAE,MAAMC,YAAY,CAACH,SAAS,CAAC,CAAC;AACtE,KAAC,CAAC;GACH;AACH;AAEA,SAASP,SAASA;;ACtCX,MAAMW,mBAAmB,GAAG,IAAIC,cAAc,CACnD,OAAOC,SAAS,KAAK,WAAW,IAAIA,SAAS,GAAG,qBAAqB,GAAG,EAAE,CAC3E;;ACaK,SAAUC,wBAAwBA,CAACC,MAAyB,EAAA;AAChE,EAAA,OAAO,CAAC;AAACC,IAAAA,OAAO,EAAEL,mBAAmB;AAAEM,IAAAA,QAAQ,EAAEF;AAAO,GAAA,CAAC;AAC3D;;MCsBaG,gBAAgB,CAAA;EAKLhG,KAAA;EAAtBE,WAAAA,CAAsBF,KAAgC,EAAA;IAAhC,IAAK,CAAAA,KAAA,GAALA,KAAK;AAA8B;AAEhDiG,EAAAA,OAAO,GAA8B,IAA4C;EAE1F,IAAIzF,KAAKA,GAAA;IACP,OAAO,IAAI,CAACR,KAAK,EAAE,CAACQ,KAAK,EAAE;AAC7B;EAEA,IAAI0F,KAAKA,GAAA;IACP,OAAO,IAAI,CAAClG,KAAK,EAAE,CAACkG,KAAK,EAAE;AAC7B;EAEA,IAAIC,OAAOA,GAAA;IACT,OAAO,IAAI,CAACnG,KAAK,EAAE,CAACmG,OAAO,EAAE;AAC/B;EAEA,IAAIC,OAAOA,GAAA;IACT,OAAO,IAAI,CAACpG,KAAK,EAAE,CAACoG,OAAO,EAAE;AAC/B;EAEA,IAAIzE,QAAQA,GAAA;IACV,OAAO,IAAI,CAAC3B,KAAK,EAAE,CAAC2B,QAAQ,EAAE;AAChC;EAEA,IAAI0E,OAAOA,GAAA;IACT,OAAO,CAAC,IAAI,CAACrG,KAAK,EAAE,CAAC2B,QAAQ,EAAE;AACjC;EAEA,IAAIuC,MAAMA,GAAA;IACR,MAAMA,MAAM,GAAG,IAAI,CAAClE,KAAK,EAAE,CAACkE,MAAM,EAAE;AACpC,IAAA,IAAIA,MAAM,CAACxD,MAAM,KAAK,CAAC,EAAE;AACvB,MAAA,OAAO,IAAI;AACb;IACA,MAAM4F,MAAM,GAAqB,EAAE;AACnC,IAAA,KAAK,MAAMnF,KAAK,IAAI+C,MAAM,EAAE;AAC1BoC,MAAAA,MAAM,CAACnF,KAAK,CAACpB,IAAI,CAAC,GAAGoB,KAAK;AAC5B;AACA,IAAA,OAAOmF,MAAM;AACf;EAEA,IAAIC,QAAQA,GAAA;IACV,OAAO,CAAC,IAAI,CAACvG,KAAK,EAAE,CAACwG,KAAK,EAAE;AAC9B;EAEA,IAAIA,KAAKA,GAAA;IACP,OAAO,IAAI,CAACxG,KAAK,EAAE,CAACwG,KAAK,EAAE;AAC7B;EAEA,IAAIC,OAAOA,GAAA;IACT,OAAO,IAAI,CAACzG,KAAK,EAAE,CAACyG,OAAO,EAAE;AAC/B;EAEA,IAAIC,SAASA,GAAA;IACX,OAAO,CAAC,IAAI,CAAC1G,KAAK,EAAE,CAACyG,OAAO,EAAE;AAChC;EAEA,IAAItC,MAAMA,GAAA;IACR,IAAI,IAAI,CAACnE,KAAK,EAAE,CAAC2B,QAAQ,EAAE,EAAE;AAC3B,MAAA,OAAO,UAAU;AACnB;IACA,IAAI,IAAI,CAAC3B,KAAK,EAAE,CAACkG,KAAK,EAAE,EAAE;AACxB,MAAA,OAAO,OAAO;AAChB;IACA,IAAI,IAAI,CAAClG,KAAK,EAAE,CAACmG,OAAO,EAAE,EAAE;AAC1B,MAAA,OAAO,SAAS;AAClB;IACA,IAAI,IAAI,CAACnG,KAAK,EAAE,CAACoG,OAAO,EAAE,EAAE;AAC1B,MAAA,OAAO,SAAS;AAClB;IACA,MAAMO,KAAK,CAAC,6CAA6C,CAAC;AAC5D;AAEAC,EAAAA,aAAa,GAAgC,IAAI;EAEjDC,YAAYA,CAACC,SAAsB,EAAA;AAGjC,IAAA,IAAIA,SAAS,KAAKC,UAAU,CAACC,QAAQ,EAAE;MACrC,OAAO,IAAI,CAAChH,KAAK,EAAE,CAACgD,QAAQ,CAACiE,QAAQ,CAAC,EAAE;AAC1C;AACA,IAAA,OAAO,KAAK;AACd;EAEAC,sBAAsBA,GAAA;AAIvB;;MC/GYC,KAAK,GAAG,IAAIzB,cAAc,CACrC,OAAOC,SAAS,KAAK7F,SAAS,IAAI6F,SAAS,GAAG,OAAO,GAAG,EAAE;MA6B/CyB,KAAK,CAAA;AACCC,EAAAA,QAAQ,GAAGC,MAAM,CAACC,QAAQ,CAAC;AACpC1B,EAAAA,MAAM,GAAGyB,MAAM,CAAC7B,mBAAmB,EAAE;AAAC+B,IAAAA,QAAQ,EAAE;AAAK,GAAA,CAAC;AACrDC,EAAAA,OAAO,GAAGtH,MAAM,CAACuH,OAAO,CAAC,IAAI,CAAC7B,MAAM,EAAE4B,OAAO,IAAI,EAAE,CAAC,CAAC/F,GAAG,CAC/D,CAAC,CAACiG,SAAS,EAAEC,WAAW,CAAC,KAAK,CAACD,SAAS,EAAElE,QAAQ,CAAC,MAAMmE,WAAW,CAAC,IAAI,CAAC3D,KAAK,EAAE,CAAC,CAAC,CAAU,CAC9F;AACQjE,EAAAA,KAAK,GAAG6H,KAAK,CAACb,QAAQ;;;;IAAgB;EACtC/C,KAAK,GAAGR,QAAQ,CAAC,MAAM,IAAI,CAACzD,KAAK,EAAE,EAAE,EAAA;AAAA,IAAA,IAAA2F,SAAA,GAAA;AAAAmC,MAAAA,SAAA,EAAA;KAAA,GAAA,EAAA;AAAA,GAAA,CAAC;EACtC,CAACC,QAAQ,IAAIjI,SAAS;AAGdkI,EAAAA,qBAAqB,GAAGV,MAAM,CAACW,iBAAiB,EAAE;AAACT,IAAAA,QAAQ,EAAE,IAAI;AAAEU,IAAAA,IAAI,EAAE;AAAI,GAAC,CAAC;EAGxFC,gBAAgB;EAGxB,IAAIC,eAAeA,GAAA;AACjB,IAAA,OAAO,IAAI,CAACJ,qBAAqB,GAAG,CAAC,CAAC,IAAI,IAAI,CAACG,gBAAgB,EAAEvB,aAAa,IAAI9G,SAAS;AAC7F;AAGUuI,EAAAA,oBAAoBA,GAAA;IAC5B,OAAQ,IAAI,CAACF,gBAAgB,KAAK,IAAInC,gBAAgB,CAAC,IAAI,CAAC/B,KAAK,CAAC;AACpE;AAGAqE,EAAAA,SAASA,GAAA;IAIPC,MAAM,CACHC,SAAS,IAAI;AACZ,MAAA,MAAMC,SAAS,GAAG,IAAI,CAACxE,KAAK,EAA0B;AACtDwE,MAAAA,SAAS,CAACC,SAAS,CAACC,aAAa,CAACC,MAAM,CAAEC,QAAQ,IAAK,CACrD,GAAGA,QAAQ,EACX,IAAsB,CACvB,CAAC;AACFL,MAAAA,SAAS,CAAC,MAAK;AACbC,QAAAA,SAAS,CAACC,SAAS,CAACC,aAAa,CAACC,MAAM,CAAEC,QAAQ,IAChDA,QAAQ,CAACC,MAAM,CAAEC,CAAC,IAAKA,CAAC,KAAK,IAAI,CAAC,CACnC;AACH,OAAC,CAAC;AACJ,KAAC,EACD;MAAC1B,QAAQ,EAAE,IAAI,CAACA;AAAS,KAAA,CAC1B;AACH;;;;;UA9CWD,KAAK;AAAA4B,IAAAA,IAAA,EAAA,EAAA;AAAAC,IAAAA,MAAA,EAAAC,EAAA,CAAAC,eAAA,CAAAC;AAAA,GAAA,CAAA;AAAL,EAAA,OAAAC,IAAA,GAAAH,EAAA,CAAAI,oBAAA,CAAA;AAAAC,IAAAA,UAAA,EAAA,QAAA;AAAAC,IAAAA,OAAA,EAAA,mBAAA;AAAAC,IAAAA,IAAA,EAAArC,KAAK;AALLsC,IAAAA,YAAA,EAAA,IAAA;AAAAC,IAAAA,QAAA,EAAA,SAAA;AAAAC,IAAAA,MAAA,EAAA;AAAA5J,MAAAA,KAAA,EAAA;AAAA6J,QAAAA,iBAAA,EAAA,OAAA;AAAAC,QAAAA,UAAA,EAAA,OAAA;AAAAC,QAAAA,QAAA,EAAA,IAAA;AAAAC,QAAAA,UAAA,EAAA,IAAA;AAAAC,QAAAA,iBAAA,EAAA;AAAA;KAAA;AAAAC,IAAAA,SAAA,EAAA,CACT;AAACpE,MAAAA,OAAO,EAAEqB,KAAK;AAAEgD,MAAAA,WAAW,EAAE/C;AAAM,KAAA,EACpC;AAACtB,MAAAA,OAAO,EAAEsE,SAAS;MAAEC,UAAU,EAAEA,MAAM/C,MAAM,CAACF,KAAK,CAAC,CAACiB,oBAAoB;AAAG,KAAA,CAC7E;AAAAiC,IAAAA,QAAA,EAAApB;AAAA,GAAA,CAAA;;;;;;QAEU9B,KAAK;AAAAmD,EAAAA,UAAA,EAAA,CAAA;UAPjBnB,SAAS;AAACoB,IAAAA,IAAA,EAAA,CAAA;AACTb,MAAAA,QAAQ,EAAE,SAAS;AACnBO,MAAAA,SAAS,EAAE,CACT;AAACpE,QAAAA,OAAO,EAAEqB,KAAK;AAAEgD,QAAAA,WAAW;AAAQ,OAAA,EACpC;AAACrE,QAAAA,OAAO,EAAEsE,SAAS;QAAEC,UAAU,EAAEA,MAAM/C,MAAM,CAAAF,KAAA,CAAO,CAACiB,oBAAoB;OAAG;KAE/E;;;;;;;;;;;;;;AClBD,MAAMoC,YAAY,GAChB,oMAAoM;AAetL,SAAAC,KAAKA,CACnB9I,IAA8D,EAC9DiE,MAA+C,EAAA;AAE/CrD,EAAAA,QAAQ,CAACZ,IAAI,EAAGd,GAAG,IAAI;IACrB,IAAIE,OAAO,CAACF,GAAG,CAACN,KAAK,EAAE,CAAC,EAAE;AACxB,MAAA,OAAOV,SAAS;AAClB;IACA,IAAI,CAAC2K,YAAY,CAACE,IAAI,CAAC7J,GAAG,CAACN,KAAK,EAAE,CAAC,EAAE;MACnC,IAAIqF,MAAM,EAAE1E,KAAK,EAAE;AACjB,QAAA,OAAOP,SAAS,CAACiF,MAAM,CAAC1E,KAAK,EAAEL,GAAG,CAAC;AACrC,OAAA,MAAO;AACL,QAAA,OAAOzB,UAAU,CAAC;AAACY,UAAAA,OAAO,EAAEW,SAAS,CAACiF,MAAM,EAAE5F,OAAO,EAAEa,GAAG;AAAC,SAAC,CAAC;AAC/D;AACF;AAEA,IAAA,OAAOhB,SAAS;AAClB,GAAC,CAAC;AACJ;;SC9CgBpB,GAAGA,CACjBkD,IAA8E,EAC9EgJ,QAAiF,EACjF/E,MAA+D,EAAA;EAE/D,MAAMgF,QAAQ,GAAG7H,QAAQ,CAACpB,IAAI,EAAGd,GAAG,IAClC2C,QAAQ,CAAC,MAAO,OAAOmH,QAAQ,KAAK,QAAQ,GAAGA,QAAQ,GAAGA,QAAQ,CAAC9J,GAAG,CAAE,CAAC,CAC1E;AACD+B,EAAAA,iBAAiB,CAACjB,IAAI,EAAEkJ,GAAG,EAAE,CAAC;AAAC7G,IAAAA;GAAM,KAAKA,KAAK,CAACjB,QAAQ,CAAC6H,QAAQ,CAAE,EAAE,CAAC;AACtErI,EAAAA,QAAQ,CAACZ,IAAI,EAAGd,GAAG,IAAI;IACrB,IAAIE,OAAO,CAACF,GAAG,CAACN,KAAK,EAAE,CAAC,EAAE;AACxB,MAAA,OAAOV,SAAS;AAClB;IACA,MAAMpB,GAAG,GAAGoC,GAAG,CAACmD,KAAK,CAACjB,QAAQ,CAAC6H,QAAQ,CAAE,EAAE;IAC3C,IAAInM,GAAG,KAAKoB,SAAS,IAAIiL,MAAM,CAAC9J,KAAK,CAACvC,GAAG,CAAC,EAAE;AAC1C,MAAA,OAAOoB,SAAS;AAClB;AACA,IAAA,MAAMU,KAAK,GAAGM,GAAG,CAACN,KAAK,EAAE;AACzB,IAAA,MAAMwK,QAAQ,GAAG,CAACxK,KAAK,IAAIA,KAAK,KAAK,CAAC,GAAGyK,GAAG,GAAGF,MAAM,CAACvK,KAAK,CAAC;IAC5D,IAAIwK,QAAQ,GAAGtM,GAAG,EAAE;MAClB,IAAImH,MAAM,EAAE1E,KAAK,EAAE;AACjB,QAAA,OAAOP,SAAS,CAACiF,MAAM,CAAC1E,KAAK,EAAEL,GAAG,CAAC;AACrC,OAAA,MAAO;QACL,OAAOrC,QAAQ,CAACC,GAAG,EAAE;AAACuB,UAAAA,OAAO,EAAEW,SAAS,CAACiF,MAAM,EAAE5F,OAAO,EAAEa,GAAG;AAAC,SAAC,CAAC;AAClE;AACF;AACA,IAAA,OAAOhB,SAAS;AAClB,GAAC,CAAC;AACJ;;SCrBgBd,SAASA,CAIvB4C,IAA8D,EAC9D5C,SAAkE,EAClE6G,MAA+C,EAAA;EAE/C,MAAMqF,eAAe,GAAGlI,QAAQ,CAACpB,IAAI,EAAGd,GAAG,IACzC2C,QAAQ,CAAC,MAAO,OAAOzE,SAAS,KAAK,QAAQ,GAAGA,SAAS,GAAGA,SAAS,CAAC8B,GAAG,CAAE,CAAC,CAC7E;AACD+B,EAAAA,iBAAiB,CAACjB,IAAI,EAAEuJ,UAAU,EAAE,CAAC;AAAClH,IAAAA;GAAM,KAAKA,KAAK,CAACjB,QAAQ,CAACkI,eAAe,CAAE,EAAE,CAAC;AACpF1I,EAAAA,QAAQ,CAACZ,IAAI,EAAGd,GAAG,IAAI;IACrB,IAAIE,OAAO,CAACF,GAAG,CAACN,KAAK,EAAE,CAAC,EAAE;AACxB,MAAA,OAAOV,SAAS;AAClB;IACA,MAAMd,SAAS,GAAG8B,GAAG,CAACmD,KAAK,CAACjB,QAAQ,CAACkI,eAAe,CAAE,EAAE;IACxD,IAAIlM,SAAS,KAAKc,SAAS,EAAE;AAC3B,MAAA,OAAOA,SAAS;AAClB;IACA,IAAIS,eAAe,CAACO,GAAG,CAACN,KAAK,EAAE,CAAC,GAAGxB,SAAS,EAAE;MAC5C,IAAI6G,MAAM,EAAE1E,KAAK,EAAE;AACjB,QAAA,OAAOP,SAAS,CAACiF,MAAM,CAAC1E,KAAK,EAAEL,GAAG,CAAC;AACrC,OAAA,MAAO;QACL,OAAO/B,cAAc,CAACC,SAAS,EAAE;AAACiB,UAAAA,OAAO,EAAEW,SAAS,CAACiF,MAAM,EAAE5F,OAAO,EAAEa,GAAG;AAAC,SAAC,CAAC;AAC9E;AACF;AACA,IAAA,OAAOhB,SAAS;AAClB,GAAC,CAAC;AACJ;;SCpCgBvB,GAAGA,CAIjBqD,IAA8D,EAC9DwJ,QAAiE,EACjEvF,MAA+C,EAAA;EAE/C,MAAMwF,QAAQ,GAAGrI,QAAQ,CAACpB,IAAI,EAAGd,GAAG,IAClC2C,QAAQ,CAAC,MAAO,OAAO2H,QAAQ,KAAK,QAAQ,GAAGA,QAAQ,GAAGA,QAAQ,CAACtK,GAAG,CAAE,CAAC,CAC1E;AACD+B,EAAAA,iBAAiB,CAACjB,IAAI,EAAE0J,GAAG,EAAE,CAAC;AAACrH,IAAAA;GAAM,KAAKA,KAAK,CAACjB,QAAQ,CAACqI,QAAQ,CAAE,EAAE,CAAC;AACtE7I,EAAAA,QAAQ,CAACZ,IAAI,EAAGd,GAAG,IAAI;IACrB,IAAIE,OAAO,CAACF,GAAG,CAACN,KAAK,EAAE,CAAC,EAAE;AACxB,MAAA,OAAOV,SAAS;AAClB;IACA,MAAMvB,GAAG,GAAGuC,GAAG,CAACmD,KAAK,CAACjB,QAAQ,CAACqI,QAAQ,CAAE,EAAE;IAC3C,IAAI9M,GAAG,KAAKuB,SAAS,IAAIiL,MAAM,CAAC9J,KAAK,CAAC1C,GAAG,CAAC,EAAE;AAC1C,MAAA,OAAOuB,SAAS;AAClB;AACA,IAAA,MAAMU,KAAK,GAAGM,GAAG,CAACN,KAAK,EAAE;AACzB,IAAA,MAAMwK,QAAQ,GAAG,CAACxK,KAAK,IAAIA,KAAK,KAAK,CAAC,GAAGyK,GAAG,GAAGF,MAAM,CAACvK,KAAK,CAAC;IAC5D,IAAIwK,QAAQ,GAAGzM,GAAG,EAAE;MAClB,IAAIsH,MAAM,EAAE1E,KAAK,EAAE;AACjB,QAAA,OAAOP,SAAS,CAACiF,MAAM,CAAC1E,KAAK,EAAEL,GAAG,CAAC;AACrC,OAAA,MAAO;QACL,OAAOxC,QAAQ,CAACC,GAAG,EAAE;AAAC0B,UAAAA,OAAO,EAAEW,SAAS,CAACiF,MAAM,EAAE5F,OAAO,EAAEa,GAAG;AAAC,SAAC,CAAC;AAClE;AACF;AACA,IAAA,OAAOhB,SAAS;AAClB,GAAC,CAAC;AACJ;;SCxBgBjB,SAASA,CAIvB+C,IAA8D,EAC9D/C,SAAkE,EAClEgH,MAA+C,EAAA;EAE/C,MAAM0F,eAAe,GAAGvI,QAAQ,CAACpB,IAAI,EAAGd,GAAG,IACzC2C,QAAQ,CAAC,MAAO,OAAO5E,SAAS,KAAK,QAAQ,GAAGA,SAAS,GAAGA,SAAS,CAACiC,GAAG,CAAE,CAAC,CAC7E;AACD+B,EAAAA,iBAAiB,CAACjB,IAAI,EAAE4J,UAAU,EAAE,CAAC;AAACvH,IAAAA;GAAM,KAAKA,KAAK,CAACjB,QAAQ,CAACuI,eAAe,CAAE,EAAE,CAAC;AACpF/I,EAAAA,QAAQ,CAACZ,IAAI,EAAGd,GAAG,IAAI;IACrB,IAAIE,OAAO,CAACF,GAAG,CAACN,KAAK,EAAE,CAAC,EAAE;AACxB,MAAA,OAAOV,SAAS;AAClB;IACA,MAAMjB,SAAS,GAAGiC,GAAG,CAACmD,KAAK,CAACjB,QAAQ,CAACuI,eAAe,CAAE,EAAE;IACxD,IAAI1M,SAAS,KAAKiB,SAAS,EAAE;AAC3B,MAAA,OAAOA,SAAS;AAClB;IACA,IAAIS,eAAe,CAACO,GAAG,CAACN,KAAK,EAAE,CAAC,GAAG3B,SAAS,EAAE;MAC5C,IAAIgH,MAAM,EAAE1E,KAAK,EAAE;AACjB,QAAA,OAAOP,SAAS,CAACiF,MAAM,CAAC1E,KAAK,EAAEL,GAAG,CAAC;AACrC,OAAA,MAAO;QACL,OAAOlC,cAAc,CAACC,SAAS,EAAE;AAACoB,UAAAA,OAAO,EAAEW,SAAS,CAACiF,MAAM,EAAE5F,OAAO,EAAEa,GAAG;AAAC,SAAC,CAAC;AAC9E;AACF;AACA,IAAA,OAAOhB,SAAS;AAClB,GAAC,CAAC;AACJ;;SCrCgBX,OAAOA,CACrByC,IAA8D,EAC9DzC,OAA4E,EAC5E0G,MAA+C,EAAA;EAE/C,MAAM4F,YAAY,GAAGzI,QAAQ,CAACpB,IAAI,EAAGd,GAAG,IACtC2C,QAAQ,CAAC,MAAOtE,OAAO,YAAYuM,MAAM,GAAGvM,OAAO,GAAGA,OAAO,CAAC2B,GAAG,CAAE,CAAC,CACrE;AACD+B,EAAAA,iBAAiB,CAACjB,IAAI,EAAE+J,OAAO,EAAE,CAAC;AAAC1H,IAAAA;GAAM,KAAKA,KAAK,CAACjB,QAAQ,CAACyI,YAAY,CAAE,EAAE,CAAC;AAC9EjJ,EAAAA,QAAQ,CAACZ,IAAI,EAAGd,GAAG,IAAI;IACrB,IAAIE,OAAO,CAACF,GAAG,CAACN,KAAK,EAAE,CAAC,EAAE;AACxB,MAAA,OAAOV,SAAS;AAClB;IACA,MAAMX,OAAO,GAAG2B,GAAG,CAACmD,KAAK,CAACjB,QAAQ,CAACyI,YAAY,CAAE,EAAE;IACnD,IAAItM,OAAO,KAAKW,SAAS,EAAE;AACzB,MAAA,OAAOA,SAAS;AAClB;IACA,IAAI,CAACX,OAAO,CAACwL,IAAI,CAAC7J,GAAG,CAACN,KAAK,EAAE,CAAC,EAAE;MAC9B,IAAIqF,MAAM,EAAE1E,KAAK,EAAE;AACjB,QAAA,OAAOP,SAAS,CAACiF,MAAM,CAAC1E,KAAK,EAAEL,GAAG,CAAC;AACrC,OAAA,MAAO;QACL,OAAO5B,YAAY,CAACC,OAAO,EAAE;AAACc,UAAAA,OAAO,EAAEW,SAAS,CAACiF,MAAM,EAAE5F,OAAO,EAAEa,GAAG;AAAC,SAAC,CAAC;AAC1E;AACF;AACA,IAAA,OAAOhB,SAAS;AAClB,GAAC,CAAC;AACJ;;ACxBgB,SAAAkH,QAAQA,CACtBpF,IAA8D,EAC9DiE,MAEC,EAAA;EAED,MAAM+F,aAAa,GAAG5I,QAAQ,CAACpB,IAAI,EAAGd,GAAG,IACvC2C,QAAQ,CAAC,MAAOoC,MAAM,EAAEgG,IAAI,GAAGhG,MAAM,CAACgG,IAAI,CAAC/K,GAAG,CAAC,GAAG,IAAK,CAAC,CACzD;AACD+B,EAAAA,iBAAiB,CAACjB,IAAI,EAAEqF,QAAQ,EAAE,CAAC;AAAChD,IAAAA;GAAM,KAAKA,KAAK,CAACjB,QAAQ,CAAC4I,aAAa,CAAE,EAAE,CAAC;AAChFpJ,EAAAA,QAAQ,CAACZ,IAAI,EAAGd,GAAG,IAAI;AACrB,IAAA,IAAIA,GAAG,CAACmD,KAAK,CAACjB,QAAQ,CAAC4I,aAAa,CAAE,EAAE,IAAI5K,OAAO,CAACF,GAAG,CAACN,KAAK,EAAE,CAAC,EAAE;MAChE,IAAIqF,MAAM,EAAE1E,KAAK,EAAE;AACjB,QAAA,OAAOP,SAAS,CAACiF,MAAM,CAAC1E,KAAK,EAAEL,GAAG,CAAC;AACrC,OAAA,MAAO;AACL,QAAA,OAAO3C,aAAa,CAAC;AAAC8B,UAAAA,OAAO,EAAEW,SAAS,CAACiF,MAAM,EAAE5F,OAAO,EAAEa,GAAG;AAAC,SAAC,CAAC;AAClE;AACF;AACA,IAAA,OAAOhB,SAAS;AAClB,GAAC,CAAC;AACJ;;ACKgB,SAAAgM,sBAAsBA,CACpClK,IAAiD,EACjDmK,MAAiC,EAAA;AAQjC,EAAA,MAAMC,cAAc,GAAGhJ,QAAQ,CAAyBpB,IAAI,EAAE,CAAC;AAACpB,IAAAA;AAAM,GAAA,KAAI;AACxE,IAAA,OAAOiD,QAAQ,CAAC,MAAMsI,MAAM,CAAC,WAAW,CAAC,CAACvJ,QAAQ,CAAChC,KAAK,EAAE,CAAC,CAAC;AAC9D,GAAC,CAAC;EAEFmC,YAAY,CAASf,IAAI,EAAE,CAAC;IAACqC,KAAK;AAAEgI,IAAAA;AAAY,GAAA,KAAI;IAElD,MAAMzK,MAAM,GAAGyC,KAAK,CAACjB,QAAQ,CAACgJ,cAAc,CAAE,EAAE;AAChD,IAAA,IAAIE,UAAU,CAAC1K,MAAM,CAAC,EAAE;AACtB,MAAA,OAAO,EAAE;AACX;AACA,IAAA,OACEA,MAAM,CAAC2K,MAAM,EAAEzK,GAAG,CAAElC,KAAK,IACvB4M,4BAA4B,CAACH,WAAW,CAASrK,IAAI,CAAC,EAAEpC,KAAK,CAAC,CAC/D,IAAI,EAAE;AAEX,GAAC,CAAC;EAEF6D,aAAa,CAIXzB,IAAI,EAAE;AACN4B,IAAAA,MAAM,EAAEA,CAAC;AAACS,MAAAA;AAAK,KAAC,KAAI;MAElB,MAAMzC,MAAM,GAAGyC,KAAK,CAACjB,QAAQ,CAACgJ,cAAc,CAAE,EAAE;AAChD,MAAA,OAAOE,UAAU,CAAC1K,MAAM,CAAC,GAAGA,MAAM,GAAG1B,SAAS;KAC/C;IACDoD,OAAO,EAAGM,MAAM,IAAI;AAClB,MAAA,OAAO6I,QAAQ,CAAC;QACd7I,MAAM;QACN8I,MAAM,EAAE,OAAO;AAAC9I,UAAAA;SAAO,KAAK,CAAC,MAAMA,MAAM,GAAG2I,MAAM,IAAI;AACvD,OAAA,CAAC;KACH;IACD9H,SAAS,EAAEA,CAAC8H,MAAM,EAAE;AAACF,MAAAA;AAAW,KAAC,KAAI;AACnC,MAAA,OAAOE,MAAM,CAACzK,GAAG,CAAElC,KAAK,IAAK4M,4BAA4B,CAACH,WAAW,CAASrK,IAAI,CAAC,EAAEpC,KAAK,CAAC,CAAC;KAC7F;IACD8E,OAAO,EAAEA,MAAK;AACf,GAAA,CAAC;AACJ;AASA,SAAS8H,4BAA4BA,CACnCpM,KAAyB,EACzBR,KAA6B,EAAA;EAE7B,IAAIyJ,MAAM,GAAGjJ,KAAgD;EAC7D,KAAK,MAAMuM,QAAQ,IAAI/M,KAAK,CAACoC,IAAI,IAAI,EAAE,EAAE;IACvC,MAAM4K,OAAO,GAAG,OAAOD,QAAQ,KAAK,QAAQ,GAAGA,QAAQ,CAACzJ,GAAG,GAAGyJ,QAAQ;AACtEtD,IAAAA,MAAM,GAAGA,MAAM,CAACuD,OAAO,CAA4C;AACrE;AACA,EAAA,OAAO9J,eAAe,CAACnD,mBAAmB,CAACC,KAAK,EAAE;IAACS,OAAO,EAAET,KAAK,CAACS;GAAQ,CAAC,EAAEgJ,MAAM,CAAC;AACtF;;;;"}