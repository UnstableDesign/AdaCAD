"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateRulesTool = void 0;
const zod_1 = require("zod");
const tool_1 = require("../../tool");
const util_1 = require("../../util");
const rules_1 = require("../../../gcp/rules");
const path_1 = require("path");
function formatRulesetIssues(issues, rulesSource) {
    const sourceLines = rulesSource.split("\n");
    const formattedOutput = [];
    for (const issue of issues) {
        const { sourcePosition, description, severity } = issue;
        let issueString = `${severity}: ${description} [Ln ${sourcePosition.line}, Col ${sourcePosition.column}]`;
        if (sourcePosition.line) {
            const lineIndex = sourcePosition.line - 1;
            if (lineIndex >= 0 && lineIndex < sourceLines.length) {
                const errorLine = sourceLines[lineIndex];
                issueString += `\n\`\`\`\n${errorLine}`;
                if (sourcePosition.column &&
                    sourcePosition.currentOffset &&
                    sourcePosition.endOffset &&
                    sourcePosition.column > 0 &&
                    sourcePosition.endOffset > sourcePosition.currentOffset) {
                    const startColumnOnLine = sourcePosition.column - 1;
                    const errorTokenLength = sourcePosition.endOffset - sourcePosition.currentOffset;
                    if (startColumnOnLine >= 0 &&
                        errorTokenLength > 0 &&
                        startColumnOnLine <= errorLine.length) {
                        const padding = " ".repeat(startColumnOnLine);
                        const carets = "^".repeat(errorTokenLength);
                        issueString += `\n${padding}${carets}\n\`\`\``;
                    }
                }
            }
        }
        formattedOutput.push(issueString);
    }
    return formattedOutput.join("\n\n");
}
function validateRulesTool(productName) {
    return (0, tool_1.tool)({
        name: "validate_rules",
        description: `Checks the provided ${productName} Rules source for syntax and validation errors. Provide EITHER the source code to validate OR a path to a source file.`,
        inputSchema: zod_1.z.object({
            source: zod_1.z
                .string()
                .optional()
                .describe("the rules source code to check. provide either this OR a path"),
            source_file: zod_1.z
                .string()
                .optional()
                .describe("a file path, relative to the project root, to a file containing the rules source you want to validate. provide this OR source, not both"),
        }),
        annotations: {
            title: `Validate ${productName} Rules`,
            readOnlyHint: true,
        },
        _meta: {
            requiresProject: true,
            requiresAuth: true,
        },
    }, async ({ source, source_file }, { projectId, config, host }) => {
        var _a, _b;
        if (source && source_file) {
            return (0, util_1.mcpError)("Must supply `source` or `source_file`, not both.");
        }
        let rulesSourceContent;
        if (source_file) {
            try {
                const filePath = (0, path_1.resolve)(source_file, host.cachedProjectRoot);
                if (filePath.includes("../"))
                    return (0, util_1.mcpError)("Cannot read files outside of the project directory.");
                rulesSourceContent = config.readProjectFile(source_file);
            }
            catch (e) {
                return (0, util_1.mcpError)(`Failed to read source_file '${source_file}': ${e.message}`);
            }
        }
        else if (source) {
            rulesSourceContent = source;
        }
        else {
            rulesSourceContent = "";
        }
        const result = await (0, rules_1.testRuleset)(projectId, [
            { name: "test.rules", content: rulesSourceContent },
        ]);
        if ((_b = (_a = result.body) === null || _a === void 0 ? void 0 : _a.issues) === null || _b === void 0 ? void 0 : _b.length) {
            const issues = result.body.issues;
            let out = `Found ${issues.length} issues in rules source:\n\n`;
            out += formatRulesetIssues(issues, rulesSourceContent);
            return (0, util_1.toContent)(out);
        }
        return (0, util_1.toContent)("OK: No errors detected.");
    });
}
exports.validateRulesTool = validateRulesTool;
