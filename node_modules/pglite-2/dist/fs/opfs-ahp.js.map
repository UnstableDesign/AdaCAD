{"version":3,"sources":["../../src/fs/opfs-ahp.ts"],"sourcesContent":["import { BaseFilesystem, ERRNO_CODES, type FsStats } from './base.js'\nimport type { PostgresMod } from '../postgresMod.js'\nimport { PGlite } from '../pglite.js'\n\nexport interface OpfsAhpOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n  debug?: boolean\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: ArrayBuffer, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: ArrayBuffer, options: { at: number }): number\n}\n\n// State\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends BaseFilesystem {\n  declare readonly dataDir: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  checkpointInterval = 1000 * 60 // 1 minute\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor(\n    dataDir: string,\n    {\n      initialPoolSize = 1000,\n      maintainedPoolSize = 100,\n      debug = false,\n    }: OpfsAhpOptions = {},\n  ) {\n    super(dataDir, { debug })\n    this.initialPoolSize = initialPoolSize\n    this.maintainedPoolSize = maintainedPoolSize\n  }\n\n  async init(pg: PGlite, opts: Partial<PostgresMod>) {\n    await this.#init()\n    return super.init(pg, opts)\n  }\n\n  async syncToFs(relaxedDurability = false) {\n    await this.maybeCheckpointState()\n    await this.maintainPool()\n    if (!relaxedDurability) {\n      this.flush()\n    }\n  }\n\n  async closeFs(): Promise<void> {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n    this.pg!.Module.FS.quit()\n  }\n\n  async #init() {\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    this.#rootAh = await this.#resolveOpfsDirectory(this.dataDir!, {\n      create: true,\n    })\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          await this.#dataDirAh.removeEntry(fh.name)\n          this.#fh.delete(filename)\n          this.#sh.delete(filename)\n          resolve()\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Uint8Array(buffer.buffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Uint8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    const ret = sh.write(new Uint8Array(buffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n\nclass FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n"],"mappings":"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","names":["init_esm_shims","STATE_FILE","DATA_DIR","INITIAL_MODE","_opfsRootAh","_rootAh","_dataDirAh","_stateFH","_stateSH","_fh","_sh","_handleIdCounter","_openHandlePaths","_openHandleIds","_unsyncedSH","_OpfsAhpFS_instances","init_fn","tryWithWAL_fn","logWAL_fn","pathParts_fn","resolvePath_fn","getPathFromFd_fn","nextHandleId_fn","resolveOpfsDirectory_fn","OpfsAhpFS","BaseFilesystem","dataDir","initialPoolSize","maintainedPoolSize","debug","__privateAdd","pg","opts","__privateMethod","relaxedDurability","sh","__privateGet","size","change","promises","resolve","filename","fh","index","stateAB","path","mode","node","fd","blksize","options","parts","newDirName","currentPath","part","FsError","newDir","_flags","_mode","handleId","buffer","offset","length","position","oldPath","newPath","doFileOps","oldPathParts","oldFilename","oldParent","newPathParts","newFilename","newParent","pathParts","dirName","parent","len","dir","atime","mtime","_atime","data","lastModified","ret","__privateSet","state","stateLines","isNewState","wal","line","entry","methodName","e","walkPromises","walk","child","poolPromises","fn","entryJSON","from","id","__privateWrapper","ah","code","message","ERRNO_CODES"]}