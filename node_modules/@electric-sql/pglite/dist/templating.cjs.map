{"version":3,"sources":["../src/templating.ts"],"sourcesContent":["const TemplateType = {\n  part: 'part',\n  container: 'container',\n} as const\n\ninterface TemplatePart {\n  _templateType: typeof TemplateType.part\n  str: string\n}\n\ninterface TemplateContainer {\n  _templateType: typeof TemplateType.container\n  strings: TemplateStringsArray\n  values: any[]\n}\n\ninterface TemplatedQuery {\n  query: string\n  params: any[]\n}\n\nfunction addToLastAndPushWithSuffix(\n  arr: string[],\n  suffix: string,\n  ...values: string[]\n) {\n  const lastArrIdx = arr.length - 1\n  const lastValIdx = values.length - 1\n\n  // no-op\n  if (lastValIdx === -1) return\n\n  // overwrite last element\n  if (lastValIdx === 0) {\n    arr[lastArrIdx] = arr[lastArrIdx] + values[0] + suffix\n    return\n  }\n\n  // sandwich values between array and suffix\n  arr[lastArrIdx] = arr[lastArrIdx] + values[0]\n  arr.push(...values.slice(1, lastValIdx))\n  arr.push(values[lastValIdx] + suffix)\n}\n\n/**\n * Templating utility that allows nesting multiple SQL strings without\n * losing the automatic parametrization capabilities of {@link query}.\n *\n * @example\n * ```ts\n * query`SELECT * FROM tale ${withFilter ? sql`WHERE foo = ${fooVar}` : sql``}`\n * // > { query: 'SELECT * FROM tale WHERE foo = $1', params: [fooVar] }\n * // or\n * // > { query: 'SELECT * FROM tale', params: [] }\n * ```\n */\nexport function sql(\n  strings: TemplateStringsArray,\n  ...values: any[]\n): TemplateContainer {\n  const parsedStrings = [strings[0]] as string[] & {\n    raw: string[]\n  }\n  parsedStrings.raw = [strings.raw[0]]\n\n  const parsedValues: any[] = []\n  for (let i = 0; i < values.length; i++) {\n    const value = values[i]\n    const nextStringIdx = i + 1\n\n    // if value is a template tag, collapse into last string\n    if (value?._templateType === TemplateType.part) {\n      addToLastAndPushWithSuffix(\n        parsedStrings,\n        strings[nextStringIdx],\n        value.str,\n      )\n      addToLastAndPushWithSuffix(\n        parsedStrings.raw,\n        strings.raw[nextStringIdx],\n        value.str,\n      )\n      continue\n    }\n\n    // if value is an output of this method, append in place\n    if (value?._templateType === TemplateType.container) {\n      addToLastAndPushWithSuffix(\n        parsedStrings,\n        strings[nextStringIdx],\n        ...value.strings,\n      )\n      addToLastAndPushWithSuffix(\n        parsedStrings.raw,\n        strings.raw[nextStringIdx],\n        ...value.strings.raw,\n      )\n      parsedValues.push(...value.values)\n      continue\n    }\n\n    // otherwise keep reconstructing\n    parsedStrings.push(strings[nextStringIdx])\n    parsedStrings.raw.push(strings.raw[nextStringIdx])\n    parsedValues.push(value)\n  }\n\n  return {\n    _templateType: 'container',\n    strings: parsedStrings,\n    values: parsedValues,\n  }\n}\n\n/**\n * Allows adding identifiers into a query template string without\n * parametrizing them. This method will automatically escape identifiers.\n *\n * @example\n * ```ts\n * query`SELECT * FROM ${identifier`foo`} WHERE ${identifier`id`} = ${id}`\n * // > { query: 'SELECT * FROM \"foo\" WHERE \"id\" = $1', params: [id] }\n * ```\n */\nexport function identifier(\n  strings: TemplateStringsArray,\n  ...values: any[]\n): TemplatePart {\n  return {\n    _templateType: 'part',\n    str: `\"${String.raw(strings, ...values)}\"`,\n  }\n}\n\n/**\n * Allows adding raw strings into a query template string without\n * parametrizing or modifying them in any way.\n *\n * @example\n * ```ts\n * query`SELECT * FROM foo ${raw`WHERE id = ${2+3}`}`\n * // > { query: 'SELECT * FROM foo WHERE id = 5', params: [] }\n * ```\n */\n\nexport function raw(\n  strings: TemplateStringsArray,\n  ...values: any[]\n): TemplatePart {\n  return {\n    _templateType: 'part',\n    str: String.raw(strings, ...values),\n  }\n}\n\n/**\n * Generates a parametrized query from a templated query string, assigning\n * the provided values to the appropriate named parameters.\n *\n * You can use templating helpers like {@link identifier} and {@link raw} to\n * add identifiers and raw strings to the query without making them parameters,\n * and you can use {@link sql} to nest multiple queries and create utilities.\n *\n * @example\n * ```ts\n * query`SELECT * FROM ${identifier`foo`} WHERE id = ${id} and name = ${name}`\n * // > { query: 'SELECT * FROM \"foo\" WHERE id = $1 and name = $2', params: [id, name] }\n * ```\n */\nexport function query(\n  strings: TemplateStringsArray,\n  ...values: any[]\n): TemplatedQuery {\n  const { strings: queryStringParts, values: params } = sql(strings, ...values)\n  return {\n    query: [\n      queryStringParts[0],\n      ...params.flatMap((_, idx) => [`$${idx + 1}`, queryStringParts[idx + 1]]),\n    ].join(''),\n    params: params,\n  }\n}\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,gBAAAE,EAAA,UAAAC,EAAA,QAAAC,EAAA,QAAAC,IAAA,eAAAC,EAAAN,GAAA,IAAMO,EAAe,CACnB,KAAM,OACN,UAAW,WACb,EAkBA,SAASC,EACPC,EACAC,KACGC,EACH,CACA,IAAMC,EAAaH,EAAI,OAAS,EAC1BI,EAAaF,EAAO,OAAS,EAGnC,GAAIE,IAAe,GAGnB,IAAIA,IAAe,EAAG,CACpBJ,EAAIG,CAAU,EAAIH,EAAIG,CAAU,EAAID,EAAO,CAAC,EAAID,EAChD,MACF,CAGAD,EAAIG,CAAU,EAAIH,EAAIG,CAAU,EAAID,EAAO,CAAC,EAC5CF,EAAI,KAAK,GAAGE,EAAO,MAAM,EAAGE,CAAU,CAAC,EACvCJ,EAAI,KAAKE,EAAOE,CAAU,EAAIH,CAAM,EACtC,CAcO,SAASI,EACdC,KACGJ,EACgB,CACnB,IAAMK,EAAgB,CAACD,EAAQ,CAAC,CAAC,EAGjCC,EAAc,IAAM,CAACD,EAAQ,IAAI,CAAC,CAAC,EAEnC,IAAME,EAAsB,CAAC,EAC7B,QAASC,EAAI,EAAGA,EAAIP,EAAO,OAAQO,IAAK,CACtC,IAAMC,EAAQR,EAAOO,CAAC,EAChBE,EAAgBF,EAAI,EAG1B,GAAIC,GAAO,gBAAkBZ,EAAa,KAAM,CAC9CC,EACEQ,EACAD,EAAQK,CAAa,EACrBD,EAAM,GACR,EACAX,EACEQ,EAAc,IACdD,EAAQ,IAAIK,CAAa,EACzBD,EAAM,GACR,EACA,QACF,CAGA,GAAIA,GAAO,gBAAkBZ,EAAa,UAAW,CACnDC,EACEQ,EACAD,EAAQK,CAAa,EACrB,GAAGD,EAAM,OACX,EACAX,EACEQ,EAAc,IACdD,EAAQ,IAAIK,CAAa,EACzB,GAAGD,EAAM,QAAQ,GACnB,EACAF,EAAa,KAAK,GAAGE,EAAM,MAAM,EACjC,QACF,CAGAH,EAAc,KAAKD,EAAQK,CAAa,CAAC,EACzCJ,EAAc,IAAI,KAAKD,EAAQ,IAAIK,CAAa,CAAC,EACjDH,EAAa,KAAKE,CAAK,CACzB,CAEA,MAAO,CACL,cAAe,YACf,QAASH,EACT,OAAQC,CACV,CACF,CAYO,SAASI,EACdN,KACGJ,EACW,CACd,MAAO,CACL,cAAe,OACf,IAAK,IAAI,OAAO,IAAII,EAAS,GAAGJ,CAAM,CAAC,GACzC,CACF,CAaO,SAASW,EACdP,KACGJ,EACW,CACd,MAAO,CACL,cAAe,OACf,IAAK,OAAO,IAAII,EAAS,GAAGJ,CAAM,CACpC,CACF,CAgBO,SAASY,EACdR,KACGJ,EACa,CAChB,GAAM,CAAE,QAASa,EAAkB,OAAQC,CAAO,EAAIX,EAAIC,EAAS,GAAGJ,CAAM,EAC5E,MAAO,CACL,MAAO,CACLa,EAAiB,CAAC,EAClB,GAAGC,EAAO,QAAQ,CAACC,EAAGC,IAAQ,CAAC,IAAIA,EAAM,CAAC,GAAIH,EAAiBG,EAAM,CAAC,CAAC,CAAC,CAC1E,EAAE,KAAK,EAAE,EACT,OAAQF,CACV,CACF","names":["templating_exports","__export","identifier","query","raw","sql","__toCommonJS","TemplateType","addToLastAndPushWithSuffix","arr","suffix","values","lastArrIdx","lastValIdx","sql","strings","parsedStrings","parsedValues","i","value","nextStringIdx","identifier","raw","query","queryStringParts","params","_","idx"]}