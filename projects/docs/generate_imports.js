// generate_statements.js

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { getAllOps } from 'adacad-drafting-lib';

// In ES Modules, __dirname is not available.
// This is the standard way to replicate it.
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const outputFilePath = path.join(__dirname, 'src/components/import_helper.js');
const oplist = getAllOps();

const IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.gif', '.webp'];

/**
 * Clears all previously generated assets:
 * - Deletes import_helper.js
 * - Deletes all generated operation documentation pages (preserves index.md)
 */
// async function clearGeneratedAssets() {
//     try {
//         // Clear import_helper.js
//         try {
//             await fs.unlink(outputFilePath);
//             console.log(`Deleted ${outputFilePath}`);
//         } catch (err) {
//             if (err.code !== 'ENOENT') {
//                 // File doesn't exist is okay, but other errors should be reported
//                 console.warn(`Could not delete ${outputFilePath}:`, err.message);
//             }
//         }

//         // Clear generated operation documentation pages
//         const operationsDocsPath = path.join(__dirname, 'docs/reference/operations');

//         try {
//             // Read all category directories
//             const categoryDirs = await fs.readdir(operationsDocsPath, { withFileTypes: true });

//             for (const dirent of categoryDirs) {
//                 if (dirent.isDirectory()) {
//                     const categoryPath = path.join(operationsDocsPath, dirent.name);
//                     const files = await fs.readdir(categoryPath);

//                     // Delete all .md files except index.md
//                     for (const file of files) {
//                         if (file.endsWith('.md') && file !== 'index.md') {
//                             const filePath = path.join(categoryPath, file);
//                             await fs.unlink(filePath);
//                             console.log(`Deleted ${filePath}`);
//                         }
//                     }
//                 }
//             }

//             console.log('Successfully cleared all generated assets');
//         } catch (err) {
//             if (err.code === 'ENOENT') {
//                 console.log('Operations docs directory does not exist yet');
//             } else {
//                 throw err;
//             }
//         }
//     } catch (err) {
//         console.error('An error occurred while clearing generated assets:', err);
//         throw err;
//     }
// }

/**
 * Copies any image files from the operation's directory in adacad-drafting-lib
 * into the corresponding docs reference/operations category directory.
 */
// async function copyOperationImages(op, docsCategoryOpDir) {
//     const libOpDir = path.join(__dirname, '..', '..', 'packages', 'adacad-drafting-lib', 'src', 'operations', op.name);
//     try {
//         const entries = await fs.readdir(libOpDir, { withFileTypes: true });
//         for (const ent of entries) {
//             if (!ent.isFile()) continue;
//             const ext = path.extname(ent.name).toLowerCase();
//             if (!IMAGE_EXTENSIONS.includes(ext)) continue;
//             const src = path.join(libOpDir, ent.name);
//             const dest = path.join(docsCategoryOpDir, ent.name);
//             await fs.copyFile(src, dest);
//             console.log(`Copied ${ent.name} to ${docsCategoryOpDir}`);
//         }
//     } catch (e) {
//         if (e.code === 'ENOENT') {
//             // Operation directory or docs dir doesn't exist; skip
//             return;
//         }
//         throw e;
//     }
// }

/**
 * pupulates src/components/import_helper.js with the imports for the operations
 * that are not draft operations
 * node generate_imports.js
 */
// async function generateModuleStatements() {
//     try {


//         // Read the filenames from the source directory
//         // const files = await fs.readdir(directoryPath);
//         //runs via 
//         let generatedCode = '// This file is auto-generated by the generate_imports script\n\n';

//         // Loop through each file and generate an import statement
//         for (const op of oplist) {

//             console.log(op.name, op.meta.draft);
//             if (op.meta.draft === undefined || op.meta.draft !== true) {
//                 generatedCode += `import  ${op.name}_img  from 'adacad-drafting-lib/markdown/${op.meta.img}';\n`;
//                 generatedCode += `import  ${op.name}_md  from 'adacad-drafting-lib/markdown/${op.name}.md';\n`;
//                 generatedCode += `import  {${op.name}}  from 'adacad-drafting-lib/operations/${op.name}/${op.name}.js';\n`;
//             }
//         }


//         generatedCode += `export const assets = [\n`;

//         // Loop through each file and generate an import statement
//         for (const op of oplist) {
//             //const fileExt = path.extname(file);
//             // Filter for files with a .js extension to avoid non-JS files

//             if (oplist.draft === undefined) {
//                 generatedCode += `{\nname: '${op.name}',\n img: ${op.name}_img,\n md: ${op.name}_md,\njs: ${op.name}\n},\n`
//             }
//         }


//         generatedCode += `];\n`;


//         // Write the generated code to the output file
//         await fs.writeFile(outputFilePath, generatedCode, 'utf8');

//         console.log(`Successfully generated ES Module statements and wrote to ${outputFilePath}`);
//     } catch (err) {
//         console.error('An error occurred:', err);
//     }
// }

async function generateDocumentationPage(op) {
    try {
        const category = (op.meta.categories) ? op.meta.categories[0].name : 'undefined';
        const file_path = path.join(__dirname, `/docs/reference/operations/${category}/${op.name}/index.md`);

        //write front matter
        let generatedCode = `---\ntitle: ${op.meta.displayname}\n`;
        generatedCode += `sidebar_label: ${op.meta.displayname}\n`;
        generatedCode += `sidebar_class_name: ${category} opItem\n`;
        generatedCode += `editUrl: 'https://github.com/UnstableDesign/AdaCAD/tree/main/packages/adacad-drafting-lib/src/operations/${op.name}/${op.name}.ts'\n`;
        generatedCode += `---\n\n`
        generatedCode += `import {OperationHeader} from '@site/src/components/OperationPage';\n\n`;

        generatedCode += `<OperationHeader name='${op.name}' />\n\n`;

        // Read and inline the library's .md content
        const libMdPath = path.join(__dirname, '..', '..', 'packages', 'adacad-drafting-lib', 'src', 'operations', op.name, `${op.name}.md`);
        try {
            const mdContent = await fs.readFile(libMdPath, 'utf8');
            generatedCode += mdContent.trim() + '\n\n';
        } catch (e) {
            if (e.code === 'ENOENT') {
                generatedCode += `*No description found for ${op.name}.*\n\n`;
            } else {
                throw e;
            }
        }

        generatedCode += '```ts reference\n'
        generatedCode += `https://github.com/UnstableDesign/AdaCAD/tree/main/packages/adacad-drafting-lib/src/operations/${op.name}/${op.name}.ts\n`
        generatedCode += '```'

        // Write the generated code to the output file
        const docsCategoryOpDir = path.dirname(file_path);
        await fs.mkdir(docsCategoryOpDir, { recursive: true });
        await fs.writeFile(file_path, generatedCode, 'utf8');
        await copyOperationImages(op, docsCategoryOpDir);

        console.log(`Successfully generated ES Module statements and wrote to ${file_path} `);
    } catch (err) {
        console.error('An error occurred:', err);
    }
}


// Main execution: clear old assets, then generate new ones
(async () => {
    // try {
    //     await clearGeneratedAssets();

    //     for (const op of oplist) {
    //         if (op.meta.draft === undefined || op.meta.draft !== true) {
    //             await generateDocumentationPage(op);
    //         }
    //     }

    //     console.log('Generation complete!');
    // } catch (err) {
    //     console.error('Generation failed:', err);
    //     process.exit(1);
    // }
})();