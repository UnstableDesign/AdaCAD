{"version":3,"file":"typed-function.mjs","names":["ok","notOk","undef","undefined","NOT_TYPED_FUNCTION","create","isPlainObject","x","constructor","Object","_types","name","test","Array","isArray","Date","RegExp","anyType","isAny","typeMap","typeList","nConversions","typed","createCount","findType","typeName","type","get","message","toLowerCase","otherName","TypeError","addTypes","types","beforeSpec","arguments","length","beforeIndex","index","newTypes","i","has","push","set","conversionsTo","affectedTypes","slice","concat","clear","Map","clearConversions","findTypeNames","value","matches","filter","isTypedFunction","entity","findSignature","fn","signature","options","exact","stringSignature","join","params","parseSignature","canonicalSignature","stringifyParams","signatures","match","_typedFunctionData","signatureMap","nParams","remainingSignatures","want","filteredSignatures","possibility","have","getParamAtIndex","restParam","hasAny","haveTypes","paramTypeSet","some","wtype","candidate","find","implementation","convert","conversions","Error","fromType","from","separator","map","p","parseParam","param","indexOf","typeDefs","split","s","trim","paramName","exactTypes","typeIndex","conversion","conversionIndex","hasConversion","expandParam","typeNames","t","matchingConversions","availableConversions","newName","convertibleTypes","typeSet","Set","forEach","add","rawSignature","rawParams","parsedParam","SyntaxError","hasRestParam","last","compileTest","test0","test1","or","tests","compileTests","initial","varIndex","lastTest","testRestParam","args","testArgs","getTypeSetAtIndex","isExactType","mergeExpectedParams","paramSet","createError","err","expected","_name","matchingSignatures","nextMatchingDefs","actualTypes","data","category","actual","lengths","Infinity","Math","min","apply","maxLength","max","expectedLength","argTypes","getLowestTypeIndex","getLowestConversionIndex","compareParams","param1","param2","typeDiff","conv1","conv2","convDiff","compareSignatures","signature1","signature2","pars1","pars2","last1","last2","hasRest1","hasRest2","any1","par","any2","lengthCriterion","comparisons","tc","thisComparison","c","bonus","decrement","knownTypes","bestIndex","bestConversion","compileArgsPreprocessing","fnConvert","compiledConversions","compileArgConversion","conv","convertArgs","fnPreprocess","offset","preprocessRestParams","defineProperty","conversion0","conversion1","to","convertor","arg","convertArg","splitParams","_splitParams","paramsSoFar","resultingParams","flatMap","nextParam","conflicting","params1","params2","ii","typeSet1","typeSet2","overlap","len1","len2","restParam1","restParam2","clearResolutions","functionList","isReferToSelf","referToSelf","callback","isReferTo","makeReferTo","referTo","references","collectResolutions","resolvedReferences","reference","resolution","resolveReferences","self","resolvedFunctions","isResolved","fill","leftUnresolved","nothingResolved","validateDeprecatedThis","signaturesMap","deprecatedThisRegex","keys","toString","createTypedFunction","rawSignaturesMap","warnAgainstDeprecatedThis","parsedParams","originalFunctions","preliminarySignatures","prototype","hasOwnProperty","call","pp","functionIndex","conversionParams","sp","spName","every","sort","theTypedFn","internalSignatureMap","ok0","ok1","ok2","ok3","ok4","ok5","allOk","test00","test10","test20","test30","test40","test50","test01","test11","test21","test31","test41","test51","fn0","fn1","fn2","fn3","fn4","fn5","len0","len3","len4","len5","iStart","iEnd","fns","generic","onMismatch","arg0","arg1","_onMismatch","arr","start","end","findInArray","objectOrFn","checkName","nameSoFar","getObjectName","obj","key","mergeSignatures","dest","source","sourceFunction","destFunction","saveTyped","maybeName","named","allSignatures","item","theseSignatures","thisName","argument","throwMismatchError","_findType","addType","beforeObjectTest","before","_validateConversion","addConversion","override","existing","other","removeConversion","addConversions","existingConversion","splice","resolve","tf","argList","sigs"],"sources":["../../src/typed-function.mjs"],"sourcesContent":["function ok () {\n  return true\n}\n\nfunction notOk () {\n  return false\n}\n\nfunction undef () {\n  return undefined\n}\n\nconst NOT_TYPED_FUNCTION = 'Argument is not a typed-function.'\n\n/**\n * @typedef {{\n *   params: Param[],\n *   fn: function,\n *   test: function,\n *   implementation: function\n * }} Signature\n *\n * @typedef {{\n *   types: Type[],\n *   hasAny: boolean,\n *   hasConversion: boolean,\n *   restParam: boolean\n * }} Param\n *\n * @typedef {{\n *   name: string,\n *   typeIndex: number,\n *   test: function,\n *   isAny: boolean,\n *   conversion?: ConversionDef,\n *   conversionIndex: number,\n * }} Type\n *\n * @typedef {{\n *   from: string,\n *   to: string,\n *   convert: function (*) : *\n * }} ConversionDef\n *\n * @typedef {{\n *   name: string,\n *   test: function(*) : boolean,\n *   isAny?: boolean\n * }} TypeDef\n */\n\n/**\n * @returns {() => function}\n */\nfunction create () {\n  // data type tests\n\n  /**\n   * Returns true if the argument is a non-null \"plain\" object\n   */\n  function isPlainObject (x) {\n    return typeof x === 'object' && x !== null && x.constructor === Object\n  }\n\n  const _types = [\n    { name: 'number', test: function (x) { return typeof x === 'number' } },\n    { name: 'string', test: function (x) { return typeof x === 'string' } },\n    { name: 'boolean', test: function (x) { return typeof x === 'boolean' } },\n    { name: 'Function', test: function (x) { return typeof x === 'function' } },\n    { name: 'Array', test: Array.isArray },\n    { name: 'Date', test: function (x) { return x instanceof Date } },\n    { name: 'RegExp', test: function (x) { return x instanceof RegExp } },\n    { name: 'Object', test: isPlainObject },\n    { name: 'null', test: function (x) { return x === null } },\n    { name: 'undefined', test: function (x) { return x === undefined } }\n  ]\n\n  const anyType = {\n    name: 'any',\n    test: ok,\n    isAny: true\n  }\n\n  // Data structures to track the types. As these are local variables in\n  // create(), each typed universe will get its own copy, but the variables\n  // will only be accessible through the (closures of the) functions supplied\n  // as properties of the typed object, not directly.\n  // These will be initialized in clear() below\n  let typeMap // primary store of all types\n  let typeList // Array of just type names, for the sake of ordering\n\n  // And similar data structures for the type conversions:\n  let nConversions = 0\n  // the actual conversions are stored on a property of the destination types\n\n  // This is a temporary object, will be replaced with a function at the end\n  let typed = { createCount: 0 }\n\n  /**\n   * Takes a type name and returns the corresponding official type object\n   * for that type.\n   *\n   * @param {string} typeName\n   * @returns {TypeDef} type\n   */\n  function findType (typeName) {\n    const type = typeMap.get(typeName)\n    if (type) {\n      return type\n    }\n    // Remainder is error handling\n    let message = 'Unknown type \"' + typeName + '\"'\n    const name = typeName.toLowerCase()\n    let otherName\n    for (otherName of typeList) {\n      if (otherName.toLowerCase() === name) {\n        message += '. Did you mean \"' + otherName + '\" ?'\n        break\n      }\n    }\n    throw new TypeError(message)\n  }\n\n  /**\n   * Adds an array `types` of type definitions to this typed instance.\n   * Each type definition should be an object with properties:\n   * 'name' - a string giving the name of the type; 'test' - function\n   * returning a boolean that tests membership in the type; and optionally\n   * 'isAny' - true only for the 'any' type.\n   *\n   * The second optional argument, `before`, gives the name of a type that\n   * these types should be added before. The new types are added in the\n   * order specified.\n   * @param {TypeDef[]} types\n   * @param {string | boolean} [beforeSpec='any'] before\n   */\n  function addTypes (types, beforeSpec = 'any') {\n    const beforeIndex = beforeSpec\n      ? findType(beforeSpec).index\n      : typeList.length\n    const newTypes = []\n    for (let i = 0; i < types.length; ++i) {\n      if (!types[i] || typeof types[i].name !== 'string' ||\n        typeof types[i].test !== 'function') {\n        throw new TypeError('Object with properties {name: string, test: function} expected')\n      }\n      const typeName = types[i].name\n      if (typeMap.has(typeName)) {\n        throw new TypeError('Duplicate type name \"' + typeName + '\"')\n      }\n      newTypes.push(typeName)\n      typeMap.set(typeName, {\n        name: typeName,\n        test: types[i].test,\n        isAny: types[i].isAny,\n        index: beforeIndex + i,\n        conversionsTo: [] // Newly added type can't have any conversions to it\n      })\n    }\n    // update the typeList\n    const affectedTypes = typeList.slice(beforeIndex)\n    typeList =\n      typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes)\n    // Fix the indices\n    for (let i = beforeIndex + newTypes.length; i < typeList.length; ++i) {\n      typeMap.get(typeList[i]).index = i\n    }\n  }\n\n  /**\n   * Removes all types and conversions from this typed instance.\n   * May cause previously constructed typed-functions to throw\n   * strange errors when they are called with types that do not\n   * match any of their signatures.\n   */\n  function clear () {\n    typeMap = new Map()\n    typeList = []\n    nConversions = 0\n    addTypes([anyType], false)\n  }\n\n  // initialize the types to the default list\n  clear()\n  addTypes(_types)\n\n  /**\n   * Removes all conversions, leaving the types alone.\n   */\n  function clearConversions () {\n    let typeName\n    for (typeName of typeList) {\n      typeMap.get(typeName).conversionsTo = []\n    }\n    nConversions = 0\n  }\n\n  /**\n   * Find the type names that match a value.\n   * @param {*} value\n   * @return {string[]} Array of names of types for which\n   *                  the type test matches the value.\n   */\n  function findTypeNames (value) {\n    const matches = typeList.filter(name => {\n      const type = typeMap.get(name)\n      return !type.isAny && type.test(value)\n    })\n    if (matches.length) {\n      return matches\n    }\n    return ['any']\n  }\n\n  /**\n   * Check if an entity is a typed function created by any instance\n   * @param {any} entity\n   * @returns {boolean}\n   */\n  function isTypedFunction (entity) {\n    return entity && typeof entity === 'function' &&\n      '_typedFunctionData' in entity\n  }\n\n  /**\n   * Find a specific signature from a (composed) typed function, for example:\n   *\n   *   typed.findSignature(fn, ['number', 'string'])\n   *   typed.findSignature(fn, 'number, string')\n   *   typed.findSignature(fn, 'number,string', {exact: true})\n   *\n   * This function findSignature will by default return the best match to\n   * the given signature, possibly employing type conversions.\n   *\n   * The (optional) third argument is a plain object giving options\n   * controlling the signature search. Currently the only implemented\n   * option is `exact`: if specified as true (default is false), only\n   * exact matches will be returned (i.e. signatures for which `fn` was\n   * directly defined). Note that a (possibly different) type matching\n   * `any`, or one or more instances of TYPE matching `...TYPE` are\n   * considered exact matches in this regard, as no conversions are used.\n   *\n   * This function returns a \"signature\" object, as does `typed.resolve()`,\n   * which is a plain object with four keys: `params` (the array of parameters\n   * for this signature), `fn` (the originally supplied function for this\n   * signature), `test` (a generated function that determines if an argument\n   * list matches this signature, and `implementation` (the function to call\n   * on a matching argument list, that performs conversions if necessary and\n   * then calls the originally supplied function).\n   *\n   * @param {Function} fn                   A typed-function\n   * @param {string | string[]} signature\n   *     Signature to be found, can be an array or a comma separated string.\n   * @param {object} options  Controls the signature search as documented\n   * @return {{ params: Param[], fn: function, test: function, implementation: function }}\n   *     Returns the matching signature, or throws an error when no signature\n   *     is found.\n   */\n  function findSignature (fn, signature, options) {\n    if (!isTypedFunction(fn)) {\n      throw new TypeError(NOT_TYPED_FUNCTION)\n    }\n\n    // Canonicalize input\n    const exact = options && options.exact\n    const stringSignature = Array.isArray(signature)\n      ? signature.join(',')\n      : signature\n    const params = parseSignature(stringSignature)\n    const canonicalSignature = stringifyParams(params)\n\n    // First hope we get lucky and exactly match a signature\n    if (!exact || canonicalSignature in fn.signatures) {\n      // OK, we can check the internal signatures\n      const match =\n        fn._typedFunctionData.signatureMap.get(canonicalSignature)\n      if (match) {\n        return match\n      }\n    }\n\n    // Oh well, we did not; so we have to go back and check the parameters\n    // one by one, in order to catch things like `any` and rest params.\n    // Note here we can assume there is at least one parameter, because\n    // the empty signature would have matched successfully above.\n    const nParams = params.length\n    let remainingSignatures\n    if (exact) {\n      remainingSignatures = []\n      let name\n      for (name in fn.signatures) {\n        remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name))\n      }\n    } else {\n      remainingSignatures = fn._typedFunctionData.signatures\n    }\n    for (let i = 0; i < nParams; ++i) {\n      const want = params[i]\n      const filteredSignatures = []\n      let possibility\n      for (possibility of remainingSignatures) {\n        const have = getParamAtIndex(possibility.params, i)\n        if (!have || (want.restParam && !have.restParam)) {\n          continue\n        }\n        if (!have.hasAny) {\n          // have to check all of the wanted types are available\n          const haveTypes = paramTypeSet(have)\n          if (want.types.some(wtype => !haveTypes.has(wtype.name))) {\n            continue\n          }\n        }\n        // OK, this looks good\n        filteredSignatures.push(possibility)\n      }\n      remainingSignatures = filteredSignatures\n      if (remainingSignatures.length === 0) break\n    }\n    // Return the first remaining signature that was totally matched:\n    let candidate\n    for (candidate of remainingSignatures) {\n      if (candidate.params.length <= nParams) {\n        return candidate\n      }\n    }\n\n    throw new TypeError('Signature not found (signature: ' + (fn.name || 'unnamed') + '(' + stringifyParams(params, ', ') + '))')\n  }\n\n  /**\n   * Find the proper function to call for a specific signature from\n   * a (composed) typed function, for example:\n   *\n   *   typed.find(fn, ['number', 'string'])\n   *   typed.find(fn, 'number, string')\n   *   typed.find(fn, 'number,string', {exact: true})\n   *\n   * This function find will by default return the best match to\n   * the given signature, possibly employing type conversions (and returning\n   * a function that will perform those conversions as needed). The\n   * (optional) third argument is a plain object giving options contolling\n   * the signature search. Currently only the option `exact` is implemented,\n   * which defaults to \"false\". If `exact` is specified as true, then only\n   * exact matches will be returned (i.e. signatures for which `fn` was\n   * directly defined). Uses of `any` and `...TYPE` are considered exact if\n   * no conversions are necessary to apply the corresponding function.\n   *\n   * @param {Function} fn                   A typed-function\n   * @param {string | string[]} signature\n   *     Signature to be found, can be an array or a comma separated string.\n   * @param {object} options  Controls the signature match as documented\n   * @return {function}\n   *     Returns the function to call for the given signature, or throws an\n   *     error if no match is found.\n   */\n  function find (fn, signature, options) {\n    return findSignature(fn, signature, options).implementation\n  }\n\n  /**\n   * Convert a given value to another data type, specified by type name.\n   *\n   * @param {*} value\n   * @param {string} typeName\n   */\n  function convert (value, typeName) {\n    // check conversion is needed\n    const type = findType(typeName)\n    if (type.test(value)) {\n      return value\n    }\n    const conversions = type.conversionsTo\n    if (conversions.length === 0) {\n      throw new Error(\n        'There are no conversions to ' + typeName + ' defined.')\n    }\n    for (let i = 0; i < conversions.length; i++) {\n      const fromType = findType(conversions[i].from)\n      if (fromType.test(value)) {\n        return conversions[i].convert(value)\n      }\n    }\n\n    throw new Error('Cannot convert ' + value + ' to ' + typeName)\n  }\n\n  /**\n   * Stringify parameters in a normalized way\n   * @param {Param[]} params\n   * @param {string} [','] separator\n   * @return {string}\n   */\n  function stringifyParams (params, separator = ',') {\n    return params.map(p => p.name).join(separator)\n  }\n\n  /**\n   * Parse a parameter, like \"...number | boolean\"\n   * @param {string} param\n   * @return {Param} param\n   */\n  function parseParam (param) {\n    const restParam = param.indexOf('...') === 0\n    const types = (!restParam)\n      ? param\n      : (param.length > 3)\n          ? param.slice(3)\n          : 'any'\n\n    const typeDefs = types.split('|').map(s => findType(s.trim()))\n\n    let hasAny = false\n    let paramName = restParam ? '...' : ''\n\n    const exactTypes = typeDefs.map(function (type) {\n      hasAny = type.isAny || hasAny\n      paramName += type.name + '|'\n\n      return {\n        name: type.name,\n        typeIndex: type.index,\n        test: type.test,\n        isAny: type.isAny,\n        conversion: null,\n        conversionIndex: -1\n      }\n    })\n\n    return {\n      types: exactTypes,\n      name: paramName.slice(0, -1), // remove trailing '|' from above\n      hasAny,\n      hasConversion: false,\n      restParam\n    }\n  }\n\n  /**\n   * Expands a parsed parameter with the types available from currently\n   * defined conversions.\n   * @param {Param} param\n   * @return {Param} param\n   */\n  function expandParam (param) {\n    const typeNames = param.types.map(t => t.name)\n    const matchingConversions = availableConversions(typeNames)\n    let hasAny = param.hasAny\n    let newName = param.name\n\n    const convertibleTypes = matchingConversions.map(function (conversion) {\n      const type = findType(conversion.from)\n      hasAny = type.isAny || hasAny\n      newName += '|' + conversion.from\n\n      return {\n        name: conversion.from,\n        typeIndex: type.index,\n        test: type.test,\n        isAny: type.isAny,\n        conversion,\n        conversionIndex: conversion.index\n      }\n    })\n\n    return {\n      types: param.types.concat(convertibleTypes),\n      name: newName,\n      hasAny,\n      hasConversion: convertibleTypes.length > 0,\n      restParam: param.restParam\n    }\n  }\n\n  /**\n   * Return the set of type names in a parameter.\n   * Caches the result for efficiency\n   *\n   * @param {Param} param\n   * @return {Set<string>} typenames\n   */\n  function paramTypeSet (param) {\n    if (!param.typeSet) {\n      param.typeSet = new Set()\n      param.types.forEach(type => param.typeSet.add(type.name))\n    }\n    return param.typeSet\n  }\n\n  /**\n   * Parse a signature with comma separated parameters,\n   * like \"number | boolean, ...string\"\n   *\n   * @param {string} signature\n   * @return {Param[]} params\n   */\n  function parseSignature (rawSignature) {\n    const params = []\n    if (typeof rawSignature !== 'string') {\n      throw new TypeError('Signatures must be strings')\n    }\n    const signature = rawSignature.trim()\n    if (signature === '') {\n      return params\n    }\n\n    const rawParams = signature.split(',')\n    for (let i = 0; i < rawParams.length; ++i) {\n      const parsedParam = parseParam(rawParams[i].trim())\n      if (parsedParam.restParam && (i !== rawParams.length - 1)) {\n        throw new SyntaxError(\n          'Unexpected rest parameter \"' + rawParams[i] + '\": ' +\n          'only allowed for the last parameter')\n      }\n      // if invalid, short-circuit (all the types may have been filtered)\n      if (parsedParam.types.length === 0) {\n        return null\n      }\n      params.push(parsedParam)\n    }\n\n    return params\n  }\n\n  /**\n   * Test whether a set of params contains a restParam\n   * @param {Param[]} params\n   * @return {boolean} Returns true when the last parameter is a restParam\n   */\n  function hasRestParam (params) {\n    const param = last(params)\n    return param ? param.restParam : false\n  }\n\n  /**\n   * Create a type test for a single parameter, which can have one or multiple\n   * types.\n   * @param {Param} param\n   * @return {function(x: *) : boolean} Returns a test function\n   */\n  function compileTest (param) {\n    if (!param || param.types.length === 0) {\n      // nothing to do\n      return ok\n    } else if (param.types.length === 1) {\n      return findType(param.types[0].name).test\n    } else if (param.types.length === 2) {\n      const test0 = findType(param.types[0].name).test\n      const test1 = findType(param.types[1].name).test\n      return function or (x) {\n        return test0(x) || test1(x)\n      }\n    } else { // param.types.length > 2\n      const tests = param.types.map(function (type) {\n        return findType(type.name).test\n      })\n      return function or (x) {\n        for (let i = 0; i < tests.length; i++) {\n          if (tests[i](x)) {\n            return true\n          }\n        }\n        return false\n      }\n    }\n  }\n\n  /**\n   * Create a test for all parameters of a signature\n   * @param {Param[]} params\n   * @return {function(args: Array<*>) : boolean}\n   */\n  function compileTests (params) {\n    let tests, test0, test1\n\n    if (hasRestParam(params)) {\n      // variable arguments like '...number'\n      tests = initial(params).map(compileTest)\n      const varIndex = tests.length\n      const lastTest = compileTest(last(params))\n      const testRestParam = function (args) {\n        for (let i = varIndex; i < args.length; i++) {\n          if (!lastTest(args[i])) {\n            return false\n          }\n        }\n        return true\n      }\n\n      return function testArgs (args) {\n        for (let i = 0; i < tests.length; i++) {\n          if (!tests[i](args[i])) {\n            return false\n          }\n        }\n        return testRestParam(args) && (args.length >= varIndex + 1)\n      }\n    } else {\n      // no variable arguments\n      if (params.length === 0) {\n        return function testArgs (args) {\n          return args.length === 0\n        }\n      } else if (params.length === 1) {\n        test0 = compileTest(params[0])\n        return function testArgs (args) {\n          return test0(args[0]) && args.length === 1\n        }\n      } else if (params.length === 2) {\n        test0 = compileTest(params[0])\n        test1 = compileTest(params[1])\n        return function testArgs (args) {\n          return test0(args[0]) && test1(args[1]) && args.length === 2\n        }\n      } else { // arguments.length > 2\n        tests = params.map(compileTest)\n        return function testArgs (args) {\n          for (let i = 0; i < tests.length; i++) {\n            if (!tests[i](args[i])) {\n              return false\n            }\n          }\n          return args.length === tests.length\n        }\n      }\n    }\n  }\n\n  /**\n   * Find the parameter at a specific index of a Params list.\n   * Handles rest parameters.\n   * @param {Param[]} params\n   * @param {number} index\n   * @return {Param | null} Returns the matching parameter when found,\n   *                        null otherwise.\n   */\n  function getParamAtIndex (params, index) {\n    return index < params.length\n      ? params[index]\n      : hasRestParam(params) ? last(params) : null\n  }\n\n  /**\n   * Get all type names of a parameter\n   * @param {Params[]} params\n   * @param {number} index\n   * @return {string[]} Returns an array with type names\n   */\n  function getTypeSetAtIndex (params, index) {\n    const param = getParamAtIndex(params, index)\n    if (!param) {\n      return new Set()\n    }\n    return paramTypeSet(param)\n  }\n\n  /**\n   * Test whether a type is an exact type or conversion\n   * @param {Type} type\n   * @return {boolean} Returns true when\n   */\n  function isExactType (type) {\n    return type.conversion === null || type.conversion === undefined\n  }\n\n  /**\n   * Helper function for creating error messages: create an array with\n   * all available types on a specific argument index.\n   * @param {Signature[]} signatures\n   * @param {number} index\n   * @return {string[]} Returns an array with available types\n   */\n  function mergeExpectedParams (signatures, index) {\n    const typeSet = new Set()\n    signatures.forEach(signature => {\n      const paramSet = getTypeSetAtIndex(signature.params, index)\n      let name\n      for (name of paramSet) {\n        typeSet.add(name)\n      }\n    })\n\n    return typeSet.has('any') ? ['any'] : Array.from(typeSet)\n  }\n\n  /**\n   * Create\n   * @param {string} name             The name of the function\n   * @param {array.<*>} args          The actual arguments passed to the function\n   * @param {Signature[]} signatures  A list with available signatures\n   * @return {TypeError} Returns a type error with additional data\n   *                     attached to it in the property `data`\n   */\n  function createError (name, args, signatures) {\n    let err, expected\n    const _name = name || 'unnamed'\n\n    // test for wrong type at some index\n    let matchingSignatures = signatures\n    let index\n    for (index = 0; index < args.length; index++) {\n      const nextMatchingDefs = []\n      matchingSignatures.forEach(signature => {\n        const param = getParamAtIndex(signature.params, index)\n        const test = compileTest(param)\n        if ((index < signature.params.length ||\n          hasRestParam(signature.params)) &&\n          test(args[index])) {\n          nextMatchingDefs.push(signature)\n        }\n      })\n\n      if (nextMatchingDefs.length === 0) {\n        // no matching signatures anymore, throw error \"wrong type\"\n        expected = mergeExpectedParams(matchingSignatures, index)\n        if (expected.length > 0) {\n          const actualTypes = findTypeNames(args[index])\n\n          err = new TypeError('Unexpected type of argument in function ' + _name +\n            ' (expected: ' + expected.join(' or ') +\n            ', actual: ' + actualTypes.join(' | ') + ', index: ' + index + ')')\n          err.data = {\n            category: 'wrongType',\n            fn: _name,\n            index,\n            actual: actualTypes,\n            expected\n          }\n          return err\n        }\n      } else {\n        matchingSignatures = nextMatchingDefs\n      }\n    }\n\n    // test for too few arguments\n    const lengths = matchingSignatures.map(function (signature) {\n      return hasRestParam(signature.params)\n        ? Infinity\n        : signature.params.length\n    })\n    if (args.length < Math.min.apply(null, lengths)) {\n      expected = mergeExpectedParams(matchingSignatures, index)\n      err = new TypeError('Too few arguments in function ' + _name +\n        ' (expected: ' + expected.join(' or ') +\n        ', index: ' + args.length + ')')\n      err.data = {\n        category: 'tooFewArgs',\n        fn: _name,\n        index: args.length,\n        expected\n      }\n      return err\n    }\n\n    // test for too many arguments\n    const maxLength = Math.max.apply(null, lengths)\n    if (args.length > maxLength) {\n      err = new TypeError('Too many arguments in function ' + _name +\n        ' (expected: ' + maxLength + ', actual: ' + args.length + ')')\n      err.data = {\n        category: 'tooManyArgs',\n        fn: _name,\n        index: args.length,\n        expectedLength: maxLength\n      }\n      return err\n    }\n\n    // Generic error\n    const argTypes = []\n    for (let i = 0; i < args.length; ++i) {\n      argTypes.push(findTypeNames(args[i]).join('|'))\n    }\n    err = new TypeError('Arguments of type \"' + argTypes.join(', ') +\n      '\" do not match any of the defined signatures of function ' + _name + '.')\n    err.data = {\n      category: 'mismatch',\n      actual: argTypes\n    }\n    return err\n  }\n\n  /**\n   * Find the lowest index of all types of a parameter\n   * @param {Param} param\n   * @return {number} Returns the index of the lowest type in typed.types\n   */\n  function getLowestTypeIndex (param) {\n    let min = typeList.length + 1\n\n    for (let i = 0; i < param.types.length; i++) {\n      min = Math.min(min, param.types[i].typeIndex)\n    }\n\n    return min\n  }\n\n  /**\n   * Find the lowest index of the conversion of all types of the parameter\n   * having a conversion\n   * @param {Param} param\n   * @return {number} Returns the lowest index of the conversions of this type\n   */\n  function getLowestConversionIndex (param) {\n    let min = nConversions + 1\n\n    for (let i = 0; i < param.types.length; i++) {\n      if (!isExactType(param.types[i])) {\n        min = Math.min(min, param.types[i].conversionIndex)\n      }\n    }\n\n    return min\n  }\n\n  /**\n   * Compare two params. The return value is a number that is\n   * negative when param1 should be considered first, positive\n   * when param2 should be considered first, and zero when the\n   * params are indistinguishable. Primarily as a debugging aid,\n   * the value is always less than one in absolute value, and\n   * a smaller absolute value indicates a less important distinction\n   * between the parameters.\n   * @param {Param} param1\n   * @param {Param} param2\n   * @return {number} negative, positive, or zero depending on whether\n   *                  param1 should be ordered before, after, or equivalently\n   *                  to param2\n   */\n  function compareParams (param1, param2) {\n    // We compare a number of metrics on a param in turn:\n    // 1) 'any' parameters are the least preferred\n    if (param1.hasAny) {\n      if (!param2.hasAny) {\n        return 0.1\n      }\n    } else if (param2.hasAny) {\n      return -0.1\n    }\n\n    // 2) Prefer non-rest to rest parameters\n    if (param1.restParam) {\n      if (!param2.restParam) {\n        return 0.01\n      }\n    } else if (param2.restParam) {\n      return -0.01\n    }\n\n    // 3) Prefer lower type index:\n    const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2)\n    if (typeDiff < 0) {\n      return -0.001\n    }\n    if (typeDiff > 0) {\n      return 0.001\n    }\n\n    // 4) Prefer exact type match to conversions, with a strength that\n    //    grows with the conversion index\n    const conv1 = getLowestConversionIndex(param1)\n    const conv2 = getLowestConversionIndex(param2)\n    if (param1.hasConversion) {\n      if (!param2.hasConversion) {\n        return (1 + conv1) * 0.000001\n      }\n    } else if (param2.hasConversion) {\n      return -(1 + conv2) * 0.000001\n    }\n\n    // 5) Prefer lower conversion index\n    const convDiff = conv1 - conv2\n    if (convDiff < 0) {\n      return -0.0000001\n    }\n    if (convDiff > 0) {\n      return 0.0000001\n    }\n\n    // Don't have a basis for preference\n    return 0\n  }\n\n  /**\n   * Compare two signatures. The result is a number that is negative\n   * when the first signature should be preferred to the second, positive\n   * when the second signature should be preferred, and zero in case the\n   * two signatures are essentially equivalent. Primarily as a debugging\n   * aid, a larger absolute value indicates a more \"important\" difference.\n   *\n   * @param {Signature} signature1\n   * @param {Signature} signature2\n   * @return {number} returns a negative number when signature1 must get a\n   *                  lower index than signature2, a positive number when the\n   *                  opposite holds, or zero when both are equivalent.\n   */\n  function compareSignatures (signature1, signature2) {\n    const pars1 = signature1.params\n    const pars2 = signature2.params\n    const last1 = last(pars1)\n    const last2 = last(pars2)\n    const hasRest1 = hasRestParam(pars1)\n    const hasRest2 = hasRestParam(pars2)\n    // We compare a number of metrics on signatures in turn:\n    // 1) An \"any rest param\" is least preferred\n    if (hasRest1 && last1.hasAny) {\n      if (!hasRest2 || !last2.hasAny) {\n        return 10000000\n      }\n    } else if (hasRest2 && last2.hasAny) {\n      return -10000000\n    }\n\n    // 2) Minimize the number of 'any' parameters\n    let any1 = 0\n    let conv1 = 0\n    let par\n    for (par of pars1) {\n      if (par.hasAny) ++any1\n      if (par.hasConversion) ++conv1\n    }\n    let any2 = 0\n    let conv2 = 0\n    for (par of pars2) {\n      if (par.hasAny) ++any2\n      if (par.hasConversion) ++conv2\n    }\n    if (any1 !== any2) {\n      return (any1 - any2) * 1000000\n    }\n\n    // 3) A conversion rest param is less preferred\n    if (hasRest1 && last1.hasConversion) {\n      if (!hasRest2 || !last2.hasConversion) {\n        return 100000\n      }\n    } else if (hasRest2 && last2.hasConversion) {\n      return -100000\n    }\n\n    // 4) Minimize the number of conversions\n    if (conv1 !== conv2) {\n      return (conv1 - conv2) * 10000\n    }\n\n    // 5) Prefer no rest param\n    if (hasRest1) {\n      if (!hasRest2) {\n        return 1000\n      }\n    } else if (hasRest2) {\n      return -1000\n    }\n\n    // 6) Prefer shorter with rest param, longer without\n    const lengthCriterion =\n      (pars1.length - pars2.length) * (hasRest1 ? -100 : 100)\n    if (lengthCriterion !== 0) {\n      return lengthCriterion\n    }\n\n    // Signatures are identical in each of the above metrics.\n    // In particular, they are the same length.\n    // We can therefore compare the parameters one by one.\n    // First we count which signature has more preferred parameters.\n    const comparisons = []\n    let tc = 0\n    for (let i = 0; i < pars1.length; ++i) {\n      const thisComparison = compareParams(pars1[i], pars2[i])\n      comparisons.push(thisComparison)\n      tc += thisComparison\n    }\n    if (tc !== 0) {\n      return ((tc < 0) ? -10 : 10) + tc\n    }\n\n    // They have the same number of preferred parameters, so go by the\n    // earliest parameter in which we have a preference.\n    // In other words, dispatch is driven somewhat more by earlier\n    // parameters than later ones.\n    let c\n    let bonus = 9\n    const decrement = bonus / (comparisons.length + 1)\n    for (c of comparisons) {\n      if (c !== 0) {\n        return ((c < 0) ? -bonus : bonus) + c\n      }\n      bonus -= decrement\n    }\n\n    // It's a tossup:\n    return 0\n  }\n\n  /**\n   * Produce a list of all conversions from distinct types to one of\n   * the given types.\n   *\n   * @param {string[]} typeNames\n   * @return {ConversionDef[]} Returns the conversions that are available\n   *                        resulting in any given type (if any)\n   */\n  function availableConversions (typeNames) {\n    if (typeNames.length === 0) {\n      return []\n    }\n    const types = typeNames.map(findType)\n    if (typeNames.length === 1) return types[0].conversionsTo\n\n    // Here, for each type that occurs as the from-type of any conversion\n    // to any of the types found, we must select the conversion of\n    // lowest index from that type. So first collect the types.\n    const knownTypes = new Set(typeNames)\n    const convertibleTypes = new Set()\n    for (let i = 0; i < types.length; ++i) {\n      for (const match of types[i].conversionsTo) {\n        if (!knownTypes.has(match.from)) convertibleTypes.add(match.from)\n      }\n    }\n\n    // Now get the lowest-index conversion for each type\n    const matches = []\n    for (const typeName of convertibleTypes) {\n      let bestIndex = nConversions + 1\n      let bestConversion = null\n      for (let i = 0; i < types.length; ++i) {\n        for (const match of types[i].conversionsTo) {\n          if (match.from === typeName && match.index < bestIndex) {\n            bestIndex = match.index\n            bestConversion = match\n          }\n        }\n      }\n      matches.push(bestConversion)\n    }\n\n    return matches\n  }\n\n  /**\n   * Preprocess arguments before calling the original function:\n   * - if needed convert the parameters\n   * - in case of rest parameters, move the rest parameters into an Array\n   * @param {Param[]} params\n   * @param {function} fn\n   * @return {function} Returns fn or a wrapped function if needed. If it\n   *                    has conversions, the function will be named to indicate\n   *                    what conversions are occurring.\n   */\n  function compileArgsPreprocessing (params, fn) {\n    let fnConvert = fn\n\n    // TODO: can we make this wrapper function smarter/simpler?\n\n    let name = ''\n    if (params.some(p => p.hasConversion)) {\n      const restParam = hasRestParam(params)\n      const compiledConversions = params.map(compileArgConversion)\n      name = compiledConversions.map(conv => conv.name).join(';')\n      fnConvert = function convertArgs () {\n        const args = []\n        const last = restParam ? arguments.length - 1 : arguments.length\n        for (let i = 0; i < last; i++) {\n          args[i] = compiledConversions[i](arguments[i])\n        }\n        if (restParam) {\n          args[last] = arguments[last].map(compiledConversions[last])\n        }\n\n        return fn.apply(this, args)\n      }\n    }\n\n    let fnPreprocess = fnConvert\n    if (hasRestParam(params)) {\n      const offset = params.length - 1\n\n      fnPreprocess = function preprocessRestParams () {\n        return fnConvert.apply(this,\n          slice(arguments, 0, offset).concat([slice(arguments, offset)]))\n      }\n    }\n    if (name) Object.defineProperty(fnPreprocess, 'name', { value: name })\n    return fnPreprocess\n  }\n\n  /**\n   * Compile conversion for a parameter to the right type\n   * @param {Param} param\n   * @return {function} Returns the wrapped function that will convert arguments\n   *\n   */\n  function compileArgConversion (param) {\n    let test0, test1, conversion0, conversion1\n    const tests = []\n    const conversions = []\n    let name = ''\n    param.types.forEach(function (type) {\n      if (type.conversion) {\n        name += type.conversion.from + '~>' + type.conversion.to + ','\n        tests.push(findType(type.conversion.from).test)\n        conversions.push(type.conversion.convert)\n      }\n    })\n    if (name) name = name.slice(0, -1)\n    else name = 'pass'\n\n    // create optimized conversion functions depending on the number of conversions\n    let convertor = arg => arg\n    switch (conversions.length) {\n      case 0: break\n      case 1:\n        test0 = tests[0]\n        conversion0 = conversions[0]\n        convertor = function convertArg (arg) {\n          if (test0(arg)) {\n            return conversion0(arg)\n          }\n          return arg\n        }\n        break\n      case 2:\n        test0 = tests[0]\n        test1 = tests[1]\n        conversion0 = conversions[0]\n        conversion1 = conversions[1]\n        convertor = function convertArg (arg) {\n          if (test0(arg)) {\n            return conversion0(arg)\n          }\n          if (test1(arg)) {\n            return conversion1(arg)\n          }\n          return arg\n        }\n        break\n      default:\n        convertor = function convertArg (arg) {\n          for (let i = 0; i < conversions.length; i++) {\n            if (tests[i](arg)) {\n              return conversions[i](arg)\n            }\n          }\n          return arg\n        }\n    }\n    Object.defineProperty(convertor, 'name', { value: name })\n    return convertor\n  }\n\n  /**\n   * Split params with union types in to separate params.\n   *\n   * For example:\n   *\n   *     splitParams([['Array', 'Object'], ['string', 'RegExp'])\n   *     // returns:\n   *     // [\n   *     //   ['Array', 'string'],\n   *     //   ['Array', 'RegExp'],\n   *     //   ['Object', 'string'],\n   *     //   ['Object', 'RegExp']\n   *     // ]\n   *\n   * @param {Param[]} params\n   * @return {Param[]}\n   */\n  function splitParams (params) {\n    function _splitParams (params, index, paramsSoFar) {\n      if (index < params.length) {\n        const param = params[index]\n        let resultingParams = []\n\n        if (param.restParam) {\n          // split the types of a rest parameter in two:\n          // one with only exact types, and one with exact types and conversions\n          const exactTypes = param.types.filter(isExactType)\n          if (exactTypes.length < param.types.length) {\n            resultingParams.push({\n              types: exactTypes,\n              name: '...' + exactTypes.map(t => t.name).join('|'),\n              hasAny: exactTypes.some(t => t.isAny),\n              hasConversion: false,\n              restParam: true\n            })\n          }\n          resultingParams.push(param)\n        } else {\n          // split all the types of a regular parameter into one type per param\n          resultingParams = param.types.map(function (type) {\n            return {\n              types: [type],\n              name: type.name,\n              hasAny: type.isAny,\n              hasConversion: type.conversion,\n              restParam: false\n            }\n          })\n        }\n\n        // recurse over the groups with types\n        return flatMap(resultingParams, function (nextParam) {\n          return _splitParams(params, index + 1, paramsSoFar.concat([nextParam]))\n        })\n      } else {\n        // we've reached the end of the parameters.\n        return [paramsSoFar]\n      }\n    }\n\n    return _splitParams(params, 0, [])\n  }\n\n  /**\n   * Test whether two param lists represent conflicting signatures\n   * @param {Param[]} params1\n   * @param {Param[]} params2\n   * @return {boolean} Returns true when the signatures conflict, false otherwise.\n   */\n  function conflicting (params1, params2) {\n    const ii = Math.max(params1.length, params2.length)\n\n    for (let i = 0; i < ii; i++) {\n      const typeSet1 = getTypeSetAtIndex(params1, i)\n      const typeSet2 = getTypeSetAtIndex(params2, i)\n      let overlap = false\n      let name\n      for (name of typeSet2) {\n        if (typeSet1.has(name)) {\n          overlap = true\n          break\n        }\n      }\n      if (!overlap) {\n        return false\n      }\n    }\n\n    const len1 = params1.length\n    const len2 = params2.length\n    const restParam1 = hasRestParam(params1)\n    const restParam2 = hasRestParam(params2)\n\n    return restParam1\n      ? restParam2 ? (len1 === len2) : (len2 >= len1)\n      : restParam2 ? (len1 >= len2) : (len1 === len2)\n  }\n\n  /**\n   * Helper function for `resolveReferences` that returns a copy of\n   * functionList wihe any prior resolutions cleared out, in case we are\n   * recycling signatures from a prior typed function construction.\n   *\n   * @param {Array.<function|typed-reference>} functionList\n   * @return {Array.<function|typed-reference>}\n   */\n  function clearResolutions (functionList) {\n    return functionList.map(fn => {\n      if (isReferToSelf(fn)) {\n        return referToSelf(fn.referToSelf.callback)\n      }\n      if (isReferTo(fn)) {\n        return makeReferTo(fn.referTo.references, fn.referTo.callback)\n      }\n      return fn\n    })\n  }\n\n  /**\n   * Take a list of references, a list of functions functionList, and a\n   * signatureMap indexing signatures into functionList, and return\n   * the list of resolutions, or a false-y value if they don't all\n   * resolve in a valid way (yet).\n   *\n   * @param {string[]} references\n   * @param {Array<function|typed-reference} functionList\n   * @param {Object.<string, integer>} signatureMap\n   * @return {function[] | false} resolutions\n   */\n  function collectResolutions (references, functionList, signatureMap) {\n    const resolvedReferences = []\n    let reference\n    for (reference of references) {\n      let resolution = signatureMap[reference]\n      if (typeof resolution !== 'number') {\n        throw new TypeError(\n          'No definition for referenced signature \"' + reference + '\"')\n      }\n      resolution = functionList[resolution]\n      if (typeof resolution !== 'function') {\n        return false\n      }\n      resolvedReferences.push(resolution)\n    }\n    return resolvedReferences\n  }\n\n  /**\n   * Resolve any references in the functionList for the typed function\n   * itself. The signatureMap tells which index in the functionList a\n   * given signature should be mapped to (for use in resolving typed.referTo)\n   * and self provides the destions of a typed.referToSelf.\n   *\n   * @param {Array<function | typed-reference-object>} functionList\n   * @param {Object.<string, function>} signatureMap\n   * @param {function} self  The typed-function itself\n   * @return {Array<function>} The list of resolved functions\n   */\n  function resolveReferences (functionList, signatureMap, self) {\n    const resolvedFunctions = clearResolutions(functionList)\n    const isResolved = new Array(resolvedFunctions.length).fill(false)\n    let leftUnresolved = true\n    while (leftUnresolved) {\n      leftUnresolved = false\n      let nothingResolved = true\n      for (let i = 0; i < resolvedFunctions.length; ++i) {\n        if (isResolved[i]) continue\n        const fn = resolvedFunctions[i]\n\n        if (isReferToSelf(fn)) {\n          resolvedFunctions[i] = fn.referToSelf.callback(self)\n          // Preserve reference in case signature is reused someday:\n          resolvedFunctions[i].referToSelf = fn.referToSelf\n          isResolved[i] = true\n          nothingResolved = false\n        } else if (isReferTo(fn)) {\n          const resolvedReferences = collectResolutions(\n            fn.referTo.references, resolvedFunctions, signatureMap)\n          if (resolvedReferences) {\n            resolvedFunctions[i] =\n              fn.referTo.callback.apply(this, resolvedReferences)\n            // Preserve reference in case signature is reused someday:\n            resolvedFunctions[i].referTo = fn.referTo\n            isResolved[i] = true\n            nothingResolved = false\n          } else {\n            leftUnresolved = true\n          }\n        }\n      }\n\n      if (nothingResolved && leftUnresolved) {\n        throw new SyntaxError(\n          'Circular reference detected in resolving typed.referTo')\n      }\n    }\n\n    return resolvedFunctions\n  }\n\n  /**\n   * Validate whether any of the function bodies contains a self-reference\n   * usage like `this(...)` or `this.signatures`. This self-referencing is\n   * deprecated since typed-function v3. It has been replaced with\n   * the functions typed.referTo and typed.referToSelf.\n   * @param {Object.<string, function>} signaturesMap\n   */\n  function validateDeprecatedThis (signaturesMap) {\n    // TODO: remove this deprecation warning logic some day (it's introduced in v3)\n\n    // match occurrences like 'this(' and 'this.signatures'\n    const deprecatedThisRegex = /\\bthis(\\(|\\.signatures\\b)/\n\n    Object.keys(signaturesMap).forEach(signature => {\n      const fn = signaturesMap[signature]\n\n      if (deprecatedThisRegex.test(fn.toString())) {\n        throw new SyntaxError('Using `this` to self-reference a function ' +\n          'is deprecated since typed-function@3. ' +\n          'Use typed.referTo and typed.referToSelf instead.')\n      }\n    })\n  }\n\n  /**\n   * Create a typed function\n   * @param {String} name               The name for the typed function\n   * @param {Object.<string, function>} rawSignaturesMap\n   *                                    An object with one or\n   *                                    multiple signatures as key, and the\n   *                                    function corresponding to the\n   *                                    signature as value.\n   * @return {function}  Returns the created typed function.\n   */\n  function createTypedFunction (name, rawSignaturesMap) {\n    typed.createCount++\n\n    if (Object.keys(rawSignaturesMap).length === 0) {\n      throw new SyntaxError('No signatures provided')\n    }\n\n    if (typed.warnAgainstDeprecatedThis) {\n      validateDeprecatedThis(rawSignaturesMap)\n    }\n\n    // Main processing loop for signatures\n    const parsedParams = []\n    const originalFunctions = []\n    const signaturesMap = {}\n    const preliminarySignatures = [] // may have duplicates from conversions\n    let signature\n    for (signature in rawSignaturesMap) {\n      // A) Protect against polluted Object prototype:\n      if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {\n        continue\n      }\n      // B) Parse the signature\n      const params = parseSignature(signature)\n      if (!params) continue\n      // C) Check for conflicts\n      parsedParams.forEach(function (pp) {\n        if (conflicting(pp, params)) {\n          throw new TypeError('Conflicting signatures \"' +\n            stringifyParams(pp) + '\" and \"' +\n            stringifyParams(params) + '\".')\n        }\n      })\n      parsedParams.push(params)\n      // D) Store the provided function and add conversions\n      const functionIndex = originalFunctions.length\n      originalFunctions.push(rawSignaturesMap[signature])\n      const conversionParams = params.map(expandParam)\n      // E) Split the signatures and collect them up\n      let sp\n      for (sp of splitParams(conversionParams)) {\n        const spName = stringifyParams(sp)\n        preliminarySignatures.push(\n          { params: sp, name: spName, fn: functionIndex })\n        if (sp.every(p => !p.hasConversion)) {\n          signaturesMap[spName] = functionIndex\n        }\n      }\n    }\n\n    preliminarySignatures.sort(compareSignatures)\n\n    // Note the forward reference to theTypedFn\n    const resolvedFunctions =\n      resolveReferences(originalFunctions, signaturesMap, theTypedFn)\n\n    // Fill in the proper function for each signature\n    let s\n    for (s in signaturesMap) {\n      if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {\n        signaturesMap[s] = resolvedFunctions[signaturesMap[s]]\n      }\n    }\n    const signatures = []\n    const internalSignatureMap = new Map() // benchmarks faster than object\n    for (s of preliminarySignatures) {\n      // Note it's only safe to eliminate duplicates like this\n      // _after_ the signature sorting step above; otherwise we might\n      // remove the wrong one.\n      if (!internalSignatureMap.has(s.name)) {\n        s.fn = resolvedFunctions[s.fn]\n        signatures.push(s)\n        internalSignatureMap.set(s.name, s)\n      }\n    }\n\n    // we create a highly optimized checks for the first couple of signatures with max 2 arguments\n    const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params)\n    const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params)\n    const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params)\n    const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params)\n    const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params)\n    const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params)\n    const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5\n\n    // compile the tests\n    for (let i = 0; i < signatures.length; ++i) {\n      signatures[i].test = compileTests(signatures[i].params)\n    }\n\n    const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk\n    const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk\n    const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk\n    const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk\n    const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk\n    const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk\n\n    const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk\n    const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk\n    const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk\n    const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk\n    const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk\n    const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk\n\n    // compile the functions\n    for (let i = 0; i < signatures.length; ++i) {\n      signatures[i].implementation =\n        compileArgsPreprocessing(signatures[i].params, signatures[i].fn)\n    }\n\n    const fn0 = ok0 ? signatures[0].implementation : undef\n    const fn1 = ok1 ? signatures[1].implementation : undef\n    const fn2 = ok2 ? signatures[2].implementation : undef\n    const fn3 = ok3 ? signatures[3].implementation : undef\n    const fn4 = ok4 ? signatures[4].implementation : undef\n    const fn5 = ok5 ? signatures[5].implementation : undef\n\n    const len0 = ok0 ? signatures[0].params.length : -1\n    const len1 = ok1 ? signatures[1].params.length : -1\n    const len2 = ok2 ? signatures[2].params.length : -1\n    const len3 = ok3 ? signatures[3].params.length : -1\n    const len4 = ok4 ? signatures[4].params.length : -1\n    const len5 = ok5 ? signatures[5].params.length : -1\n\n    // simple and generic, but also slow\n    const iStart = allOk ? 6 : 0\n    const iEnd = signatures.length\n    // de-reference ahead for execution speed:\n    const tests = signatures.map(s => s.test)\n    const fns = signatures.map(s => s.implementation)\n    const generic = function generic () {\n      'use strict'\n\n      for (let i = iStart; i < iEnd; i++) {\n        if (tests[i](arguments)) {\n          return fns[i].apply(this, arguments)\n        }\n      }\n\n      return typed.onMismatch(name, arguments, signatures)\n    }\n\n    // create the typed function\n    // fast, specialized version. Falls back to the slower, generic one if needed\n    function theTypedFn (arg0, arg1) {\n      'use strict'\n\n      if (arguments.length === len0 && test00(arg0) && test01(arg1)) { return fn0.apply(this, arguments) }\n      if (arguments.length === len1 && test10(arg0) && test11(arg1)) { return fn1.apply(this, arguments) }\n      if (arguments.length === len2 && test20(arg0) && test21(arg1)) { return fn2.apply(this, arguments) }\n      if (arguments.length === len3 && test30(arg0) && test31(arg1)) { return fn3.apply(this, arguments) }\n      if (arguments.length === len4 && test40(arg0) && test41(arg1)) { return fn4.apply(this, arguments) }\n      if (arguments.length === len5 && test50(arg0) && test51(arg1)) { return fn5.apply(this, arguments) }\n\n      return generic.apply(this, arguments)\n    }\n\n    // attach name the typed function\n    try {\n      Object.defineProperty(theTypedFn, 'name', { value: name })\n    } catch (err) {\n      // old browsers do not support Object.defineProperty and some don't support setting the name property\n      // the function name is not essential for the functioning, it's mostly useful for debugging,\n      // so it's fine to have unnamed functions.\n    }\n\n    // attach signatures to the function.\n    // This property is close to the original collection of signatures\n    // used to create the typed-function, just with unions split:\n    theTypedFn.signatures = signaturesMap\n\n    // Store internal data for functions like resolve, find, etc.\n    // Also serves as the flag that this is a typed-function\n    theTypedFn._typedFunctionData = {\n      signatures,\n      signatureMap: internalSignatureMap\n    }\n\n    return theTypedFn\n  }\n\n  /**\n   * Action to take on mismatch\n   * @param {string} name      Name of function that was attempted to be called\n   * @param {Array} args       Actual arguments to the call\n   * @param {Array} signatures Known signatures of the named typed-function\n   */\n  function _onMismatch (name, args, signatures) {\n    throw createError(name, args, signatures)\n  }\n\n  /**\n   * Return all but the last items of an array or function Arguments\n   * @param {Array | Arguments} arr\n   * @return {Array}\n   */\n  function initial (arr) {\n    return slice(arr, 0, arr.length - 1)\n  }\n\n  /**\n   * return the last item of an array or function Arguments\n   * @param {Array | Arguments} arr\n   * @return {*}\n   */\n  function last (arr) {\n    return arr[arr.length - 1]\n  }\n\n  /**\n   * Slice an array or function Arguments\n   * @param {Array | Arguments | IArguments} arr\n   * @param {number} start\n   * @param {number} [end]\n   * @return {Array}\n   */\n  function slice (arr, start, end) {\n    return Array.prototype.slice.call(arr, start, end)\n  }\n\n  /**\n   * Return the first item from an array for which test(arr[i]) returns true\n   * @param {Array} arr\n   * @param {function} test\n   * @return {* | undefined} Returns the first matching item\n   *                         or undefined when there is no match\n   */\n  function findInArray (arr, test) {\n    for (let i = 0; i < arr.length; i++) {\n      if (test(arr[i])) {\n        return arr[i]\n      }\n    }\n    return undefined\n  }\n\n  /**\n   * Flat map the result invoking a callback for every item in an array.\n   * https://gist.github.com/samgiles/762ee337dff48623e729\n   * @param {Array} arr\n   * @param {function} callback\n   * @return {Array}\n   */\n  function flatMap (arr, callback) {\n    return Array.prototype.concat.apply([], arr.map(callback))\n  }\n\n  /**\n   * Create a reference callback to one or multiple signatures\n   *\n   * Syntax:\n   *\n   *     typed.referTo(signature1, signature2, ..., function callback(fn1, fn2, ...) {\n   *       // ...\n   *     })\n   *\n   * @returns {{referTo: {references: string[], callback}}}\n   */\n  function referTo () {\n    const references =\n      initial(arguments).map(s => stringifyParams(parseSignature(s)))\n    const callback = last(arguments)\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback function expected as last argument')\n    }\n\n    return makeReferTo(references, callback)\n  }\n\n  function makeReferTo (references, callback) {\n    return { referTo: { references, callback } }\n  }\n\n  /**\n   * Create a reference callback to the typed-function itself\n   *\n   * @param {(self: function) => function} callback\n   * @returns {{referToSelf: { callback: function }}}\n   */\n  function referToSelf (callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback function expected as first argument')\n    }\n\n    return { referToSelf: { callback } }\n  }\n\n  /**\n   * Test whether something is a referTo object, holding a list with reference\n   * signatures and a callback.\n   *\n   * @param {Object | function} objectOrFn\n   * @returns {boolean}\n   */\n  function isReferTo (objectOrFn) {\n    return objectOrFn &&\n      typeof objectOrFn.referTo === 'object' &&\n      Array.isArray(objectOrFn.referTo.references) &&\n      typeof objectOrFn.referTo.callback === 'function'\n  }\n\n  /**\n   * Test whether something is a referToSelf object, holding a callback where\n   * to pass `self`.\n   *\n   * @param {Object | function} objectOrFn\n   * @returns {boolean}\n   */\n  function isReferToSelf (objectOrFn) {\n    return objectOrFn &&\n      typeof objectOrFn.referToSelf === 'object' &&\n      typeof objectOrFn.referToSelf.callback === 'function'\n  }\n\n  /**\n   * Check if name is (A) new, (B) a match, or (C) a mismatch; and throw\n   * an error in case (C).\n   *\n   * @param { string | undefined } nameSoFar\n   * @param { string | undefined } newName\n   * @returns { string } updated name\n   */\n  function checkName (nameSoFar, newName) {\n    if (!nameSoFar) {\n      return newName\n    }\n    if (newName && newName !== nameSoFar) {\n      const err = new Error('Function names do not match (expected: ' +\n        nameSoFar + ', actual: ' + newName + ')')\n      err.data = { actual: newName, expected: nameSoFar }\n      throw err\n    }\n    return nameSoFar\n  }\n\n  /**\n   * Retrieve the implied name from an object with signature keys\n   * and function values, checking whether all value names match\n   *\n   * @param { {string: function} } obj\n   */\n  function getObjectName (obj) {\n    let name\n    for (const key in obj) {\n      // Only pay attention to own properties, and only if their values\n      // are typed functions or functions with a signature property\n      if (Object.prototype.hasOwnProperty.call(obj, key) &&\n        (isTypedFunction(obj[key]) ||\n          typeof obj[key].signature === 'string')) {\n        name = checkName(name, obj[key].name)\n      }\n    }\n    return name\n  }\n\n  /**\n   * Copy all of the signatures from the second argument into the first,\n   * which is modified by side effect, checking for conflicts\n   *\n   * @param {Object.<string, function|typed-reference>} dest\n   * @param {Object.<string, function|typed-reference>} source\n   */\n  function mergeSignatures (dest, source) {\n    let key\n    for (key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        if (key in dest) {\n          if (source[key] !== dest[key]) {\n            const err = new Error('Signature \"' + key + '\" is defined twice')\n            err.data = {\n              signature: key,\n              sourceFunction: source[key],\n              destFunction: dest[key]\n            }\n            throw err\n          }\n          // else: both signatures point to the same function, that's fine\n        }\n        dest[key] = source[key]\n      }\n    }\n  }\n\n  const saveTyped = typed\n\n  /**\n   * Originally the main function was a typed function itself, but then\n   * it might not be able to generate error messages if the client\n   * replaced the type system with different names.\n   *\n   * Main entry: typed([name], functions/objects with signatures...)\n   *\n   * Assembles and returns a new typed-function from the given items\n   * that provide signatures and implementations, each of which may be\n   * * a plain object mapping (string) signatures to implementing functions,\n   * * a previously constructed typed function, or\n   * * any other single function with a string-valued property `signature`.\n\n   * The name of the resulting typed-function will be given by the\n   * string-valued name argument if present, or if not, by the name\n   * of any of the arguments that have one, as long as any that do are\n   * consistent with each other. If no name is specified, the name will be\n   * an empty string.\n   *\n   * @param {string} maybeName [optional]\n   * @param {(function|object)[]} signature providers\n   * @returns {typed-function}\n   */\n  typed = function (maybeName) {\n    const named = typeof maybeName === 'string'\n    const start = named ? 1 : 0\n    let name = named ? maybeName : ''\n    const allSignatures = {}\n    for (let i = start; i < arguments.length; ++i) {\n      const item = arguments[i]\n      let theseSignatures = {}\n      let thisName\n      if (typeof item === 'function') {\n        thisName = item.name\n        if (typeof item.signature === 'string') {\n          // Case 1: Ordinary function with a string 'signature' property\n          theseSignatures[item.signature] = item\n        } else if (isTypedFunction(item)) {\n          // Case 2: Existing typed function\n          theseSignatures = item.signatures\n        }\n      } else if (isPlainObject(item)) {\n        // Case 3: Plain object, assume keys = signatures, values = functions\n        theseSignatures = item\n        if (!named) {\n          thisName = getObjectName(item)\n        }\n      }\n\n      if (Object.keys(theseSignatures).length === 0) {\n        const err = new TypeError(\n          'Argument to \\'typed\\' at index ' + i + ' is not a (typed) function, ' +\n          'nor an object with signatures as keys and functions as values.')\n        err.data = { index: i, argument: item }\n        throw err\n      }\n\n      if (!named) {\n        name = checkName(name, thisName)\n      }\n      mergeSignatures(allSignatures, theseSignatures)\n    }\n\n    return createTypedFunction(name || '', allSignatures)\n  }\n\n  typed.create = create\n  typed.createCount = saveTyped.createCount\n  typed.onMismatch = _onMismatch\n  typed.throwMismatchError = _onMismatch\n  typed.createError = createError\n  typed.clear = clear\n  typed.clearConversions = clearConversions\n  typed.addTypes = addTypes\n  typed._findType = findType // For unit testing only\n  typed.referTo = referTo\n  typed.referToSelf = referToSelf\n  typed.convert = convert\n  typed.findSignature = findSignature\n  typed.find = find\n  typed.isTypedFunction = isTypedFunction\n  typed.warnAgainstDeprecatedThis = true\n\n  /**\n   * add a type (convenience wrapper for typed.addTypes)\n   * @param {{name: string, test: function}} type\n   * @param {boolean} [beforeObjectTest=true]\n   *                          If true, the new test will be inserted before\n   *                          the test with name 'Object' (if any), since\n   *                          tests for Object match Array and classes too.\n   */\n  typed.addType = function (type, beforeObjectTest) {\n    let before = 'any'\n    if (beforeObjectTest !== false && typeMap.has('Object')) {\n      before = 'Object'\n    }\n    typed.addTypes([type], before)\n  }\n\n  /**\n   * Verify that the ConversionDef conversion has a valid format.\n   *\n   * @param {conversionDef} conversion\n   * @return {void}\n   * @throws {TypeError|SyntaxError}\n   */\n  function _validateConversion (conversion) {\n    if (!conversion ||\n      typeof conversion.from !== 'string' ||\n      typeof conversion.to !== 'string' ||\n      typeof conversion.convert !== 'function') {\n      throw new TypeError('Object with properties {from: string, to: string, convert: function} expected')\n    }\n    if (conversion.to === conversion.from) {\n      throw new SyntaxError(\n        'Illegal to define conversion from \"' + conversion.from +\n        '\" to itself.')\n    }\n  }\n\n  /**\n   * Add a conversion\n   *\n   * @param {ConversionDef} conversion\n   * @param {{override: boolean}} [options]\n   * @returns {void}\n   * @throws {TypeError}\n   */\n  typed.addConversion = function (conversion, options = { override: false }) {\n    _validateConversion(conversion)\n\n    const to = findType(conversion.to)\n    const existing = to.conversionsTo.find((other) => other.from === conversion.from)\n\n    if (existing) {\n      if (options && options.override) {\n        typed.removeConversion({ from: existing.from, to: conversion.to, convert: existing.convert })\n      } else {\n        throw new Error(\n          'There is already a conversion from \"' + conversion.from + '\" to \"' +\n          to.name + '\"')\n      }\n    }\n\n    to.conversionsTo.push({\n      from: conversion.from,\n      to: to.name,\n      convert: conversion.convert,\n      index: nConversions++\n    })\n  }\n\n  /**\n   * Convenience wrapper to call addConversion on each conversion in a list.\n   *\n   * @param {ConversionDef[]} conversions\n   * @param {{override: boolean}} [options]\n   * @returns {void}\n   * @throws {TypeError}\n   */\n  typed.addConversions = function (conversions, options) {\n    conversions.forEach(conversion => typed.addConversion(conversion, options))\n  }\n\n  /**\n   * Remove the specified conversion. The format is the same as for\n   * addConversion, and the convert function must match or an error\n   * is thrown.\n   *\n   * @param {{from: string, to: string, convert: function}} conversion\n   * @returns {void}\n   * @throws {TypeError|SyntaxError|Error}\n   */\n  typed.removeConversion = function (conversion) {\n    _validateConversion(conversion)\n    const to = findType(conversion.to)\n    const existingConversion =\n      findInArray(to.conversionsTo, c => (c.from === conversion.from))\n    if (!existingConversion) {\n      throw new Error(\n        'Attempt to remove nonexistent conversion from ' + conversion.from +\n        ' to ' + conversion.to)\n    }\n    if (existingConversion.convert !== conversion.convert) {\n      throw new Error(\n        'Conversion to remove does not match existing conversion')\n    }\n    const index = to.conversionsTo.indexOf(existingConversion)\n    to.conversionsTo.splice(index, 1)\n  }\n\n  /**\n   * Produce the specific signature that a typed function\n   * will execute on the given arguments. Here, a \"signature\" is an\n   * object with properties 'params', 'test', 'fn', and 'implementation'.\n   * This last property is a function that converts params as necessary\n   * and then calls 'fn'. Returns null if there is no matching signature.\n   * @param {typed-function} tf\n   * @param {any[]} argList\n   * @returns {{params: string, test: function, fn: function, implementation: function}}\n   */\n  typed.resolve = function (tf, argList) {\n    if (!isTypedFunction(tf)) {\n      throw new TypeError(NOT_TYPED_FUNCTION)\n    }\n    const sigs = tf._typedFunctionData.signatures\n    for (let i = 0; i < sigs.length; ++i) {\n      if (sigs[i].test(argList)) {\n        return sigs[i]\n      }\n    }\n    return null\n  }\n\n  return typed\n}\n\nexport default create()\n"],"mappings":"AAAA,SAASA,EAAEA,CAAA,EAAI;EACb,OAAO,IAAI;AACb;AAEA,SAASC,KAAKA,CAAA,EAAI;EAChB,OAAO,KAAK;AACd;AAEA,SAASC,KAAKA,CAAA,EAAI;EAChB,OAAOC,SAAS;AAClB;AAEA,MAAMC,kBAAkB,GAAG,mCAAmC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAASC,MAAMA,CAAA,EAAI;EACjB;;EAEA;AACF;AACA;EACE,SAASC,aAAaA,CAAEC,CAAC,EAAE;IACzB,OAAO,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,IAAI,IAAIA,CAAC,CAACC,WAAW,KAAKC,MAAM;EACxE;EAEA,MAAMC,MAAM,GAAG,CACb;IAAEC,IAAI,EAAE,QAAQ;IAAEC,IAAI,EAAE,SAAAA,CAAUL,CAAC,EAAE;MAAE,OAAO,OAAOA,CAAC,KAAK,QAAQ;IAAC;EAAE,CAAC,EACvE;IAAEI,IAAI,EAAE,QAAQ;IAAEC,IAAI,EAAE,SAAAA,CAAUL,CAAC,EAAE;MAAE,OAAO,OAAOA,CAAC,KAAK,QAAQ;IAAC;EAAE,CAAC,EACvE;IAAEI,IAAI,EAAE,SAAS;IAAEC,IAAI,EAAE,SAAAA,CAAUL,CAAC,EAAE;MAAE,OAAO,OAAOA,CAAC,KAAK,SAAS;IAAC;EAAE,CAAC,EACzE;IAAEI,IAAI,EAAE,UAAU;IAAEC,IAAI,EAAE,SAAAA,CAAUL,CAAC,EAAE;MAAE,OAAO,OAAOA,CAAC,KAAK,UAAU;IAAC;EAAE,CAAC,EAC3E;IAAEI,IAAI,EAAE,OAAO;IAAEC,IAAI,EAAEC,KAAK,CAACC;EAAQ,CAAC,EACtC;IAAEH,IAAI,EAAE,MAAM;IAAEC,IAAI,EAAE,SAAAA,CAAUL,CAAC,EAAE;MAAE,OAAOA,CAAC,YAAYQ,IAAI;IAAC;EAAE,CAAC,EACjE;IAAEJ,IAAI,EAAE,QAAQ;IAAEC,IAAI,EAAE,SAAAA,CAAUL,CAAC,EAAE;MAAE,OAAOA,CAAC,YAAYS,MAAM;IAAC;EAAE,CAAC,EACrE;IAAEL,IAAI,EAAE,QAAQ;IAAEC,IAAI,EAAEN;EAAc,CAAC,EACvC;IAAEK,IAAI,EAAE,MAAM;IAAEC,IAAI,EAAE,SAAAA,CAAUL,CAAC,EAAE;MAAE,OAAOA,CAAC,KAAK,IAAI;IAAC;EAAE,CAAC,EAC1D;IAAEI,IAAI,EAAE,WAAW;IAAEC,IAAI,EAAE,SAAAA,CAAUL,CAAC,EAAE;MAAE,OAAOA,CAAC,KAAKJ,SAAS;IAAC;EAAE,CAAC,CACrE;EAED,MAAMc,OAAO,GAAG;IACdN,IAAI,EAAE,KAAK;IACXC,IAAI,EAAEZ,EAAE;IACRkB,KAAK,EAAE;EACT,CAAC;;EAED;EACA;EACA;EACA;EACA;EACA,IAAIC,OAAO,EAAC;EACZ,IAAIC,QAAQ,EAAC;;EAEb;EACA,IAAIC,YAAY,GAAG,CAAC;EACpB;;EAEA;EACA,IAAIC,KAAK,GAAG;IAAEC,WAAW,EAAE;EAAE,CAAC;;EAE9B;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,QAAQA,CAAEC,QAAQ,EAAE;IAC3B,MAAMC,IAAI,GAAGP,OAAO,CAACQ,GAAG,CAACF,QAAQ,CAAC;IAClC,IAAIC,IAAI,EAAE;MACR,OAAOA,IAAI;IACb;IACA;IACA,IAAIE,OAAO,GAAG,gBAAgB,GAAGH,QAAQ,GAAG,GAAG;IAC/C,MAAMd,IAAI,GAAGc,QAAQ,CAACI,WAAW,CAAC,CAAC;IACnC,IAAIC,SAAS;IACb,KAAKA,SAAS,IAAIV,QAAQ,EAAE;MAC1B,IAAIU,SAAS,CAACD,WAAW,CAAC,CAAC,KAAKlB,IAAI,EAAE;QACpCiB,OAAO,IAAI,kBAAkB,GAAGE,SAAS,GAAG,KAAK;QACjD;MACF;IACF;IACA,MAAM,IAAIC,SAAS,CAACH,OAAO,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASI,QAAQA,CAAEC,KAAK,EAAsB;IAAA,IAApBC,UAAU,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhC,SAAA,GAAAgC,SAAA,MAAG,KAAK;IAC1C,MAAME,WAAW,GAAGH,UAAU,GAC1BV,QAAQ,CAACU,UAAU,CAAC,CAACI,KAAK,GAC1BlB,QAAQ,CAACgB,MAAM;IACnB,MAAMG,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACG,MAAM,EAAE,EAAEI,CAAC,EAAE;MACrC,IAAI,CAACP,KAAK,CAACO,CAAC,CAAC,IAAI,OAAOP,KAAK,CAACO,CAAC,CAAC,CAAC7B,IAAI,KAAK,QAAQ,IAChD,OAAOsB,KAAK,CAACO,CAAC,CAAC,CAAC5B,IAAI,KAAK,UAAU,EAAE;QACrC,MAAM,IAAImB,SAAS,CAAC,gEAAgE,CAAC;MACvF;MACA,MAAMN,QAAQ,GAAGQ,KAAK,CAACO,CAAC,CAAC,CAAC7B,IAAI;MAC9B,IAAIQ,OAAO,CAACsB,GAAG,CAAChB,QAAQ,CAAC,EAAE;QACzB,MAAM,IAAIM,SAAS,CAAC,uBAAuB,GAAGN,QAAQ,GAAG,GAAG,CAAC;MAC/D;MACAc,QAAQ,CAACG,IAAI,CAACjB,QAAQ,CAAC;MACvBN,OAAO,CAACwB,GAAG,CAAClB,QAAQ,EAAE;QACpBd,IAAI,EAAEc,QAAQ;QACdb,IAAI,EAAEqB,KAAK,CAACO,CAAC,CAAC,CAAC5B,IAAI;QACnBM,KAAK,EAAEe,KAAK,CAACO,CAAC,CAAC,CAACtB,KAAK;QACrBoB,KAAK,EAAED,WAAW,GAAGG,CAAC;QACtBI,aAAa,EAAE,EAAE,CAAC;MACpB,CAAC,CAAC;IACJ;IACA;IACA,MAAMC,aAAa,GAAGzB,QAAQ,CAAC0B,KAAK,CAACT,WAAW,CAAC;IACjDjB,QAAQ,GACNA,QAAQ,CAAC0B,KAAK,CAAC,CAAC,EAAET,WAAW,CAAC,CAACU,MAAM,CAACR,QAAQ,CAAC,CAACQ,MAAM,CAACF,aAAa,CAAC;IACvE;IACA,KAAK,IAAIL,CAAC,GAAGH,WAAW,GAAGE,QAAQ,CAACH,MAAM,EAAEI,CAAC,GAAGpB,QAAQ,CAACgB,MAAM,EAAE,EAAEI,CAAC,EAAE;MACpErB,OAAO,CAACQ,GAAG,CAACP,QAAQ,CAACoB,CAAC,CAAC,CAAC,CAACF,KAAK,GAAGE,CAAC;IACpC;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASQ,KAAKA,CAAA,EAAI;IAChB7B,OAAO,GAAG,IAAI8B,GAAG,CAAC,CAAC;IACnB7B,QAAQ,GAAG,EAAE;IACbC,YAAY,GAAG,CAAC;IAChBW,QAAQ,CAAC,CAACf,OAAO,CAAC,EAAE,KAAK,CAAC;EAC5B;;EAEA;EACA+B,KAAK,CAAC,CAAC;EACPhB,QAAQ,CAACtB,MAAM,CAAC;;EAEhB;AACF;AACA;EACE,SAASwC,gBAAgBA,CAAA,EAAI;IAC3B,IAAIzB,QAAQ;IACZ,KAAKA,QAAQ,IAAIL,QAAQ,EAAE;MACzBD,OAAO,CAACQ,GAAG,CAACF,QAAQ,CAAC,CAACmB,aAAa,GAAG,EAAE;IAC1C;IACAvB,YAAY,GAAG,CAAC;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAAS8B,aAAaA,CAAEC,KAAK,EAAE;IAC7B,MAAMC,OAAO,GAAGjC,QAAQ,CAACkC,MAAM,CAAC3C,IAAI,IAAI;MACtC,MAAMe,IAAI,GAAGP,OAAO,CAACQ,GAAG,CAAChB,IAAI,CAAC;MAC9B,OAAO,CAACe,IAAI,CAACR,KAAK,IAAIQ,IAAI,CAACd,IAAI,CAACwC,KAAK,CAAC;IACxC,CAAC,CAAC;IACF,IAAIC,OAAO,CAACjB,MAAM,EAAE;MAClB,OAAOiB,OAAO;IAChB;IACA,OAAO,CAAC,KAAK,CAAC;EAChB;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASE,eAAeA,CAAEC,MAAM,EAAE;IAChC,OAAOA,MAAM,IAAI,OAAOA,MAAM,KAAK,UAAU,IAC3C,oBAAoB,IAAIA,MAAM;EAClC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,aAAaA,CAAEC,EAAE,EAAEC,SAAS,EAAEC,OAAO,EAAE;IAC9C,IAAI,CAACL,eAAe,CAACG,EAAE,CAAC,EAAE;MACxB,MAAM,IAAI3B,SAAS,CAAC3B,kBAAkB,CAAC;IACzC;;IAEA;IACA,MAAMyD,KAAK,GAAGD,OAAO,IAAIA,OAAO,CAACC,KAAK;IACtC,MAAMC,eAAe,GAAGjD,KAAK,CAACC,OAAO,CAAC6C,SAAS,CAAC,GAC5CA,SAAS,CAACI,IAAI,CAAC,GAAG,CAAC,GACnBJ,SAAS;IACb,MAAMK,MAAM,GAAGC,cAAc,CAACH,eAAe,CAAC;IAC9C,MAAMI,kBAAkB,GAAGC,eAAe,CAACH,MAAM,CAAC;;IAElD;IACA,IAAI,CAACH,KAAK,IAAIK,kBAAkB,IAAIR,EAAE,CAACU,UAAU,EAAE;MACjD;MACA,MAAMC,KAAK,GACTX,EAAE,CAACY,kBAAkB,CAACC,YAAY,CAAC5C,GAAG,CAACuC,kBAAkB,CAAC;MAC5D,IAAIG,KAAK,EAAE;QACT,OAAOA,KAAK;MACd;IACF;;IAEA;IACA;IACA;IACA;IACA,MAAMG,OAAO,GAAGR,MAAM,CAAC5B,MAAM;IAC7B,IAAIqC,mBAAmB;IACvB,IAAIZ,KAAK,EAAE;MACTY,mBAAmB,GAAG,EAAE;MACxB,IAAI9D,IAAI;MACR,KAAKA,IAAI,IAAI+C,EAAE,CAACU,UAAU,EAAE;QAC1BK,mBAAmB,CAAC/B,IAAI,CAACgB,EAAE,CAACY,kBAAkB,CAACC,YAAY,CAAC5C,GAAG,CAAChB,IAAI,CAAC,CAAC;MACxE;IACF,CAAC,MAAM;MACL8D,mBAAmB,GAAGf,EAAE,CAACY,kBAAkB,CAACF,UAAU;IACxD;IACA,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgC,OAAO,EAAE,EAAEhC,CAAC,EAAE;MAChC,MAAMkC,IAAI,GAAGV,MAAM,CAACxB,CAAC,CAAC;MACtB,MAAMmC,kBAAkB,GAAG,EAAE;MAC7B,IAAIC,WAAW;MACf,KAAKA,WAAW,IAAIH,mBAAmB,EAAE;QACvC,MAAMI,IAAI,GAAGC,eAAe,CAACF,WAAW,CAACZ,MAAM,EAAExB,CAAC,CAAC;QACnD,IAAI,CAACqC,IAAI,IAAKH,IAAI,CAACK,SAAS,IAAI,CAACF,IAAI,CAACE,SAAU,EAAE;UAChD;QACF;QACA,IAAI,CAACF,IAAI,CAACG,MAAM,EAAE;UAChB;UACA,MAAMC,SAAS,GAAGC,YAAY,CAACL,IAAI,CAAC;UACpC,IAAIH,IAAI,CAACzC,KAAK,CAACkD,IAAI,CAACC,KAAK,IAAI,CAACH,SAAS,CAACxC,GAAG,CAAC2C,KAAK,CAACzE,IAAI,CAAC,CAAC,EAAE;YACxD;UACF;QACF;QACA;QACAgE,kBAAkB,CAACjC,IAAI,CAACkC,WAAW,CAAC;MACtC;MACAH,mBAAmB,GAAGE,kBAAkB;MACxC,IAAIF,mBAAmB,CAACrC,MAAM,KAAK,CAAC,EAAE;IACxC;IACA;IACA,IAAIiD,SAAS;IACb,KAAKA,SAAS,IAAIZ,mBAAmB,EAAE;MACrC,IAAIY,SAAS,CAACrB,MAAM,CAAC5B,MAAM,IAAIoC,OAAO,EAAE;QACtC,OAAOa,SAAS;MAClB;IACF;IAEA,MAAM,IAAItD,SAAS,CAAC,kCAAkC,IAAI2B,EAAE,CAAC/C,IAAI,IAAI,SAAS,CAAC,GAAG,GAAG,GAAGwD,eAAe,CAACH,MAAM,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC;EAC/H;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASsB,IAAIA,CAAE5B,EAAE,EAAEC,SAAS,EAAEC,OAAO,EAAE;IACrC,OAAOH,aAAa,CAACC,EAAE,EAAEC,SAAS,EAAEC,OAAO,CAAC,CAAC2B,cAAc;EAC7D;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASC,OAAOA,CAAEpC,KAAK,EAAE3B,QAAQ,EAAE;IACjC;IACA,MAAMC,IAAI,GAAGF,QAAQ,CAACC,QAAQ,CAAC;IAC/B,IAAIC,IAAI,CAACd,IAAI,CAACwC,KAAK,CAAC,EAAE;MACpB,OAAOA,KAAK;IACd;IACA,MAAMqC,WAAW,GAAG/D,IAAI,CAACkB,aAAa;IACtC,IAAI6C,WAAW,CAACrD,MAAM,KAAK,CAAC,EAAE;MAC5B,MAAM,IAAIsD,KAAK,CACb,8BAA8B,GAAGjE,QAAQ,GAAG,WAAW,CAAC;IAC5D;IACA,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiD,WAAW,CAACrD,MAAM,EAAEI,CAAC,EAAE,EAAE;MAC3C,MAAMmD,QAAQ,GAAGnE,QAAQ,CAACiE,WAAW,CAACjD,CAAC,CAAC,CAACoD,IAAI,CAAC;MAC9C,IAAID,QAAQ,CAAC/E,IAAI,CAACwC,KAAK,CAAC,EAAE;QACxB,OAAOqC,WAAW,CAACjD,CAAC,CAAC,CAACgD,OAAO,CAACpC,KAAK,CAAC;MACtC;IACF;IAEA,MAAM,IAAIsC,KAAK,CAAC,iBAAiB,GAAGtC,KAAK,GAAG,MAAM,GAAG3B,QAAQ,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAAS0C,eAAeA,CAAEH,MAAM,EAAmB;IAAA,IAAjB6B,SAAS,GAAA1D,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhC,SAAA,GAAAgC,SAAA,MAAG,GAAG;IAC/C,OAAO6B,MAAM,CAAC8B,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACpF,IAAI,CAAC,CAACoD,IAAI,CAAC8B,SAAS,CAAC;EAChD;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASG,UAAUA,CAAEC,KAAK,EAAE;IAC1B,MAAMlB,SAAS,GAAGkB,KAAK,CAACC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC;IAC5C,MAAMjE,KAAK,GAAI,CAAC8C,SAAS,GACrBkB,KAAK,GACJA,KAAK,CAAC7D,MAAM,GAAG,CAAC,GACb6D,KAAK,CAACnD,KAAK,CAAC,CAAC,CAAC,GACd,KAAK;IAEb,MAAMqD,QAAQ,GAAGlE,KAAK,CAACmE,KAAK,CAAC,GAAG,CAAC,CAACN,GAAG,CAACO,CAAC,IAAI7E,QAAQ,CAAC6E,CAAC,CAACC,IAAI,CAAC,CAAC,CAAC,CAAC;IAE9D,IAAItB,MAAM,GAAG,KAAK;IAClB,IAAIuB,SAAS,GAAGxB,SAAS,GAAG,KAAK,GAAG,EAAE;IAEtC,MAAMyB,UAAU,GAAGL,QAAQ,CAACL,GAAG,CAAC,UAAUpE,IAAI,EAAE;MAC9CsD,MAAM,GAAGtD,IAAI,CAACR,KAAK,IAAI8D,MAAM;MAC7BuB,SAAS,IAAI7E,IAAI,CAACf,IAAI,GAAG,GAAG;MAE5B,OAAO;QACLA,IAAI,EAAEe,IAAI,CAACf,IAAI;QACf8F,SAAS,EAAE/E,IAAI,CAACY,KAAK;QACrB1B,IAAI,EAAEc,IAAI,CAACd,IAAI;QACfM,KAAK,EAAEQ,IAAI,CAACR,KAAK;QACjBwF,UAAU,EAAE,IAAI;QAChBC,eAAe,EAAE,CAAC;MACpB,CAAC;IACH,CAAC,CAAC;IAEF,OAAO;MACL1E,KAAK,EAAEuE,UAAU;MACjB7F,IAAI,EAAE4F,SAAS,CAACzD,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAAE;MAC9BkC,MAAM;MACN4B,aAAa,EAAE,KAAK;MACpB7B;IACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAAS8B,WAAWA,CAAEZ,KAAK,EAAE;IAC3B,MAAMa,SAAS,GAAGb,KAAK,CAAChE,KAAK,CAAC6D,GAAG,CAACiB,CAAC,IAAIA,CAAC,CAACpG,IAAI,CAAC;IAC9C,MAAMqG,mBAAmB,GAAGC,oBAAoB,CAACH,SAAS,CAAC;IAC3D,IAAI9B,MAAM,GAAGiB,KAAK,CAACjB,MAAM;IACzB,IAAIkC,OAAO,GAAGjB,KAAK,CAACtF,IAAI;IAExB,MAAMwG,gBAAgB,GAAGH,mBAAmB,CAAClB,GAAG,CAAC,UAAUY,UAAU,EAAE;MACrE,MAAMhF,IAAI,GAAGF,QAAQ,CAACkF,UAAU,CAACd,IAAI,CAAC;MACtCZ,MAAM,GAAGtD,IAAI,CAACR,KAAK,IAAI8D,MAAM;MAC7BkC,OAAO,IAAI,GAAG,GAAGR,UAAU,CAACd,IAAI;MAEhC,OAAO;QACLjF,IAAI,EAAE+F,UAAU,CAACd,IAAI;QACrBa,SAAS,EAAE/E,IAAI,CAACY,KAAK;QACrB1B,IAAI,EAAEc,IAAI,CAACd,IAAI;QACfM,KAAK,EAAEQ,IAAI,CAACR,KAAK;QACjBwF,UAAU;QACVC,eAAe,EAAED,UAAU,CAACpE;MAC9B,CAAC;IACH,CAAC,CAAC;IAEF,OAAO;MACLL,KAAK,EAAEgE,KAAK,CAAChE,KAAK,CAACc,MAAM,CAACoE,gBAAgB,CAAC;MAC3CxG,IAAI,EAAEuG,OAAO;MACblC,MAAM;MACN4B,aAAa,EAAEO,gBAAgB,CAAC/E,MAAM,GAAG,CAAC;MAC1C2C,SAAS,EAAEkB,KAAK,CAAClB;IACnB,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASG,YAAYA,CAAEe,KAAK,EAAE;IAC5B,IAAI,CAACA,KAAK,CAACmB,OAAO,EAAE;MAClBnB,KAAK,CAACmB,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;MACzBpB,KAAK,CAAChE,KAAK,CAACqF,OAAO,CAAC5F,IAAI,IAAIuE,KAAK,CAACmB,OAAO,CAACG,GAAG,CAAC7F,IAAI,CAACf,IAAI,CAAC,CAAC;IAC3D;IACA,OAAOsF,KAAK,CAACmB,OAAO;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASnD,cAAcA,CAAEuD,YAAY,EAAE;IACrC,MAAMxD,MAAM,GAAG,EAAE;IACjB,IAAI,OAAOwD,YAAY,KAAK,QAAQ,EAAE;MACpC,MAAM,IAAIzF,SAAS,CAAC,4BAA4B,CAAC;IACnD;IACA,MAAM4B,SAAS,GAAG6D,YAAY,CAAClB,IAAI,CAAC,CAAC;IACrC,IAAI3C,SAAS,KAAK,EAAE,EAAE;MACpB,OAAOK,MAAM;IACf;IAEA,MAAMyD,SAAS,GAAG9D,SAAS,CAACyC,KAAK,CAAC,GAAG,CAAC;IACtC,KAAK,IAAI5D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiF,SAAS,CAACrF,MAAM,EAAE,EAAEI,CAAC,EAAE;MACzC,MAAMkF,WAAW,GAAG1B,UAAU,CAACyB,SAAS,CAACjF,CAAC,CAAC,CAAC8D,IAAI,CAAC,CAAC,CAAC;MACnD,IAAIoB,WAAW,CAAC3C,SAAS,IAAKvC,CAAC,KAAKiF,SAAS,CAACrF,MAAM,GAAG,CAAE,EAAE;QACzD,MAAM,IAAIuF,WAAW,CACnB,6BAA6B,GAAGF,SAAS,CAACjF,CAAC,CAAC,GAAG,KAAK,GACpD,qCAAqC,CAAC;MAC1C;MACA;MACA,IAAIkF,WAAW,CAACzF,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;QAClC,OAAO,IAAI;MACb;MACA4B,MAAM,CAACtB,IAAI,CAACgF,WAAW,CAAC;IAC1B;IAEA,OAAO1D,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;EACE,SAAS4D,YAAYA,CAAE5D,MAAM,EAAE;IAC7B,MAAMiC,KAAK,GAAG4B,IAAI,CAAC7D,MAAM,CAAC;IAC1B,OAAOiC,KAAK,GAAGA,KAAK,CAAClB,SAAS,GAAG,KAAK;EACxC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAAS+C,WAAWA,CAAE7B,KAAK,EAAE;IAC3B,IAAI,CAACA,KAAK,IAAIA,KAAK,CAAChE,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;MACtC;MACA,OAAOpC,EAAE;IACX,CAAC,MAAM,IAAIiG,KAAK,CAAChE,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;MACnC,OAAOZ,QAAQ,CAACyE,KAAK,CAAChE,KAAK,CAAC,CAAC,CAAC,CAACtB,IAAI,CAAC,CAACC,IAAI;IAC3C,CAAC,MAAM,IAAIqF,KAAK,CAAChE,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;MACnC,MAAM2F,KAAK,GAAGvG,QAAQ,CAACyE,KAAK,CAAChE,KAAK,CAAC,CAAC,CAAC,CAACtB,IAAI,CAAC,CAACC,IAAI;MAChD,MAAMoH,KAAK,GAAGxG,QAAQ,CAACyE,KAAK,CAAChE,KAAK,CAAC,CAAC,CAAC,CAACtB,IAAI,CAAC,CAACC,IAAI;MAChD,OAAO,SAASqH,EAAEA,CAAE1H,CAAC,EAAE;QACrB,OAAOwH,KAAK,CAACxH,CAAC,CAAC,IAAIyH,KAAK,CAACzH,CAAC,CAAC;MAC7B,CAAC;IACH,CAAC,MAAM;MAAE;MACP,MAAM2H,KAAK,GAAGjC,KAAK,CAAChE,KAAK,CAAC6D,GAAG,CAAC,UAAUpE,IAAI,EAAE;QAC5C,OAAOF,QAAQ,CAACE,IAAI,CAACf,IAAI,CAAC,CAACC,IAAI;MACjC,CAAC,CAAC;MACF,OAAO,SAASqH,EAAEA,CAAE1H,CAAC,EAAE;QACrB,KAAK,IAAIiC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0F,KAAK,CAAC9F,MAAM,EAAEI,CAAC,EAAE,EAAE;UACrC,IAAI0F,KAAK,CAAC1F,CAAC,CAAC,CAACjC,CAAC,CAAC,EAAE;YACf,OAAO,IAAI;UACb;QACF;QACA,OAAO,KAAK;MACd,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE,SAAS4H,YAAYA,CAAEnE,MAAM,EAAE;IAC7B,IAAIkE,KAAK,EAAEH,KAAK,EAAEC,KAAK;IAEvB,IAAIJ,YAAY,CAAC5D,MAAM,CAAC,EAAE;MACxB;MACAkE,KAAK,GAAGE,OAAO,CAACpE,MAAM,CAAC,CAAC8B,GAAG,CAACgC,WAAW,CAAC;MACxC,MAAMO,QAAQ,GAAGH,KAAK,CAAC9F,MAAM;MAC7B,MAAMkG,QAAQ,GAAGR,WAAW,CAACD,IAAI,CAAC7D,MAAM,CAAC,CAAC;MAC1C,MAAMuE,aAAa,GAAG,SAAAA,CAAUC,IAAI,EAAE;QACpC,KAAK,IAAIhG,CAAC,GAAG6F,QAAQ,EAAE7F,CAAC,GAAGgG,IAAI,CAACpG,MAAM,EAAEI,CAAC,EAAE,EAAE;UAC3C,IAAI,CAAC8F,QAAQ,CAACE,IAAI,CAAChG,CAAC,CAAC,CAAC,EAAE;YACtB,OAAO,KAAK;UACd;QACF;QACA,OAAO,IAAI;MACb,CAAC;MAED,OAAO,SAASiG,QAAQA,CAAED,IAAI,EAAE;QAC9B,KAAK,IAAIhG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0F,KAAK,CAAC9F,MAAM,EAAEI,CAAC,EAAE,EAAE;UACrC,IAAI,CAAC0F,KAAK,CAAC1F,CAAC,CAAC,CAACgG,IAAI,CAAChG,CAAC,CAAC,CAAC,EAAE;YACtB,OAAO,KAAK;UACd;QACF;QACA,OAAO+F,aAAa,CAACC,IAAI,CAAC,IAAKA,IAAI,CAACpG,MAAM,IAAIiG,QAAQ,GAAG,CAAE;MAC7D,CAAC;IACH,CAAC,MAAM;MACL;MACA,IAAIrE,MAAM,CAAC5B,MAAM,KAAK,CAAC,EAAE;QACvB,OAAO,SAASqG,QAAQA,CAAED,IAAI,EAAE;UAC9B,OAAOA,IAAI,CAACpG,MAAM,KAAK,CAAC;QAC1B,CAAC;MACH,CAAC,MAAM,IAAI4B,MAAM,CAAC5B,MAAM,KAAK,CAAC,EAAE;QAC9B2F,KAAK,GAAGD,WAAW,CAAC9D,MAAM,CAAC,CAAC,CAAC,CAAC;QAC9B,OAAO,SAASyE,QAAQA,CAAED,IAAI,EAAE;UAC9B,OAAOT,KAAK,CAACS,IAAI,CAAC,CAAC,CAAC,CAAC,IAAIA,IAAI,CAACpG,MAAM,KAAK,CAAC;QAC5C,CAAC;MACH,CAAC,MAAM,IAAI4B,MAAM,CAAC5B,MAAM,KAAK,CAAC,EAAE;QAC9B2F,KAAK,GAAGD,WAAW,CAAC9D,MAAM,CAAC,CAAC,CAAC,CAAC;QAC9BgE,KAAK,GAAGF,WAAW,CAAC9D,MAAM,CAAC,CAAC,CAAC,CAAC;QAC9B,OAAO,SAASyE,QAAQA,CAAED,IAAI,EAAE;UAC9B,OAAOT,KAAK,CAACS,IAAI,CAAC,CAAC,CAAC,CAAC,IAAIR,KAAK,CAACQ,IAAI,CAAC,CAAC,CAAC,CAAC,IAAIA,IAAI,CAACpG,MAAM,KAAK,CAAC;QAC9D,CAAC;MACH,CAAC,MAAM;QAAE;QACP8F,KAAK,GAAGlE,MAAM,CAAC8B,GAAG,CAACgC,WAAW,CAAC;QAC/B,OAAO,SAASW,QAAQA,CAAED,IAAI,EAAE;UAC9B,KAAK,IAAIhG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0F,KAAK,CAAC9F,MAAM,EAAEI,CAAC,EAAE,EAAE;YACrC,IAAI,CAAC0F,KAAK,CAAC1F,CAAC,CAAC,CAACgG,IAAI,CAAChG,CAAC,CAAC,CAAC,EAAE;cACtB,OAAO,KAAK;YACd;UACF;UACA,OAAOgG,IAAI,CAACpG,MAAM,KAAK8F,KAAK,CAAC9F,MAAM;QACrC,CAAC;MACH;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAAS0C,eAAeA,CAAEd,MAAM,EAAE1B,KAAK,EAAE;IACvC,OAAOA,KAAK,GAAG0B,MAAM,CAAC5B,MAAM,GACxB4B,MAAM,CAAC1B,KAAK,CAAC,GACbsF,YAAY,CAAC5D,MAAM,CAAC,GAAG6D,IAAI,CAAC7D,MAAM,CAAC,GAAG,IAAI;EAChD;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAAS0E,iBAAiBA,CAAE1E,MAAM,EAAE1B,KAAK,EAAE;IACzC,MAAM2D,KAAK,GAAGnB,eAAe,CAACd,MAAM,EAAE1B,KAAK,CAAC;IAC5C,IAAI,CAAC2D,KAAK,EAAE;MACV,OAAO,IAAIoB,GAAG,CAAC,CAAC;IAClB;IACA,OAAOnC,YAAY,CAACe,KAAK,CAAC;EAC5B;;EAEA;AACF;AACA;AACA;AACA;EACE,SAAS0C,WAAWA,CAAEjH,IAAI,EAAE;IAC1B,OAAOA,IAAI,CAACgF,UAAU,KAAK,IAAI,IAAIhF,IAAI,CAACgF,UAAU,KAAKvG,SAAS;EAClE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASyI,mBAAmBA,CAAExE,UAAU,EAAE9B,KAAK,EAAE;IAC/C,MAAM8E,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;IACzBjD,UAAU,CAACkD,OAAO,CAAC3D,SAAS,IAAI;MAC9B,MAAMkF,QAAQ,GAAGH,iBAAiB,CAAC/E,SAAS,CAACK,MAAM,EAAE1B,KAAK,CAAC;MAC3D,IAAI3B,IAAI;MACR,KAAKA,IAAI,IAAIkI,QAAQ,EAAE;QACrBzB,OAAO,CAACG,GAAG,CAAC5G,IAAI,CAAC;MACnB;IACF,CAAC,CAAC;IAEF,OAAOyG,OAAO,CAAC3E,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG5B,KAAK,CAAC+E,IAAI,CAACwB,OAAO,CAAC;EAC3D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAAS0B,WAAWA,CAAEnI,IAAI,EAAE6H,IAAI,EAAEpE,UAAU,EAAE;IAC5C,IAAI2E,GAAG,EAAEC,QAAQ;IACjB,MAAMC,KAAK,GAAGtI,IAAI,IAAI,SAAS;;IAE/B;IACA,IAAIuI,kBAAkB,GAAG9E,UAAU;IACnC,IAAI9B,KAAK;IACT,KAAKA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGkG,IAAI,CAACpG,MAAM,EAAEE,KAAK,EAAE,EAAE;MAC5C,MAAM6G,gBAAgB,GAAG,EAAE;MAC3BD,kBAAkB,CAAC5B,OAAO,CAAC3D,SAAS,IAAI;QACtC,MAAMsC,KAAK,GAAGnB,eAAe,CAACnB,SAAS,CAACK,MAAM,EAAE1B,KAAK,CAAC;QACtD,MAAM1B,IAAI,GAAGkH,WAAW,CAAC7B,KAAK,CAAC;QAC/B,IAAI,CAAC3D,KAAK,GAAGqB,SAAS,CAACK,MAAM,CAAC5B,MAAM,IAClCwF,YAAY,CAACjE,SAAS,CAACK,MAAM,CAAC,KAC9BpD,IAAI,CAAC4H,IAAI,CAAClG,KAAK,CAAC,CAAC,EAAE;UACnB6G,gBAAgB,CAACzG,IAAI,CAACiB,SAAS,CAAC;QAClC;MACF,CAAC,CAAC;MAEF,IAAIwF,gBAAgB,CAAC/G,MAAM,KAAK,CAAC,EAAE;QACjC;QACA4G,QAAQ,GAAGJ,mBAAmB,CAACM,kBAAkB,EAAE5G,KAAK,CAAC;QACzD,IAAI0G,QAAQ,CAAC5G,MAAM,GAAG,CAAC,EAAE;UACvB,MAAMgH,WAAW,GAAGjG,aAAa,CAACqF,IAAI,CAAClG,KAAK,CAAC,CAAC;UAE9CyG,GAAG,GAAG,IAAIhH,SAAS,CAAC,0CAA0C,GAAGkH,KAAK,GACpE,cAAc,GAAGD,QAAQ,CAACjF,IAAI,CAAC,MAAM,CAAC,GACtC,YAAY,GAAGqF,WAAW,CAACrF,IAAI,CAAC,KAAK,CAAC,GAAG,WAAW,GAAGzB,KAAK,GAAG,GAAG,CAAC;UACrEyG,GAAG,CAACM,IAAI,GAAG;YACTC,QAAQ,EAAE,WAAW;YACrB5F,EAAE,EAAEuF,KAAK;YACT3G,KAAK;YACLiH,MAAM,EAAEH,WAAW;YACnBJ;UACF,CAAC;UACD,OAAOD,GAAG;QACZ;MACF,CAAC,MAAM;QACLG,kBAAkB,GAAGC,gBAAgB;MACvC;IACF;;IAEA;IACA,MAAMK,OAAO,GAAGN,kBAAkB,CAACpD,GAAG,CAAC,UAAUnC,SAAS,EAAE;MAC1D,OAAOiE,YAAY,CAACjE,SAAS,CAACK,MAAM,CAAC,GACjCyF,QAAQ,GACR9F,SAAS,CAACK,MAAM,CAAC5B,MAAM;IAC7B,CAAC,CAAC;IACF,IAAIoG,IAAI,CAACpG,MAAM,GAAGsH,IAAI,CAACC,GAAG,CAACC,KAAK,CAAC,IAAI,EAAEJ,OAAO,CAAC,EAAE;MAC/CR,QAAQ,GAAGJ,mBAAmB,CAACM,kBAAkB,EAAE5G,KAAK,CAAC;MACzDyG,GAAG,GAAG,IAAIhH,SAAS,CAAC,gCAAgC,GAAGkH,KAAK,GAC1D,cAAc,GAAGD,QAAQ,CAACjF,IAAI,CAAC,MAAM,CAAC,GACtC,WAAW,GAAGyE,IAAI,CAACpG,MAAM,GAAG,GAAG,CAAC;MAClC2G,GAAG,CAACM,IAAI,GAAG;QACTC,QAAQ,EAAE,YAAY;QACtB5F,EAAE,EAAEuF,KAAK;QACT3G,KAAK,EAAEkG,IAAI,CAACpG,MAAM;QAClB4G;MACF,CAAC;MACD,OAAOD,GAAG;IACZ;;IAEA;IACA,MAAMc,SAAS,GAAGH,IAAI,CAACI,GAAG,CAACF,KAAK,CAAC,IAAI,EAAEJ,OAAO,CAAC;IAC/C,IAAIhB,IAAI,CAACpG,MAAM,GAAGyH,SAAS,EAAE;MAC3Bd,GAAG,GAAG,IAAIhH,SAAS,CAAC,iCAAiC,GAAGkH,KAAK,GAC3D,cAAc,GAAGY,SAAS,GAAG,YAAY,GAAGrB,IAAI,CAACpG,MAAM,GAAG,GAAG,CAAC;MAChE2G,GAAG,CAACM,IAAI,GAAG;QACTC,QAAQ,EAAE,aAAa;QACvB5F,EAAE,EAAEuF,KAAK;QACT3G,KAAK,EAAEkG,IAAI,CAACpG,MAAM;QAClB2H,cAAc,EAAEF;MAClB,CAAC;MACD,OAAOd,GAAG;IACZ;;IAEA;IACA,MAAMiB,QAAQ,GAAG,EAAE;IACnB,KAAK,IAAIxH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgG,IAAI,CAACpG,MAAM,EAAE,EAAEI,CAAC,EAAE;MACpCwH,QAAQ,CAACtH,IAAI,CAACS,aAAa,CAACqF,IAAI,CAAChG,CAAC,CAAC,CAAC,CAACuB,IAAI,CAAC,GAAG,CAAC,CAAC;IACjD;IACAgF,GAAG,GAAG,IAAIhH,SAAS,CAAC,qBAAqB,GAAGiI,QAAQ,CAACjG,IAAI,CAAC,IAAI,CAAC,GAC7D,2DAA2D,GAAGkF,KAAK,GAAG,GAAG,CAAC;IAC5EF,GAAG,CAACM,IAAI,GAAG;MACTC,QAAQ,EAAE,UAAU;MACpBC,MAAM,EAAES;IACV,CAAC;IACD,OAAOjB,GAAG;EACZ;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASkB,kBAAkBA,CAAEhE,KAAK,EAAE;IAClC,IAAI0D,GAAG,GAAGvI,QAAQ,CAACgB,MAAM,GAAG,CAAC;IAE7B,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,KAAK,CAAChE,KAAK,CAACG,MAAM,EAAEI,CAAC,EAAE,EAAE;MAC3CmH,GAAG,GAAGD,IAAI,CAACC,GAAG,CAACA,GAAG,EAAE1D,KAAK,CAAChE,KAAK,CAACO,CAAC,CAAC,CAACiE,SAAS,CAAC;IAC/C;IAEA,OAAOkD,GAAG;EACZ;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASO,wBAAwBA,CAAEjE,KAAK,EAAE;IACxC,IAAI0D,GAAG,GAAGtI,YAAY,GAAG,CAAC;IAE1B,KAAK,IAAImB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,KAAK,CAAChE,KAAK,CAACG,MAAM,EAAEI,CAAC,EAAE,EAAE;MAC3C,IAAI,CAACmG,WAAW,CAAC1C,KAAK,CAAChE,KAAK,CAACO,CAAC,CAAC,CAAC,EAAE;QAChCmH,GAAG,GAAGD,IAAI,CAACC,GAAG,CAACA,GAAG,EAAE1D,KAAK,CAAChE,KAAK,CAACO,CAAC,CAAC,CAACmE,eAAe,CAAC;MACrD;IACF;IAEA,OAAOgD,GAAG;EACZ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASQ,aAAaA,CAAEC,MAAM,EAAEC,MAAM,EAAE;IACtC;IACA;IACA,IAAID,MAAM,CAACpF,MAAM,EAAE;MACjB,IAAI,CAACqF,MAAM,CAACrF,MAAM,EAAE;QAClB,OAAO,GAAG;MACZ;IACF,CAAC,MAAM,IAAIqF,MAAM,CAACrF,MAAM,EAAE;MACxB,OAAO,CAAC,GAAG;IACb;;IAEA;IACA,IAAIoF,MAAM,CAACrF,SAAS,EAAE;MACpB,IAAI,CAACsF,MAAM,CAACtF,SAAS,EAAE;QACrB,OAAO,IAAI;MACb;IACF,CAAC,MAAM,IAAIsF,MAAM,CAACtF,SAAS,EAAE;MAC3B,OAAO,CAAC,IAAI;IACd;;IAEA;IACA,MAAMuF,QAAQ,GAAGL,kBAAkB,CAACG,MAAM,CAAC,GAAGH,kBAAkB,CAACI,MAAM,CAAC;IACxE,IAAIC,QAAQ,GAAG,CAAC,EAAE;MAChB,OAAO,CAAC,KAAK;IACf;IACA,IAAIA,QAAQ,GAAG,CAAC,EAAE;MAChB,OAAO,KAAK;IACd;;IAEA;IACA;IACA,MAAMC,KAAK,GAAGL,wBAAwB,CAACE,MAAM,CAAC;IAC9C,MAAMI,KAAK,GAAGN,wBAAwB,CAACG,MAAM,CAAC;IAC9C,IAAID,MAAM,CAACxD,aAAa,EAAE;MACxB,IAAI,CAACyD,MAAM,CAACzD,aAAa,EAAE;QACzB,OAAO,CAAC,CAAC,GAAG2D,KAAK,IAAI,QAAQ;MAC/B;IACF,CAAC,MAAM,IAAIF,MAAM,CAACzD,aAAa,EAAE;MAC/B,OAAO,EAAE,CAAC,GAAG4D,KAAK,CAAC,GAAG,QAAQ;IAChC;;IAEA;IACA,MAAMC,QAAQ,GAAGF,KAAK,GAAGC,KAAK;IAC9B,IAAIC,QAAQ,GAAG,CAAC,EAAE;MAChB,OAAO,CAAC,SAAS;IACnB;IACA,IAAIA,QAAQ,GAAG,CAAC,EAAE;MAChB,OAAO,SAAS;IAClB;;IAEA;IACA,OAAO,CAAC;EACV;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,iBAAiBA,CAAEC,UAAU,EAAEC,UAAU,EAAE;IAClD,MAAMC,KAAK,GAAGF,UAAU,CAAC3G,MAAM;IAC/B,MAAM8G,KAAK,GAAGF,UAAU,CAAC5G,MAAM;IAC/B,MAAM+G,KAAK,GAAGlD,IAAI,CAACgD,KAAK,CAAC;IACzB,MAAMG,KAAK,GAAGnD,IAAI,CAACiD,KAAK,CAAC;IACzB,MAAMG,QAAQ,GAAGrD,YAAY,CAACiD,KAAK,CAAC;IACpC,MAAMK,QAAQ,GAAGtD,YAAY,CAACkD,KAAK,CAAC;IACpC;IACA;IACA,IAAIG,QAAQ,IAAIF,KAAK,CAAC/F,MAAM,EAAE;MAC5B,IAAI,CAACkG,QAAQ,IAAI,CAACF,KAAK,CAAChG,MAAM,EAAE;QAC9B,OAAO,QAAQ;MACjB;IACF,CAAC,MAAM,IAAIkG,QAAQ,IAAIF,KAAK,CAAChG,MAAM,EAAE;MACnC,OAAO,CAAC,QAAQ;IAClB;;IAEA;IACA,IAAImG,IAAI,GAAG,CAAC;IACZ,IAAIZ,KAAK,GAAG,CAAC;IACb,IAAIa,GAAG;IACP,KAAKA,GAAG,IAAIP,KAAK,EAAE;MACjB,IAAIO,GAAG,CAACpG,MAAM,EAAE,EAAEmG,IAAI;MACtB,IAAIC,GAAG,CAACxE,aAAa,EAAE,EAAE2D,KAAK;IAChC;IACA,IAAIc,IAAI,GAAG,CAAC;IACZ,IAAIb,KAAK,GAAG,CAAC;IACb,KAAKY,GAAG,IAAIN,KAAK,EAAE;MACjB,IAAIM,GAAG,CAACpG,MAAM,EAAE,EAAEqG,IAAI;MACtB,IAAID,GAAG,CAACxE,aAAa,EAAE,EAAE4D,KAAK;IAChC;IACA,IAAIW,IAAI,KAAKE,IAAI,EAAE;MACjB,OAAO,CAACF,IAAI,GAAGE,IAAI,IAAI,OAAO;IAChC;;IAEA;IACA,IAAIJ,QAAQ,IAAIF,KAAK,CAACnE,aAAa,EAAE;MACnC,IAAI,CAACsE,QAAQ,IAAI,CAACF,KAAK,CAACpE,aAAa,EAAE;QACrC,OAAO,MAAM;MACf;IACF,CAAC,MAAM,IAAIsE,QAAQ,IAAIF,KAAK,CAACpE,aAAa,EAAE;MAC1C,OAAO,CAAC,MAAM;IAChB;;IAEA;IACA,IAAI2D,KAAK,KAAKC,KAAK,EAAE;MACnB,OAAO,CAACD,KAAK,GAAGC,KAAK,IAAI,KAAK;IAChC;;IAEA;IACA,IAAIS,QAAQ,EAAE;MACZ,IAAI,CAACC,QAAQ,EAAE;QACb,OAAO,IAAI;MACb;IACF,CAAC,MAAM,IAAIA,QAAQ,EAAE;MACnB,OAAO,CAAC,IAAI;IACd;;IAEA;IACA,MAAMI,eAAe,GACnB,CAACT,KAAK,CAACzI,MAAM,GAAG0I,KAAK,CAAC1I,MAAM,KAAK6I,QAAQ,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC;IACzD,IAAIK,eAAe,KAAK,CAAC,EAAE;MACzB,OAAOA,eAAe;IACxB;;IAEA;IACA;IACA;IACA;IACA,MAAMC,WAAW,GAAG,EAAE;IACtB,IAAIC,EAAE,GAAG,CAAC;IACV,KAAK,IAAIhJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqI,KAAK,CAACzI,MAAM,EAAE,EAAEI,CAAC,EAAE;MACrC,MAAMiJ,cAAc,GAAGtB,aAAa,CAACU,KAAK,CAACrI,CAAC,CAAC,EAAEsI,KAAK,CAACtI,CAAC,CAAC,CAAC;MACxD+I,WAAW,CAAC7I,IAAI,CAAC+I,cAAc,CAAC;MAChCD,EAAE,IAAIC,cAAc;IACtB;IACA,IAAID,EAAE,KAAK,CAAC,EAAE;MACZ,OAAO,CAAEA,EAAE,GAAG,CAAC,GAAI,CAAC,EAAE,GAAG,EAAE,IAAIA,EAAE;IACnC;;IAEA;IACA;IACA;IACA;IACA,IAAIE,CAAC;IACL,IAAIC,KAAK,GAAG,CAAC;IACb,MAAMC,SAAS,GAAGD,KAAK,IAAIJ,WAAW,CAACnJ,MAAM,GAAG,CAAC,CAAC;IAClD,KAAKsJ,CAAC,IAAIH,WAAW,EAAE;MACrB,IAAIG,CAAC,KAAK,CAAC,EAAE;QACX,OAAO,CAAEA,CAAC,GAAG,CAAC,GAAI,CAACC,KAAK,GAAGA,KAAK,IAAID,CAAC;MACvC;MACAC,KAAK,IAAIC,SAAS;IACpB;;IAEA;IACA,OAAO,CAAC;EACV;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAAS3E,oBAAoBA,CAAEH,SAAS,EAAE;IACxC,IAAIA,SAAS,CAAC1E,MAAM,KAAK,CAAC,EAAE;MAC1B,OAAO,EAAE;IACX;IACA,MAAMH,KAAK,GAAG6E,SAAS,CAAChB,GAAG,CAACtE,QAAQ,CAAC;IACrC,IAAIsF,SAAS,CAAC1E,MAAM,KAAK,CAAC,EAAE,OAAOH,KAAK,CAAC,CAAC,CAAC,CAACW,aAAa;;IAEzD;IACA;IACA;IACA,MAAMiJ,UAAU,GAAG,IAAIxE,GAAG,CAACP,SAAS,CAAC;IACrC,MAAMK,gBAAgB,GAAG,IAAIE,GAAG,CAAC,CAAC;IAClC,KAAK,IAAI7E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACG,MAAM,EAAE,EAAEI,CAAC,EAAE;MACrC,KAAK,MAAM6B,KAAK,IAAIpC,KAAK,CAACO,CAAC,CAAC,CAACI,aAAa,EAAE;QAC1C,IAAI,CAACiJ,UAAU,CAACpJ,GAAG,CAAC4B,KAAK,CAACuB,IAAI,CAAC,EAAEuB,gBAAgB,CAACI,GAAG,CAAClD,KAAK,CAACuB,IAAI,CAAC;MACnE;IACF;;IAEA;IACA,MAAMvC,OAAO,GAAG,EAAE;IAClB,KAAK,MAAM5B,QAAQ,IAAI0F,gBAAgB,EAAE;MACvC,IAAI2E,SAAS,GAAGzK,YAAY,GAAG,CAAC;MAChC,IAAI0K,cAAc,GAAG,IAAI;MACzB,KAAK,IAAIvJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACG,MAAM,EAAE,EAAEI,CAAC,EAAE;QACrC,KAAK,MAAM6B,KAAK,IAAIpC,KAAK,CAACO,CAAC,CAAC,CAACI,aAAa,EAAE;UAC1C,IAAIyB,KAAK,CAACuB,IAAI,KAAKnE,QAAQ,IAAI4C,KAAK,CAAC/B,KAAK,GAAGwJ,SAAS,EAAE;YACtDA,SAAS,GAAGzH,KAAK,CAAC/B,KAAK;YACvByJ,cAAc,GAAG1H,KAAK;UACxB;QACF;MACF;MACAhB,OAAO,CAACX,IAAI,CAACqJ,cAAc,CAAC;IAC9B;IAEA,OAAO1I,OAAO;EAChB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAAS2I,wBAAwBA,CAAEhI,MAAM,EAAEN,EAAE,EAAE;IAC7C,IAAIuI,SAAS,GAAGvI,EAAE;;IAElB;;IAEA,IAAI/C,IAAI,GAAG,EAAE;IACb,IAAIqD,MAAM,CAACmB,IAAI,CAACY,CAAC,IAAIA,CAAC,CAACa,aAAa,CAAC,EAAE;MACrC,MAAM7B,SAAS,GAAG6C,YAAY,CAAC5D,MAAM,CAAC;MACtC,MAAMkI,mBAAmB,GAAGlI,MAAM,CAAC8B,GAAG,CAACqG,oBAAoB,CAAC;MAC5DxL,IAAI,GAAGuL,mBAAmB,CAACpG,GAAG,CAACsG,IAAI,IAAIA,IAAI,CAACzL,IAAI,CAAC,CAACoD,IAAI,CAAC,GAAG,CAAC;MAC3DkI,SAAS,GAAG,SAASI,WAAWA,CAAA,EAAI;QAClC,MAAM7D,IAAI,GAAG,EAAE;QACf,MAAMX,IAAI,GAAG9C,SAAS,GAAG5C,SAAS,CAACC,MAAM,GAAG,CAAC,GAAGD,SAAS,CAACC,MAAM;QAChE,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqF,IAAI,EAAErF,CAAC,EAAE,EAAE;UAC7BgG,IAAI,CAAChG,CAAC,CAAC,GAAG0J,mBAAmB,CAAC1J,CAAC,CAAC,CAACL,SAAS,CAACK,CAAC,CAAC,CAAC;QAChD;QACA,IAAIuC,SAAS,EAAE;UACbyD,IAAI,CAACX,IAAI,CAAC,GAAG1F,SAAS,CAAC0F,IAAI,CAAC,CAAC/B,GAAG,CAACoG,mBAAmB,CAACrE,IAAI,CAAC,CAAC;QAC7D;QAEA,OAAOnE,EAAE,CAACkG,KAAK,CAAC,IAAI,EAAEpB,IAAI,CAAC;MAC7B,CAAC;IACH;IAEA,IAAI8D,YAAY,GAAGL,SAAS;IAC5B,IAAIrE,YAAY,CAAC5D,MAAM,CAAC,EAAE;MACxB,MAAMuI,MAAM,GAAGvI,MAAM,CAAC5B,MAAM,GAAG,CAAC;MAEhCkK,YAAY,GAAG,SAASE,oBAAoBA,CAAA,EAAI;QAC9C,OAAOP,SAAS,CAACrC,KAAK,CAAC,IAAI,EACzB9G,KAAK,CAACX,SAAS,EAAE,CAAC,EAAEoK,MAAM,CAAC,CAACxJ,MAAM,CAAC,CAACD,KAAK,CAACX,SAAS,EAAEoK,MAAM,CAAC,CAAC,CAAC,CAAC;MACnE,CAAC;IACH;IACA,IAAI5L,IAAI,EAAEF,MAAM,CAACgM,cAAc,CAACH,YAAY,EAAE,MAAM,EAAE;MAAElJ,KAAK,EAAEzC;IAAK,CAAC,CAAC;IACtE,OAAO2L,YAAY;EACrB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASH,oBAAoBA,CAAElG,KAAK,EAAE;IACpC,IAAI8B,KAAK,EAAEC,KAAK,EAAE0E,WAAW,EAAEC,WAAW;IAC1C,MAAMzE,KAAK,GAAG,EAAE;IAChB,MAAMzC,WAAW,GAAG,EAAE;IACtB,IAAI9E,IAAI,GAAG,EAAE;IACbsF,KAAK,CAAChE,KAAK,CAACqF,OAAO,CAAC,UAAU5F,IAAI,EAAE;MAClC,IAAIA,IAAI,CAACgF,UAAU,EAAE;QACnB/F,IAAI,IAAIe,IAAI,CAACgF,UAAU,CAACd,IAAI,GAAG,IAAI,GAAGlE,IAAI,CAACgF,UAAU,CAACkG,EAAE,GAAG,GAAG;QAC9D1E,KAAK,CAACxF,IAAI,CAAClB,QAAQ,CAACE,IAAI,CAACgF,UAAU,CAACd,IAAI,CAAC,CAAChF,IAAI,CAAC;QAC/C6E,WAAW,CAAC/C,IAAI,CAAChB,IAAI,CAACgF,UAAU,CAAClB,OAAO,CAAC;MAC3C;IACF,CAAC,CAAC;IACF,IAAI7E,IAAI,EAAEA,IAAI,GAAGA,IAAI,CAACmC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAC7BnC,IAAI,GAAG,MAAM;;IAElB;IACA,IAAIkM,SAAS,GAAGC,GAAG,IAAIA,GAAG;IAC1B,QAAQrH,WAAW,CAACrD,MAAM;MACxB,KAAK,CAAC;QAAE;MACR,KAAK,CAAC;QACJ2F,KAAK,GAAGG,KAAK,CAAC,CAAC,CAAC;QAChBwE,WAAW,GAAGjH,WAAW,CAAC,CAAC,CAAC;QAC5BoH,SAAS,GAAG,SAASE,UAAUA,CAAED,GAAG,EAAE;UACpC,IAAI/E,KAAK,CAAC+E,GAAG,CAAC,EAAE;YACd,OAAOJ,WAAW,CAACI,GAAG,CAAC;UACzB;UACA,OAAOA,GAAG;QACZ,CAAC;QACD;MACF,KAAK,CAAC;QACJ/E,KAAK,GAAGG,KAAK,CAAC,CAAC,CAAC;QAChBF,KAAK,GAAGE,KAAK,CAAC,CAAC,CAAC;QAChBwE,WAAW,GAAGjH,WAAW,CAAC,CAAC,CAAC;QAC5BkH,WAAW,GAAGlH,WAAW,CAAC,CAAC,CAAC;QAC5BoH,SAAS,GAAG,SAASE,UAAUA,CAAED,GAAG,EAAE;UACpC,IAAI/E,KAAK,CAAC+E,GAAG,CAAC,EAAE;YACd,OAAOJ,WAAW,CAACI,GAAG,CAAC;UACzB;UACA,IAAI9E,KAAK,CAAC8E,GAAG,CAAC,EAAE;YACd,OAAOH,WAAW,CAACG,GAAG,CAAC;UACzB;UACA,OAAOA,GAAG;QACZ,CAAC;QACD;MACF;QACED,SAAS,GAAG,SAASE,UAAUA,CAAED,GAAG,EAAE;UACpC,KAAK,IAAItK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiD,WAAW,CAACrD,MAAM,EAAEI,CAAC,EAAE,EAAE;YAC3C,IAAI0F,KAAK,CAAC1F,CAAC,CAAC,CAACsK,GAAG,CAAC,EAAE;cACjB,OAAOrH,WAAW,CAACjD,CAAC,CAAC,CAACsK,GAAG,CAAC;YAC5B;UACF;UACA,OAAOA,GAAG;QACZ,CAAC;IACL;IACArM,MAAM,CAACgM,cAAc,CAACI,SAAS,EAAE,MAAM,EAAE;MAAEzJ,KAAK,EAAEzC;IAAK,CAAC,CAAC;IACzD,OAAOkM,SAAS;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASG,WAAWA,CAAEhJ,MAAM,EAAE;IAC5B,SAASiJ,YAAYA,CAAEjJ,MAAM,EAAE1B,KAAK,EAAE4K,WAAW,EAAE;MACjD,IAAI5K,KAAK,GAAG0B,MAAM,CAAC5B,MAAM,EAAE;QACzB,MAAM6D,KAAK,GAAGjC,MAAM,CAAC1B,KAAK,CAAC;QAC3B,IAAI6K,eAAe,GAAG,EAAE;QAExB,IAAIlH,KAAK,CAAClB,SAAS,EAAE;UACnB;UACA;UACA,MAAMyB,UAAU,GAAGP,KAAK,CAAChE,KAAK,CAACqB,MAAM,CAACqF,WAAW,CAAC;UAClD,IAAInC,UAAU,CAACpE,MAAM,GAAG6D,KAAK,CAAChE,KAAK,CAACG,MAAM,EAAE;YAC1C+K,eAAe,CAACzK,IAAI,CAAC;cACnBT,KAAK,EAAEuE,UAAU;cACjB7F,IAAI,EAAE,KAAK,GAAG6F,UAAU,CAACV,GAAG,CAACiB,CAAC,IAAIA,CAAC,CAACpG,IAAI,CAAC,CAACoD,IAAI,CAAC,GAAG,CAAC;cACnDiB,MAAM,EAAEwB,UAAU,CAACrB,IAAI,CAAC4B,CAAC,IAAIA,CAAC,CAAC7F,KAAK,CAAC;cACrC0F,aAAa,EAAE,KAAK;cACpB7B,SAAS,EAAE;YACb,CAAC,CAAC;UACJ;UACAoI,eAAe,CAACzK,IAAI,CAACuD,KAAK,CAAC;QAC7B,CAAC,MAAM;UACL;UACAkH,eAAe,GAAGlH,KAAK,CAAChE,KAAK,CAAC6D,GAAG,CAAC,UAAUpE,IAAI,EAAE;YAChD,OAAO;cACLO,KAAK,EAAE,CAACP,IAAI,CAAC;cACbf,IAAI,EAAEe,IAAI,CAACf,IAAI;cACfqE,MAAM,EAAEtD,IAAI,CAACR,KAAK;cAClB0F,aAAa,EAAElF,IAAI,CAACgF,UAAU;cAC9B3B,SAAS,EAAE;YACb,CAAC;UACH,CAAC,CAAC;QACJ;;QAEA;QACA,OAAOqI,OAAO,CAACD,eAAe,EAAE,UAAUE,SAAS,EAAE;UACnD,OAAOJ,YAAY,CAACjJ,MAAM,EAAE1B,KAAK,GAAG,CAAC,EAAE4K,WAAW,CAACnK,MAAM,CAAC,CAACsK,SAAS,CAAC,CAAC,CAAC;QACzE,CAAC,CAAC;MACJ,CAAC,MAAM;QACL;QACA,OAAO,CAACH,WAAW,CAAC;MACtB;IACF;IAEA,OAAOD,YAAY,CAACjJ,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;EACpC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASsJ,WAAWA,CAAEC,OAAO,EAAEC,OAAO,EAAE;IACtC,MAAMC,EAAE,GAAG/D,IAAI,CAACI,GAAG,CAACyD,OAAO,CAACnL,MAAM,EAAEoL,OAAO,CAACpL,MAAM,CAAC;IAEnD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiL,EAAE,EAAEjL,CAAC,EAAE,EAAE;MAC3B,MAAMkL,QAAQ,GAAGhF,iBAAiB,CAAC6E,OAAO,EAAE/K,CAAC,CAAC;MAC9C,MAAMmL,QAAQ,GAAGjF,iBAAiB,CAAC8E,OAAO,EAAEhL,CAAC,CAAC;MAC9C,IAAIoL,OAAO,GAAG,KAAK;MACnB,IAAIjN,IAAI;MACR,KAAKA,IAAI,IAAIgN,QAAQ,EAAE;QACrB,IAAID,QAAQ,CAACjL,GAAG,CAAC9B,IAAI,CAAC,EAAE;UACtBiN,OAAO,GAAG,IAAI;UACd;QACF;MACF;MACA,IAAI,CAACA,OAAO,EAAE;QACZ,OAAO,KAAK;MACd;IACF;IAEA,MAAMC,IAAI,GAAGN,OAAO,CAACnL,MAAM;IAC3B,MAAM0L,IAAI,GAAGN,OAAO,CAACpL,MAAM;IAC3B,MAAM2L,UAAU,GAAGnG,YAAY,CAAC2F,OAAO,CAAC;IACxC,MAAMS,UAAU,GAAGpG,YAAY,CAAC4F,OAAO,CAAC;IAExC,OAAOO,UAAU,GACbC,UAAU,GAAIH,IAAI,KAAKC,IAAI,GAAKA,IAAI,IAAID,IAAK,GAC7CG,UAAU,GAAIH,IAAI,IAAIC,IAAI,GAAKD,IAAI,KAAKC,IAAK;EACnD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASG,gBAAgBA,CAAEC,YAAY,EAAE;IACvC,OAAOA,YAAY,CAACpI,GAAG,CAACpC,EAAE,IAAI;MAC5B,IAAIyK,aAAa,CAACzK,EAAE,CAAC,EAAE;QACrB,OAAO0K,WAAW,CAAC1K,EAAE,CAAC0K,WAAW,CAACC,QAAQ,CAAC;MAC7C;MACA,IAAIC,SAAS,CAAC5K,EAAE,CAAC,EAAE;QACjB,OAAO6K,WAAW,CAAC7K,EAAE,CAAC8K,OAAO,CAACC,UAAU,EAAE/K,EAAE,CAAC8K,OAAO,CAACH,QAAQ,CAAC;MAChE;MACA,OAAO3K,EAAE;IACX,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASgL,kBAAkBA,CAAED,UAAU,EAAEP,YAAY,EAAE3J,YAAY,EAAE;IACnE,MAAMoK,kBAAkB,GAAG,EAAE;IAC7B,IAAIC,SAAS;IACb,KAAKA,SAAS,IAAIH,UAAU,EAAE;MAC5B,IAAII,UAAU,GAAGtK,YAAY,CAACqK,SAAS,CAAC;MACxC,IAAI,OAAOC,UAAU,KAAK,QAAQ,EAAE;QAClC,MAAM,IAAI9M,SAAS,CACjB,0CAA0C,GAAG6M,SAAS,GAAG,GAAG,CAAC;MACjE;MACAC,UAAU,GAAGX,YAAY,CAACW,UAAU,CAAC;MACrC,IAAI,OAAOA,UAAU,KAAK,UAAU,EAAE;QACpC,OAAO,KAAK;MACd;MACAF,kBAAkB,CAACjM,IAAI,CAACmM,UAAU,CAAC;IACrC;IACA,OAAOF,kBAAkB;EAC3B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASG,iBAAiBA,CAAEZ,YAAY,EAAE3J,YAAY,EAAEwK,IAAI,EAAE;IAC5D,MAAMC,iBAAiB,GAAGf,gBAAgB,CAACC,YAAY,CAAC;IACxD,MAAMe,UAAU,GAAG,IAAIpO,KAAK,CAACmO,iBAAiB,CAAC5M,MAAM,CAAC,CAAC8M,IAAI,CAAC,KAAK,CAAC;IAClE,IAAIC,cAAc,GAAG,IAAI;IACzB,OAAOA,cAAc,EAAE;MACrBA,cAAc,GAAG,KAAK;MACtB,IAAIC,eAAe,GAAG,IAAI;MAC1B,KAAK,IAAI5M,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwM,iBAAiB,CAAC5M,MAAM,EAAE,EAAEI,CAAC,EAAE;QACjD,IAAIyM,UAAU,CAACzM,CAAC,CAAC,EAAE;QACnB,MAAMkB,EAAE,GAAGsL,iBAAiB,CAACxM,CAAC,CAAC;QAE/B,IAAI2L,aAAa,CAACzK,EAAE,CAAC,EAAE;UACrBsL,iBAAiB,CAACxM,CAAC,CAAC,GAAGkB,EAAE,CAAC0K,WAAW,CAACC,QAAQ,CAACU,IAAI,CAAC;UACpD;UACAC,iBAAiB,CAACxM,CAAC,CAAC,CAAC4L,WAAW,GAAG1K,EAAE,CAAC0K,WAAW;UACjDa,UAAU,CAACzM,CAAC,CAAC,GAAG,IAAI;UACpB4M,eAAe,GAAG,KAAK;QACzB,CAAC,MAAM,IAAId,SAAS,CAAC5K,EAAE,CAAC,EAAE;UACxB,MAAMiL,kBAAkB,GAAGD,kBAAkB,CAC3ChL,EAAE,CAAC8K,OAAO,CAACC,UAAU,EAAEO,iBAAiB,EAAEzK,YAAY,CAAC;UACzD,IAAIoK,kBAAkB,EAAE;YACtBK,iBAAiB,CAACxM,CAAC,CAAC,GAClBkB,EAAE,CAAC8K,OAAO,CAACH,QAAQ,CAACzE,KAAK,CAAC,IAAI,EAAE+E,kBAAkB,CAAC;YACrD;YACAK,iBAAiB,CAACxM,CAAC,CAAC,CAACgM,OAAO,GAAG9K,EAAE,CAAC8K,OAAO;YACzCS,UAAU,CAACzM,CAAC,CAAC,GAAG,IAAI;YACpB4M,eAAe,GAAG,KAAK;UACzB,CAAC,MAAM;YACLD,cAAc,GAAG,IAAI;UACvB;QACF;MACF;MAEA,IAAIC,eAAe,IAAID,cAAc,EAAE;QACrC,MAAM,IAAIxH,WAAW,CACnB,wDAAwD,CAAC;MAC7D;IACF;IAEA,OAAOqH,iBAAiB;EAC1B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASK,sBAAsBA,CAAEC,aAAa,EAAE;IAC9C;;IAEA;IACA,MAAMC,mBAAmB,GAAG,2BAA2B;IAEvD9O,MAAM,CAAC+O,IAAI,CAACF,aAAa,CAAC,CAAChI,OAAO,CAAC3D,SAAS,IAAI;MAC9C,MAAMD,EAAE,GAAG4L,aAAa,CAAC3L,SAAS,CAAC;MAEnC,IAAI4L,mBAAmB,CAAC3O,IAAI,CAAC8C,EAAE,CAAC+L,QAAQ,CAAC,CAAC,CAAC,EAAE;QAC3C,MAAM,IAAI9H,WAAW,CAAC,4CAA4C,GAChE,wCAAwC,GACxC,kDAAkD,CAAC;MACvD;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAAS+H,mBAAmBA,CAAE/O,IAAI,EAAEgP,gBAAgB,EAAE;IACpDrO,KAAK,CAACC,WAAW,EAAE;IAEnB,IAAId,MAAM,CAAC+O,IAAI,CAACG,gBAAgB,CAAC,CAACvN,MAAM,KAAK,CAAC,EAAE;MAC9C,MAAM,IAAIuF,WAAW,CAAC,wBAAwB,CAAC;IACjD;IAEA,IAAIrG,KAAK,CAACsO,yBAAyB,EAAE;MACnCP,sBAAsB,CAACM,gBAAgB,CAAC;IAC1C;;IAEA;IACA,MAAME,YAAY,GAAG,EAAE;IACvB,MAAMC,iBAAiB,GAAG,EAAE;IAC5B,MAAMR,aAAa,GAAG,CAAC,CAAC;IACxB,MAAMS,qBAAqB,GAAG,EAAE,EAAC;IACjC,IAAIpM,SAAS;IACb,KAAKA,SAAS,IAAIgM,gBAAgB,EAAE;MAClC;MACA,IAAI,CAAClP,MAAM,CAACuP,SAAS,CAACC,cAAc,CAACC,IAAI,CAACP,gBAAgB,EAAEhM,SAAS,CAAC,EAAE;QACtE;MACF;MACA;MACA,MAAMK,MAAM,GAAGC,cAAc,CAACN,SAAS,CAAC;MACxC,IAAI,CAACK,MAAM,EAAE;MACb;MACA6L,YAAY,CAACvI,OAAO,CAAC,UAAU6I,EAAE,EAAE;QACjC,IAAI7C,WAAW,CAAC6C,EAAE,EAAEnM,MAAM,CAAC,EAAE;UAC3B,MAAM,IAAIjC,SAAS,CAAC,0BAA0B,GAC5CoC,eAAe,CAACgM,EAAE,CAAC,GAAG,SAAS,GAC/BhM,eAAe,CAACH,MAAM,CAAC,GAAG,IAAI,CAAC;QACnC;MACF,CAAC,CAAC;MACF6L,YAAY,CAACnN,IAAI,CAACsB,MAAM,CAAC;MACzB;MACA,MAAMoM,aAAa,GAAGN,iBAAiB,CAAC1N,MAAM;MAC9C0N,iBAAiB,CAACpN,IAAI,CAACiN,gBAAgB,CAAChM,SAAS,CAAC,CAAC;MACnD,MAAM0M,gBAAgB,GAAGrM,MAAM,CAAC8B,GAAG,CAACe,WAAW,CAAC;MAChD;MACA,IAAIyJ,EAAE;MACN,KAAKA,EAAE,IAAItD,WAAW,CAACqD,gBAAgB,CAAC,EAAE;QACxC,MAAME,MAAM,GAAGpM,eAAe,CAACmM,EAAE,CAAC;QAClCP,qBAAqB,CAACrN,IAAI,CACxB;UAAEsB,MAAM,EAAEsM,EAAE;UAAE3P,IAAI,EAAE4P,MAAM;UAAE7M,EAAE,EAAE0M;QAAc,CAAC,CAAC;QAClD,IAAIE,EAAE,CAACE,KAAK,CAACzK,CAAC,IAAI,CAACA,CAAC,CAACa,aAAa,CAAC,EAAE;UACnC0I,aAAa,CAACiB,MAAM,CAAC,GAAGH,aAAa;QACvC;MACF;IACF;IAEAL,qBAAqB,CAACU,IAAI,CAAC/F,iBAAiB,CAAC;;IAE7C;IACA,MAAMsE,iBAAiB,GACrBF,iBAAiB,CAACgB,iBAAiB,EAAER,aAAa,EAAEoB,UAAU,CAAC;;IAEjE;IACA,IAAIrK,CAAC;IACL,KAAKA,CAAC,IAAIiJ,aAAa,EAAE;MACvB,IAAI7O,MAAM,CAACuP,SAAS,CAACC,cAAc,CAACC,IAAI,CAACZ,aAAa,EAAEjJ,CAAC,CAAC,EAAE;QAC1DiJ,aAAa,CAACjJ,CAAC,CAAC,GAAG2I,iBAAiB,CAACM,aAAa,CAACjJ,CAAC,CAAC,CAAC;MACxD;IACF;IACA,MAAMjC,UAAU,GAAG,EAAE;IACrB,MAAMuM,oBAAoB,GAAG,IAAI1N,GAAG,CAAC,CAAC,EAAC;IACvC,KAAKoD,CAAC,IAAI0J,qBAAqB,EAAE;MAC/B;MACA;MACA;MACA,IAAI,CAACY,oBAAoB,CAAClO,GAAG,CAAC4D,CAAC,CAAC1F,IAAI,CAAC,EAAE;QACrC0F,CAAC,CAAC3C,EAAE,GAAGsL,iBAAiB,CAAC3I,CAAC,CAAC3C,EAAE,CAAC;QAC9BU,UAAU,CAAC1B,IAAI,CAAC2D,CAAC,CAAC;QAClBsK,oBAAoB,CAAChO,GAAG,CAAC0D,CAAC,CAAC1F,IAAI,EAAE0F,CAAC,CAAC;MACrC;IACF;;IAEA;IACA,MAAMuK,GAAG,GAAGxM,UAAU,CAAC,CAAC,CAAC,IAAIA,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,IAAI,CAAC,IAAI,CAACwF,YAAY,CAACxD,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC;IACpG,MAAM6M,GAAG,GAAGzM,UAAU,CAAC,CAAC,CAAC,IAAIA,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,IAAI,CAAC,IAAI,CAACwF,YAAY,CAACxD,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC;IACpG,MAAM8M,GAAG,GAAG1M,UAAU,CAAC,CAAC,CAAC,IAAIA,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,IAAI,CAAC,IAAI,CAACwF,YAAY,CAACxD,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC;IACpG,MAAM+M,GAAG,GAAG3M,UAAU,CAAC,CAAC,CAAC,IAAIA,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,IAAI,CAAC,IAAI,CAACwF,YAAY,CAACxD,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC;IACpG,MAAMgN,GAAG,GAAG5M,UAAU,CAAC,CAAC,CAAC,IAAIA,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,IAAI,CAAC,IAAI,CAACwF,YAAY,CAACxD,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC;IACpG,MAAMiN,GAAG,GAAG7M,UAAU,CAAC,CAAC,CAAC,IAAIA,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,IAAI,CAAC,IAAI,CAACwF,YAAY,CAACxD,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC;IACpG,MAAMkN,KAAK,GAAGN,GAAG,IAAIC,GAAG,IAAIC,GAAG,IAAIC,GAAG,IAAIC,GAAG,IAAIC,GAAG;;IAEpD;IACA,KAAK,IAAIzO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4B,UAAU,CAAChC,MAAM,EAAE,EAAEI,CAAC,EAAE;MAC1C4B,UAAU,CAAC5B,CAAC,CAAC,CAAC5B,IAAI,GAAGuH,YAAY,CAAC/D,UAAU,CAAC5B,CAAC,CAAC,CAACwB,MAAM,CAAC;IACzD;IAEA,MAAMmN,MAAM,GAAGP,GAAG,GAAG9I,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAMmR,MAAM,GAAGP,GAAG,GAAG/I,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAMoR,MAAM,GAAGP,GAAG,GAAGhJ,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAMqR,MAAM,GAAGP,GAAG,GAAGjJ,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAMsR,MAAM,GAAGP,GAAG,GAAGlJ,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAMuR,MAAM,GAAGP,GAAG,GAAGnJ,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IAEjE,MAAMwR,MAAM,GAAGb,GAAG,GAAG9I,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAMyR,MAAM,GAAGb,GAAG,GAAG/I,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAM0R,MAAM,GAAGb,GAAG,GAAGhJ,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAM2R,MAAM,GAAGb,GAAG,GAAGjJ,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAM4R,MAAM,GAAGb,GAAG,GAAGlJ,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;IACjE,MAAM6R,MAAM,GAAGb,GAAG,GAAGnJ,WAAW,CAAC1D,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG/D,KAAK;;IAEjE;IACA,KAAK,IAAIuC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4B,UAAU,CAAChC,MAAM,EAAE,EAAEI,CAAC,EAAE;MAC1C4B,UAAU,CAAC5B,CAAC,CAAC,CAAC+C,cAAc,GAC1ByG,wBAAwB,CAAC5H,UAAU,CAAC5B,CAAC,CAAC,CAACwB,MAAM,EAAEI,UAAU,CAAC5B,CAAC,CAAC,CAACkB,EAAE,CAAC;IACpE;IAEA,MAAMqO,GAAG,GAAGnB,GAAG,GAAGxM,UAAU,CAAC,CAAC,CAAC,CAACmB,cAAc,GAAGrF,KAAK;IACtD,MAAM8R,GAAG,GAAGnB,GAAG,GAAGzM,UAAU,CAAC,CAAC,CAAC,CAACmB,cAAc,GAAGrF,KAAK;IACtD,MAAM+R,GAAG,GAAGnB,GAAG,GAAG1M,UAAU,CAAC,CAAC,CAAC,CAACmB,cAAc,GAAGrF,KAAK;IACtD,MAAMgS,GAAG,GAAGnB,GAAG,GAAG3M,UAAU,CAAC,CAAC,CAAC,CAACmB,cAAc,GAAGrF,KAAK;IACtD,MAAMiS,GAAG,GAAGnB,GAAG,GAAG5M,UAAU,CAAC,CAAC,CAAC,CAACmB,cAAc,GAAGrF,KAAK;IACtD,MAAMkS,GAAG,GAAGnB,GAAG,GAAG7M,UAAU,CAAC,CAAC,CAAC,CAACmB,cAAc,GAAGrF,KAAK;IAEtD,MAAMmS,IAAI,GAAGzB,GAAG,GAAGxM,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,GAAG,CAAC,CAAC;IACnD,MAAMyL,IAAI,GAAGgD,GAAG,GAAGzM,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,GAAG,CAAC,CAAC;IACnD,MAAM0L,IAAI,GAAGgD,GAAG,GAAG1M,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,GAAG,CAAC,CAAC;IACnD,MAAMkQ,IAAI,GAAGvB,GAAG,GAAG3M,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,GAAG,CAAC,CAAC;IACnD,MAAMmQ,IAAI,GAAGvB,GAAG,GAAG5M,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,GAAG,CAAC,CAAC;IACnD,MAAMoQ,IAAI,GAAGvB,GAAG,GAAG7M,UAAU,CAAC,CAAC,CAAC,CAACJ,MAAM,CAAC5B,MAAM,GAAG,CAAC,CAAC;;IAEnD;IACA,MAAMqQ,MAAM,GAAGvB,KAAK,GAAG,CAAC,GAAG,CAAC;IAC5B,MAAMwB,IAAI,GAAGtO,UAAU,CAAChC,MAAM;IAC9B;IACA,MAAM8F,KAAK,GAAG9D,UAAU,CAAC0B,GAAG,CAACO,CAAC,IAAIA,CAAC,CAACzF,IAAI,CAAC;IACzC,MAAM+R,GAAG,GAAGvO,UAAU,CAAC0B,GAAG,CAACO,CAAC,IAAIA,CAAC,CAACd,cAAc,CAAC;IACjD,MAAMqN,OAAO,GAAG,SAASA,OAAOA,CAAA,EAAI;MAClC,YAAY;;MAEZ,KAAK,IAAIpQ,CAAC,GAAGiQ,MAAM,EAAEjQ,CAAC,GAAGkQ,IAAI,EAAElQ,CAAC,EAAE,EAAE;QAClC,IAAI0F,KAAK,CAAC1F,CAAC,CAAC,CAACL,SAAS,CAAC,EAAE;UACvB,OAAOwQ,GAAG,CAACnQ,CAAC,CAAC,CAACoH,KAAK,CAAC,IAAI,EAAEzH,SAAS,CAAC;QACtC;MACF;MAEA,OAAOb,KAAK,CAACuR,UAAU,CAAClS,IAAI,EAAEwB,SAAS,EAAEiC,UAAU,CAAC;IACtD,CAAC;;IAED;IACA;IACA,SAASsM,UAAUA,CAAEoC,IAAI,EAAEC,IAAI,EAAE;MAC/B,YAAY;;MAEZ,IAAI5Q,SAAS,CAACC,MAAM,KAAKiQ,IAAI,IAAIlB,MAAM,CAAC2B,IAAI,CAAC,IAAIrB,MAAM,CAACsB,IAAI,CAAC,EAAE;QAAE,OAAOhB,GAAG,CAACnI,KAAK,CAAC,IAAI,EAAEzH,SAAS,CAAC;MAAC;MACnG,IAAIA,SAAS,CAACC,MAAM,KAAKyL,IAAI,IAAIuD,MAAM,CAAC0B,IAAI,CAAC,IAAIpB,MAAM,CAACqB,IAAI,CAAC,EAAE;QAAE,OAAOf,GAAG,CAACpI,KAAK,CAAC,IAAI,EAAEzH,SAAS,CAAC;MAAC;MACnG,IAAIA,SAAS,CAACC,MAAM,KAAK0L,IAAI,IAAIuD,MAAM,CAACyB,IAAI,CAAC,IAAInB,MAAM,CAACoB,IAAI,CAAC,EAAE;QAAE,OAAOd,GAAG,CAACrI,KAAK,CAAC,IAAI,EAAEzH,SAAS,CAAC;MAAC;MACnG,IAAIA,SAAS,CAACC,MAAM,KAAKkQ,IAAI,IAAIhB,MAAM,CAACwB,IAAI,CAAC,IAAIlB,MAAM,CAACmB,IAAI,CAAC,EAAE;QAAE,OAAOb,GAAG,CAACtI,KAAK,CAAC,IAAI,EAAEzH,SAAS,CAAC;MAAC;MACnG,IAAIA,SAAS,CAACC,MAAM,KAAKmQ,IAAI,IAAIhB,MAAM,CAACuB,IAAI,CAAC,IAAIjB,MAAM,CAACkB,IAAI,CAAC,EAAE;QAAE,OAAOZ,GAAG,CAACvI,KAAK,CAAC,IAAI,EAAEzH,SAAS,CAAC;MAAC;MACnG,IAAIA,SAAS,CAACC,MAAM,KAAKoQ,IAAI,IAAIhB,MAAM,CAACsB,IAAI,CAAC,IAAIhB,MAAM,CAACiB,IAAI,CAAC,EAAE;QAAE,OAAOX,GAAG,CAACxI,KAAK,CAAC,IAAI,EAAEzH,SAAS,CAAC;MAAC;MAEnG,OAAOyQ,OAAO,CAAChJ,KAAK,CAAC,IAAI,EAAEzH,SAAS,CAAC;IACvC;;IAEA;IACA,IAAI;MACF1B,MAAM,CAACgM,cAAc,CAACiE,UAAU,EAAE,MAAM,EAAE;QAAEtN,KAAK,EAAEzC;MAAK,CAAC,CAAC;IAC5D,CAAC,CAAC,OAAOoI,GAAG,EAAE;MACZ;MACA;MACA;IAAA;;IAGF;IACA;IACA;IACA2H,UAAU,CAACtM,UAAU,GAAGkL,aAAa;;IAErC;IACA;IACAoB,UAAU,CAACpM,kBAAkB,GAAG;MAC9BF,UAAU;MACVG,YAAY,EAAEoM;IAChB,CAAC;IAED,OAAOD,UAAU;EACnB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASsC,WAAWA,CAAErS,IAAI,EAAE6H,IAAI,EAAEpE,UAAU,EAAE;IAC5C,MAAM0E,WAAW,CAACnI,IAAI,EAAE6H,IAAI,EAAEpE,UAAU,CAAC;EAC3C;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASgE,OAAOA,CAAE6K,GAAG,EAAE;IACrB,OAAOnQ,KAAK,CAACmQ,GAAG,EAAE,CAAC,EAAEA,GAAG,CAAC7Q,MAAM,GAAG,CAAC,CAAC;EACtC;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASyF,IAAIA,CAAEoL,GAAG,EAAE;IAClB,OAAOA,GAAG,CAACA,GAAG,CAAC7Q,MAAM,GAAG,CAAC,CAAC;EAC5B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASU,KAAKA,CAAEmQ,GAAG,EAAEC,KAAK,EAAEC,GAAG,EAAE;IAC/B,OAAOtS,KAAK,CAACmP,SAAS,CAAClN,KAAK,CAACoN,IAAI,CAAC+C,GAAG,EAAEC,KAAK,EAAEC,GAAG,CAAC;EACpD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,WAAWA,CAAEH,GAAG,EAAErS,IAAI,EAAE;IAC/B,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyQ,GAAG,CAAC7Q,MAAM,EAAEI,CAAC,EAAE,EAAE;MACnC,IAAI5B,IAAI,CAACqS,GAAG,CAACzQ,CAAC,CAAC,CAAC,EAAE;QAChB,OAAOyQ,GAAG,CAACzQ,CAAC,CAAC;MACf;IACF;IACA,OAAOrC,SAAS;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASiN,OAAOA,CAAE6F,GAAG,EAAE5E,QAAQ,EAAE;IAC/B,OAAOxN,KAAK,CAACmP,SAAS,CAACjN,MAAM,CAAC6G,KAAK,CAAC,EAAE,EAAEqJ,GAAG,CAACnN,GAAG,CAACuI,QAAQ,CAAC,CAAC;EAC5D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASG,OAAOA,CAAA,EAAI;IAClB,MAAMC,UAAU,GACdrG,OAAO,CAACjG,SAAS,CAAC,CAAC2D,GAAG,CAACO,CAAC,IAAIlC,eAAe,CAACF,cAAc,CAACoC,CAAC,CAAC,CAAC,CAAC;IACjE,MAAMgI,QAAQ,GAAGxG,IAAI,CAAC1F,SAAS,CAAC;IAEhC,IAAI,OAAOkM,QAAQ,KAAK,UAAU,EAAE;MAClC,MAAM,IAAItM,SAAS,CAAC,6CAA6C,CAAC;IACpE;IAEA,OAAOwM,WAAW,CAACE,UAAU,EAAEJ,QAAQ,CAAC;EAC1C;EAEA,SAASE,WAAWA,CAAEE,UAAU,EAAEJ,QAAQ,EAAE;IAC1C,OAAO;MAAEG,OAAO,EAAE;QAAEC,UAAU;QAAEJ;MAAS;IAAE,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASD,WAAWA,CAAEC,QAAQ,EAAE;IAC9B,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MAClC,MAAM,IAAItM,SAAS,CAAC,8CAA8C,CAAC;IACrE;IAEA,OAAO;MAAEqM,WAAW,EAAE;QAAEC;MAAS;IAAE,CAAC;EACtC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,SAASA,CAAE+E,UAAU,EAAE;IAC9B,OAAOA,UAAU,IACf,OAAOA,UAAU,CAAC7E,OAAO,KAAK,QAAQ,IACtC3N,KAAK,CAACC,OAAO,CAACuS,UAAU,CAAC7E,OAAO,CAACC,UAAU,CAAC,IAC5C,OAAO4E,UAAU,CAAC7E,OAAO,CAACH,QAAQ,KAAK,UAAU;EACrD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASF,aAAaA,CAAEkF,UAAU,EAAE;IAClC,OAAOA,UAAU,IACf,OAAOA,UAAU,CAACjF,WAAW,KAAK,QAAQ,IAC1C,OAAOiF,UAAU,CAACjF,WAAW,CAACC,QAAQ,KAAK,UAAU;EACzD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASiF,SAASA,CAAEC,SAAS,EAAErM,OAAO,EAAE;IACtC,IAAI,CAACqM,SAAS,EAAE;MACd,OAAOrM,OAAO;IAChB;IACA,IAAIA,OAAO,IAAIA,OAAO,KAAKqM,SAAS,EAAE;MACpC,MAAMxK,GAAG,GAAG,IAAIrD,KAAK,CAAC,yCAAyC,GAC7D6N,SAAS,GAAG,YAAY,GAAGrM,OAAO,GAAG,GAAG,CAAC;MAC3C6B,GAAG,CAACM,IAAI,GAAG;QAAEE,MAAM,EAAErC,OAAO;QAAE8B,QAAQ,EAAEuK;MAAU,CAAC;MACnD,MAAMxK,GAAG;IACX;IACA,OAAOwK,SAAS;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASC,aAAaA,CAAEC,GAAG,EAAE;IAC3B,IAAI9S,IAAI;IACR,KAAK,MAAM+S,GAAG,IAAID,GAAG,EAAE;MACrB;MACA;MACA,IAAIhT,MAAM,CAACuP,SAAS,CAACC,cAAc,CAACC,IAAI,CAACuD,GAAG,EAAEC,GAAG,CAAC,KAC/CnQ,eAAe,CAACkQ,GAAG,CAACC,GAAG,CAAC,CAAC,IACxB,OAAOD,GAAG,CAACC,GAAG,CAAC,CAAC/P,SAAS,KAAK,QAAQ,CAAC,EAAE;QAC3ChD,IAAI,GAAG2S,SAAS,CAAC3S,IAAI,EAAE8S,GAAG,CAACC,GAAG,CAAC,CAAC/S,IAAI,CAAC;MACvC;IACF;IACA,OAAOA,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASgT,eAAeA,CAAEC,IAAI,EAAEC,MAAM,EAAE;IACtC,IAAIH,GAAG;IACP,KAAKA,GAAG,IAAIG,MAAM,EAAE;MAClB,IAAIpT,MAAM,CAACuP,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC2D,MAAM,EAAEH,GAAG,CAAC,EAAE;QACrD,IAAIA,GAAG,IAAIE,IAAI,EAAE;UACf,IAAIC,MAAM,CAACH,GAAG,CAAC,KAAKE,IAAI,CAACF,GAAG,CAAC,EAAE;YAC7B,MAAM3K,GAAG,GAAG,IAAIrD,KAAK,CAAC,aAAa,GAAGgO,GAAG,GAAG,oBAAoB,CAAC;YACjE3K,GAAG,CAACM,IAAI,GAAG;cACT1F,SAAS,EAAE+P,GAAG;cACdI,cAAc,EAAED,MAAM,CAACH,GAAG,CAAC;cAC3BK,YAAY,EAAEH,IAAI,CAACF,GAAG;YACxB,CAAC;YACD,MAAM3K,GAAG;UACX;UACA;QACF;QACA6K,IAAI,CAACF,GAAG,CAAC,GAAGG,MAAM,CAACH,GAAG,CAAC;MACzB;IACF;EACF;EAEA,MAAMM,SAAS,GAAG1S,KAAK;;EAEvB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEEA,KAAK,GAAG,SAAAA,CAAU2S,SAAS,EAAE;IAC3B,MAAMC,KAAK,GAAG,OAAOD,SAAS,KAAK,QAAQ;IAC3C,MAAMf,KAAK,GAAGgB,KAAK,GAAG,CAAC,GAAG,CAAC;IAC3B,IAAIvT,IAAI,GAAGuT,KAAK,GAAGD,SAAS,GAAG,EAAE;IACjC,MAAME,aAAa,GAAG,CAAC,CAAC;IACxB,KAAK,IAAI3R,CAAC,GAAG0Q,KAAK,EAAE1Q,CAAC,GAAGL,SAAS,CAACC,MAAM,EAAE,EAAEI,CAAC,EAAE;MAC7C,MAAM4R,IAAI,GAAGjS,SAAS,CAACK,CAAC,CAAC;MACzB,IAAI6R,eAAe,GAAG,CAAC,CAAC;MACxB,IAAIC,QAAQ;MACZ,IAAI,OAAOF,IAAI,KAAK,UAAU,EAAE;QAC9BE,QAAQ,GAAGF,IAAI,CAACzT,IAAI;QACpB,IAAI,OAAOyT,IAAI,CAACzQ,SAAS,KAAK,QAAQ,EAAE;UACtC;UACA0Q,eAAe,CAACD,IAAI,CAACzQ,SAAS,CAAC,GAAGyQ,IAAI;QACxC,CAAC,MAAM,IAAI7Q,eAAe,CAAC6Q,IAAI,CAAC,EAAE;UAChC;UACAC,eAAe,GAAGD,IAAI,CAAChQ,UAAU;QACnC;MACF,CAAC,MAAM,IAAI9D,aAAa,CAAC8T,IAAI,CAAC,EAAE;QAC9B;QACAC,eAAe,GAAGD,IAAI;QACtB,IAAI,CAACF,KAAK,EAAE;UACVI,QAAQ,GAAGd,aAAa,CAACY,IAAI,CAAC;QAChC;MACF;MAEA,IAAI3T,MAAM,CAAC+O,IAAI,CAAC6E,eAAe,CAAC,CAACjS,MAAM,KAAK,CAAC,EAAE;QAC7C,MAAM2G,GAAG,GAAG,IAAIhH,SAAS,CACvB,iCAAiC,GAAGS,CAAC,GAAG,8BAA8B,GACtE,gEAAgE,CAAC;QACnEuG,GAAG,CAACM,IAAI,GAAG;UAAE/G,KAAK,EAAEE,CAAC;UAAE+R,QAAQ,EAAEH;QAAK,CAAC;QACvC,MAAMrL,GAAG;MACX;MAEA,IAAI,CAACmL,KAAK,EAAE;QACVvT,IAAI,GAAG2S,SAAS,CAAC3S,IAAI,EAAE2T,QAAQ,CAAC;MAClC;MACAX,eAAe,CAACQ,aAAa,EAAEE,eAAe,CAAC;IACjD;IAEA,OAAO3E,mBAAmB,CAAC/O,IAAI,IAAI,EAAE,EAAEwT,aAAa,CAAC;EACvD,CAAC;EAED7S,KAAK,CAACjB,MAAM,GAAGA,MAAM;EACrBiB,KAAK,CAACC,WAAW,GAAGyS,SAAS,CAACzS,WAAW;EACzCD,KAAK,CAACuR,UAAU,GAAGG,WAAW;EAC9B1R,KAAK,CAACkT,kBAAkB,GAAGxB,WAAW;EACtC1R,KAAK,CAACwH,WAAW,GAAGA,WAAW;EAC/BxH,KAAK,CAAC0B,KAAK,GAAGA,KAAK;EACnB1B,KAAK,CAAC4B,gBAAgB,GAAGA,gBAAgB;EACzC5B,KAAK,CAACU,QAAQ,GAAGA,QAAQ;EACzBV,KAAK,CAACmT,SAAS,GAAGjT,QAAQ,EAAC;EAC3BF,KAAK,CAACkN,OAAO,GAAGA,OAAO;EACvBlN,KAAK,CAAC8M,WAAW,GAAGA,WAAW;EAC/B9M,KAAK,CAACkE,OAAO,GAAGA,OAAO;EACvBlE,KAAK,CAACmC,aAAa,GAAGA,aAAa;EACnCnC,KAAK,CAACgE,IAAI,GAAGA,IAAI;EACjBhE,KAAK,CAACiC,eAAe,GAAGA,eAAe;EACvCjC,KAAK,CAACsO,yBAAyB,GAAG,IAAI;;EAEtC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEtO,KAAK,CAACoT,OAAO,GAAG,UAAUhT,IAAI,EAAEiT,gBAAgB,EAAE;IAChD,IAAIC,MAAM,GAAG,KAAK;IAClB,IAAID,gBAAgB,KAAK,KAAK,IAAIxT,OAAO,CAACsB,GAAG,CAAC,QAAQ,CAAC,EAAE;MACvDmS,MAAM,GAAG,QAAQ;IACnB;IACAtT,KAAK,CAACU,QAAQ,CAAC,CAACN,IAAI,CAAC,EAAEkT,MAAM,CAAC;EAChC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,SAASC,mBAAmBA,CAAEnO,UAAU,EAAE;IACxC,IAAI,CAACA,UAAU,IACb,OAAOA,UAAU,CAACd,IAAI,KAAK,QAAQ,IACnC,OAAOc,UAAU,CAACkG,EAAE,KAAK,QAAQ,IACjC,OAAOlG,UAAU,CAAClB,OAAO,KAAK,UAAU,EAAE;MAC1C,MAAM,IAAIzD,SAAS,CAAC,+EAA+E,CAAC;IACtG;IACA,IAAI2E,UAAU,CAACkG,EAAE,KAAKlG,UAAU,CAACd,IAAI,EAAE;MACrC,MAAM,IAAI+B,WAAW,CACnB,qCAAqC,GAAGjB,UAAU,CAACd,IAAI,GACvD,cAAc,CAAC;IACnB;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEtE,KAAK,CAACwT,aAAa,GAAG,UAAUpO,UAAU,EAAiC;IAAA,IAA/B9C,OAAO,GAAAzB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAhC,SAAA,GAAAgC,SAAA,MAAG;MAAE4S,QAAQ,EAAE;IAAM,CAAC;IACvEF,mBAAmB,CAACnO,UAAU,CAAC;IAE/B,MAAMkG,EAAE,GAAGpL,QAAQ,CAACkF,UAAU,CAACkG,EAAE,CAAC;IAClC,MAAMoI,QAAQ,GAAGpI,EAAE,CAAChK,aAAa,CAAC0C,IAAI,CAAE2P,KAAK,IAAKA,KAAK,CAACrP,IAAI,KAAKc,UAAU,CAACd,IAAI,CAAC;IAEjF,IAAIoP,QAAQ,EAAE;MACZ,IAAIpR,OAAO,IAAIA,OAAO,CAACmR,QAAQ,EAAE;QAC/BzT,KAAK,CAAC4T,gBAAgB,CAAC;UAAEtP,IAAI,EAAEoP,QAAQ,CAACpP,IAAI;UAAEgH,EAAE,EAAElG,UAAU,CAACkG,EAAE;UAAEpH,OAAO,EAAEwP,QAAQ,CAACxP;QAAQ,CAAC,CAAC;MAC/F,CAAC,MAAM;QACL,MAAM,IAAIE,KAAK,CACb,sCAAsC,GAAGgB,UAAU,CAACd,IAAI,GAAG,QAAQ,GACnEgH,EAAE,CAACjM,IAAI,GAAG,GAAG,CAAC;MAClB;IACF;IAEAiM,EAAE,CAAChK,aAAa,CAACF,IAAI,CAAC;MACpBkD,IAAI,EAAEc,UAAU,CAACd,IAAI;MACrBgH,EAAE,EAAEA,EAAE,CAACjM,IAAI;MACX6E,OAAO,EAAEkB,UAAU,CAAClB,OAAO;MAC3BlD,KAAK,EAAEjB,YAAY;IACrB,CAAC,CAAC;EACJ,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,KAAK,CAAC6T,cAAc,GAAG,UAAU1P,WAAW,EAAE7B,OAAO,EAAE;IACrD6B,WAAW,CAAC6B,OAAO,CAACZ,UAAU,IAAIpF,KAAK,CAACwT,aAAa,CAACpO,UAAU,EAAE9C,OAAO,CAAC,CAAC;EAC7E,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEtC,KAAK,CAAC4T,gBAAgB,GAAG,UAAUxO,UAAU,EAAE;IAC7CmO,mBAAmB,CAACnO,UAAU,CAAC;IAC/B,MAAMkG,EAAE,GAAGpL,QAAQ,CAACkF,UAAU,CAACkG,EAAE,CAAC;IAClC,MAAMwI,kBAAkB,GACtBhC,WAAW,CAACxG,EAAE,CAAChK,aAAa,EAAE8I,CAAC,IAAKA,CAAC,CAAC9F,IAAI,KAAKc,UAAU,CAACd,IAAK,CAAC;IAClE,IAAI,CAACwP,kBAAkB,EAAE;MACvB,MAAM,IAAI1P,KAAK,CACb,gDAAgD,GAAGgB,UAAU,CAACd,IAAI,GAClE,MAAM,GAAGc,UAAU,CAACkG,EAAE,CAAC;IAC3B;IACA,IAAIwI,kBAAkB,CAAC5P,OAAO,KAAKkB,UAAU,CAAClB,OAAO,EAAE;MACrD,MAAM,IAAIE,KAAK,CACb,yDAAyD,CAAC;IAC9D;IACA,MAAMpD,KAAK,GAAGsK,EAAE,CAAChK,aAAa,CAACsD,OAAO,CAACkP,kBAAkB,CAAC;IAC1DxI,EAAE,CAAChK,aAAa,CAACyS,MAAM,CAAC/S,KAAK,EAAE,CAAC,CAAC;EACnC,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEhB,KAAK,CAACgU,OAAO,GAAG,UAAUC,EAAE,EAAEC,OAAO,EAAE;IACrC,IAAI,CAACjS,eAAe,CAACgS,EAAE,CAAC,EAAE;MACxB,MAAM,IAAIxT,SAAS,CAAC3B,kBAAkB,CAAC;IACzC;IACA,MAAMqV,IAAI,GAAGF,EAAE,CAACjR,kBAAkB,CAACF,UAAU;IAC7C,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiT,IAAI,CAACrT,MAAM,EAAE,EAAEI,CAAC,EAAE;MACpC,IAAIiT,IAAI,CAACjT,CAAC,CAAC,CAAC5B,IAAI,CAAC4U,OAAO,CAAC,EAAE;QACzB,OAAOC,IAAI,CAACjT,CAAC,CAAC;MAChB;IACF;IACA,OAAO,IAAI;EACb,CAAC;EAED,OAAOlB,KAAK;AACd;AAEA,eAAejB,MAAM,CAAC,CAAC","ignoreList":[]}